<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="chrome://global/skin/" type="text/css"?>
<?xml-stylesheet href="takahashi.css" type="text/css"?>

<page xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    id="presentation" xmlns:html="http:/www.w3.org/1999/xhtml"
    orient="vertical" onkeypress="Presentation.onKeyPress(event);">

<html:textarea id="builtinCode" style="visibility: collapse">

<![CDATA[
POSTSCRIPT: THIS
SLIDESHOW WILL BE
COMPLETELY REWRITTEN
WITHIN A FEW DAYS;
IT WILL BE BETTER THEN
----
Muldis D -
Portable Databases
At Full Power
(2008 July Edition)
----
Darren Duncan
Muldis Data Systems
----
Victoria, BC, Canada
----
Database Software
Products and Services
(Perl by Default)
----
For your convenience,
a copy of this slideshow is at
http://www.muldis.com
****
Another is on CPAN
----
Questions?
You may ask anywhen
But at the end is best
----
Here be the beginning
----
When someone says
"relational sucks,
we should use
[insert one of XML,
object database, ...]"
----
They are probably
talking about SQL
----
SQL is *not*
relational
----
At best, SQL is
quasi-relational
----
SQL lacks many core
relational features
----
SQL has many bad
features a
relational language
wouldn't have
----
SQL's main problems
are due to not being
truly relational
----
A truly relational
DBMS would be great
----
But those have been
few and far between
----
Now, however ...
----
A new, better
choice exists
----
I introduce
you to ...
----
Muldis D
----
New programming
language for
truly relational
databases
----
Offered up,
to replace SQL,
as the language
of choice
----
Queries
Data manipulation
Schema definitions
Stored routines
----
For DBMS makers,
as their public API
----
For database
abstraction frameworks,
as their internal AST
----
For database migration
tools, as their
interchange format
----
For data driven
applications, to say
what you really mean
----
And more besides
----
Now you may be
thinking ...
----
SQL does the job,
its good enough,
its well known
----
But I say, we can
do better than that
----
And no worries
about legacies
----
Muldis D is designed
to support legacies
while letting you grow
beyond SQL's limits
----
Anything that was
good in SQL is in
Muldis D too
----
Anything else has
a migration path
----
Muldis D is easy
to learn
----
Your existing
knowledge transfers
----
Automatic translation
is easy to achieve
----
All good so far?
Right then ...
----
Frequently
Asked Question:
"Muldis"?
What's that?
----
Frequently
Delivered Answer:
"Multiverse
of Discourse"
----
Search for the
singular of that
----
It refers to the
shared assumptions
of parties that
communicate
----
Its fundamental to
what databases *are*,
what my work's about
----
Example: I assume
you've already used
SQL and databases,
I don't have to
teach those basics
----
Databases and SQL are
part of our
universe of discourse
----
I made up "Muldis",
good for branding
----
So what is this
talk about?
----
Introduce
Muldis D
----
Why it exists,
----
Influences,
Design,
Features
----
Code examples,
What it's good at,
Solving common problems
----
Touch on implementation
----
Introduce
Muldis Rosetta
----
Reference
Implementation
of Muldis D,
in Perl
----
Why in Perl,
Features,
Design,
Examples
----
Talk about
the future
----
And this talk
is not about?
----
Explaining the
relational model
in detail
----
You should know
enough already,
or Google is
your friend
----
Giving the math proofs
for my design choices
****
See my influences
for those
----
I'm not a math
whiz or logician
****
I'm a coder,
a practitioner
----
Focusing on
implementation
****
The API is my focus
----
Focusing on the
problems of SQL
****
You know enough
----
So moving
right along ...
----
Official Muldis D
language spec is
on CPAN, in the
namespace Muldis::D
----
http://search.cpan.org/dist/Muldis-D/
----
Motivation?
Why does
Muldis D
exist?
----
I want databases
to be easier to use
----
SQL is too clumsy,
too limited for
many tasks
----
SQL is widely
incompatible
between DBMSs
----
SQL is too
inconsistent
with itself
----
I want better
inter-DBMS
portability
----
Write once,
run everywhere
----
Schemas,
Queries,
Applications,
Utilities
----
Save us from
vendor lock-in
----
Develop/test
on one DBMS,
deploy on another
----
No other existing
tool comes close
to meeting goals
----
Many other
DB wrappers,
ORMs exist
****
You've seen them
----
They're quite self-same,
don't understand
deep issues
----
To make something
better, I have to
go where they've
never gone
----
Muldis D exists
as a toolkit to
build better DB
wrappers
----
It exists to help
build better
whole *DBMSs*!
----
That is why
Muldis D exists
----
Influences
----
Number one ...
----
"Databases, Types, and
The Relational Model:
The Third Manifesto"
(TTM)
----
by Hugh Darwen
and
Christopher J. Date
----
Who were early
proponents of
Edgar F. Codd's
relational model
for databases
----
Involved with it in
IBM from the start
****
And sat on the SQL
standards committee
----
They *are*
math whizzes
and logicians
----
TTM is a formal proposal
for a solid foundation
for data and DBMSs
----
http://www.thethirdmanifesto.com
****
And there are several books
----
TTM is as an abstract
blueprint for the
design of a DBMS and
the language interface
to such a DBMS
----
It consists in essence of a
rigorous set of principles,
stated in the form of a
series of prescriptions
and proscriptions
----
There is *no*
"Object-Relational
Impedance Mismatch"!
(Just an OO-SQL
mismatch!)
----
A hypothetical language
that conforms to those,
Darwen and Date call "D"
----
The "D" part of
"Muldis D"
refers to that
----
It's just a
coincidence
my own names
start with "D"
----
TTM leaves a lot open
on the details of a
"D" language ...
----
So a "D" can have
nearly any syntax,
paradigm,
feature set
----
So it is quite feasible
to have a "D" that
closely resembles any
general purpose language
existing today
----
Darwen and Date's
teaching language
"Tutorial D" chose
to resemble SQL
in concrete syntax
----
Muldis D doesn't
----
Which brings us
to influence
number two ...
----
Perl
----
Especially
Perl 6
----
http://perlcabal.org/syn/
----
Many details of
Muldis D features,
paradigms,
naming conventions
match Perl 6
----
But Muldis D is
a lot more strict
****
And has distinct
extra features
----
Influence
number three ...
----
Functional languages
****
Haskell for example
----
Most Muldis D code
is pure functional,
with no side-effects
----
Strong determinism,
easier to prove,
easier to
auto-optimize,
auto-parallelize
----
But the bits of code
with side-effects
are imperative
----
Imperative invokes
functional, but
not the reverse
----
Number four ...
----
The SQL standard,
and SQL DBMSs
----
Many details of
Muldis D features,
paradigms, schema
organization, etc,
follow SQL examples
----
SQL got a lot right,
or good enough,
no reason to
reinvent those
----
Helps translation
to/from SQL, and
lets people reuse
their knowledge
----
Number five ...
----
In retrospect, there
are similarities
with such as FoxPro,
xBase, Ada, Lua,
who knows what else
----
Those are the
main influences
----
Design of
Muldis D
----
Not a
cargo cult!
----
Every detail was
chosen on purpose
----
Because I thought
it was the best
choice, based on
understanding
----
Or at least it
was good enough
for now
----
Not just because
that's how others
do it
----
But I do copy
what's popular
if I can't
rationalize
differences
----
Some details I came
up with myself, and
later found others
had done it before
----
Some details,
I don't know if
anyone else
has done it
----
Versioning
----
Muldis D is
designed as an
open standard
----
Influences aside,
I wrote it all
myself so far
----
I'd like open
collaboration
with others to
make it better
----
Each version of
the Muldis D
spec includes
an authority,
version number
----
Muldis D code explicitly
declares what language
version it's written in,
so its syntax and
semantics are unambiguous
----
The language can
evolve without
being hobbled by
legacy issues
----
If the language has
a problem, it can
be fixed
----
An implementation can
choose what version
it uses internally
----
It can support other
versions by translation
****
Or reject other
versions as it wants
----
The newest official spec
as of this writing is named:
Muldis_D:'http://muldis.com':'0.39.0'
----
Anyone else must
use a different
authority string
when they publish
a changed spec
----
If some large company
makes a fork, you can
say 'http://muldis.com'
to guarantee you get
the unembraced Muldis D
----
Perl 6 inspired
this versioning
method
----
Managing
Complexity
----
Muldis D
avoids
gratuitous
complexity
----
Just essentials,
most important
features, are
in the core
----
Push out as much
complexity to
extensions
or wrappers
as possible
----
But core alone
keeps enough to
be generally
useful, and fully
implement TTM
----
Only the core
is mandatory
for Muldis D
implementations
----
(Other ways
complexity is
managed are
shown later)
----
Interpretation
of the
Relational Model
----
Understanding the
relational model
is understanding
a "D" language,
and Muldis D
----
The relational model
of data is based on
predicate logic and
set theory
----
The model
assumes all data
is represented
as mathematical
N-ary relations
----
Reasoning about
such data is done
in two-valued
predicate logic
----
Every proposition
must evaluate to
just TRUE or FALSE
----
There is *no*
3+ valued logic
----
So SQL's concept
of NULL does not
exist here as an
alternative to
TRUE/FALSE
----
SQL's 3+VL
is one of its
fundamental
problems
----
The source of
many, many bugs,
much complexity,
and a scourge
to optimization
----
Muldis D has
alternate ways
to say "unknown"
or "N/A" etc,
with just 2VL
----
(That will be
explained later)
----
The basic relational
building block is
the data type, which
can have scalar values
or more complex values
----
An tuple is an unordered
set of 0..N attributes,
each attribute having a
name and value, and the
value is of a data type
----
The count of attributes
in a tuple is its degree,
the set of attribute names
is the tuple's heading,
the values are its body
----
A relation is an unordered
set of 0..N tuples that
all have the same heading,
whose values per attribute
are all of compatible types
----
A relation has its own
heading, common to all
its tuples, but it has
one even if it has
zero tuples
----
The body of a
relation is the
set of all its
tuples' bodies
----
The count of
tuples in a
relation is its
cardinality
----
SQL uses different words
for its analogies to these:
attribute -> field/column
tuple -> row
relation -> rowset
----
SQL columns are
ordered, they
don't need names,
they can have
duplicate names
----
This nature of
SQL is a source
of many problems
----
Attributes of a
tuple/relation
must all have
distinct names,
are not ordered
----
A relational heading
represents a predicate,
the heading's attributes
represent free variables
of the predicate
----
The body of a relation
represents the set of
true propositions
that can be formed from
the predicate represented
by the relation's heading
----
The body of a tuple with
the same heading provides
attribute values to instantiate
the predicate into a proposition
by substituting each
of its free variables
----
When a tuple appears in a
relation body, the
proposition it represents
is deemed to be true
----
For every compatible tuple
that does not appear in
the relation body,
its proposition is deemed
to be false
----
This assumption
is known as the
"closed world
assumption"
----
SQL is bag
oriented, allows
duplicate rows
in a rowset
----
A relation never
has duplicate
tuples, as they
are meaningless
----
Saying the same
thing twice
doesn't make
it more true
----
A "D" relation is,
by definition,
*always* in at least
first normal form
----
SQL's bag
nature
is one of its
fundamental
problems
----
When duplicate rows exist
or are produced by
operators, distinct queries
that look equivalent
give different answers
----
For example, think
of the same conceptual
SQL query written with
a join versus with
an "IN" subquery
----
Duplicates cause
a lot of bugs,
and are a scourge
to optimizers
----
In a set-oriented
language, it is
safe to make many
optimizations you
can't with bags
----
Muldis D is always
set oriented, so
results are more
predictable, easier
to auto-optimize
----
If duplicate rows in
SQL are significant
to you, such as
to indicate a
quantity ...
----
Then you should
add a 'quantity'
column instead
----
The relational model
says data is operated
on using a relational
calculus or algebra,
those being equivalent
----
Relational algebra, an offshoot
of first-order logic, is a set of
relations closed under operators;
each operator takes N relations
and results in a relation
----
(The relational
operators in
Muldis D are
detailed later)
----
Tuples, relations
of degree zero
are interesting
and useful, and
Muldis D has them
----
Zero-attribute
relations
correspond to
predicates with
no free variables
----
One can
consist of
just zero
tuples or
one tuple
----
They are identity
values for relational
operations like the
numbers 0 and 1
are for number ops
----
They are also
useful in
various other
ways
----
SQL does not
permit a row
or rowset to
have zero
fields/columns
----
That's like
trying to do
math without
using a zero
----
Data types and
the relational
model are
orthogonal
----
An attribute
value may be
a tuple or a
relation; not
just a scalar
----
All of the same
relational operators
work with relations
in attributes,
not just relvars
----
Consistency
is good
----
This is a very
powerful feature
generally missing
from SQL where only
scalars allowed
----
An RVA means a
single query can
return parent, child
tuples together,
without redundancy
----
Child tuples are
in an RVA of
parent tuples
----
Similarly, you
don't have to use
association tables
for a many-to-many
relationship
----
You don't have
to split up a
relvar into
several for
normalization
----
The use of TVAs,
RVAs does *not*
violate any
normalization
forms
----
So about a 2VL
alternative to
SQL nulls?
----
Use RVAs
as the
conceptually
nullable
attributes
----
If the RVA has
zero tuples,
that means
missing or N/A,
meaning IS NULL
----
If the RVA has
a tuple, that
means IS NOT NULL;
the tuple attr val
is the known value
----
This approach
brings consistency
for outer-joins
----
Result attributes
from the possibly
missing tuples are
RVAs with either
zero or 1+ tuples
----
So a test for
IS (NOT) NULL
becomes a test
for is the RVA
empty or not
----
Of course, an
implementation
can recognize
such cases and
optimize BTS
----
A Muldis D
implementation
over SQL would
probably map
nullable to RVA
----
So what is a
relational
database?
----
It is a set of
relation-typed
variables, or
"relvars"
----
Being composed
of relations is
what gives a
relational DB
that name
----
Or at a different
abstraction level,
it's a tuple of
relation-valued
attributes
----
A variable of
that is called
a "dbvar"
----
SQL's analogy
to a relvar
is a "table"
----
High
Level
Design
----
Muldis D is a Turing /
computationally
complete language
with fully integrated
database functionality
----
It can perform any
operation that a
typical general
purpose language
is capable of
----
It has operators,
values, variables,
conditionals,
repetition, and
system input/output
----
You *can*
write an
entire app
in just
Muldis D
----
But typically
you won't ...
----
Typical use
of Muldis D
is like what
is typical
with SQL
----
You write DB
facing parts of
apps in Muldis D,
and the rest in
something else
----
But Muldis D is
based on the
concept of a DB
embedded in your
dev environment
----
The DBMS doesn't
have to be some
separate program
your app talks to
----
AFAIK, that
was a mistaken
trend that
COBOL started
----
Rather it is like
a module in your
app that provides
relational ops
for data munging
----
As well as a
state managing
solution based
on relation
variables
----
Its up to the
implementation
whether the DBMS
is embedded or
a separate process
----
But you write code
to it the same way
regardless, like
local versus remote
procedure calls
----
When you write
Muldis D queries,
you are writing
named routines
to invoke later
----
(More later about
virtual machines
and depots)
----
The paradigm
of Muldis D
is a mixture of ...
----
1. Declarative
----
Your code says
*what* to do
rather than
*how* to do it
----
Provides a clear
distinction
between model and
implementation
----
A database
structure
is logical,
not physical
----
Don't define
abstract machine
in terms of what
system "really
does" BTS
----
2. Homoiconic
----
Muldis D code
is represented
as data structures
manipulatable
in Muldis D
----
(More on
that shortly)
----
3. Functional
----
Most Muldis D
code takes the
form of pure
functional value
expressions
----
Also, Muldis D
uses closures
or higher
order functions
to an extent
----
4. Imperative
----
The top levels
of a Muldis D
program are
imperative
----
5. Object
Oriented
----
Sub/super-typing,
substitutability,
orthogonality,
user-defined types
----
System
Catalog
----
Muldis D provides a
thorough means to both
introspect and define all
DBMS entities using just
data manipulation operators
----
The DBMS catalog is a set of
system-defined relvars which
reflect the definitions of DBMS
entities; update them to create,
alter, or drop DBMS entities
----
In fact, updating the catalog
is the fundamental way to do
data-definition in Muldis D;
any other provisions for DD
are just abstractions of this
----
Generally speaking,
users can do absolutely
everything in the DBMS
with just data querying
and updating operations
----
The SQL analogy to the
Muldis D catalog is the
"information schema",
but you can't update
those SQL tables
----
The Muldis D system
catalog is fully
decomposed like an AST,
including stored
routines and type defs
----
This nature is
the main part
of what makes
Muldis D
homoiconic
----
By contrast, most of
a SQL information
schema consists of
strings of SQL code,
not decomposed
----
Muldis D thereby
has a huge advantage
over SQL ... it is
very easy to build
or parse Muldis D code
----
You conceptually
just manipulate
tree nodes ...
though with relational
operators
----
This is in contrast
to SQL where you have
to parse or stitch
character strings
----
Your individual data
points are separate
values in Muldis D
code, you don't have
to stitch into strings
----
SQL injection
attacks have
no frequently
exploitable
analogy here!
----
Depots
----
A depot is a local
abstraction of a typically
external storage system
which holds 1 dbvar
and 1 associated catalog
----
Plus maybe other
details that help
mapping of the
abstraction to
the actuality
----
All user-defined
non-lexical code and
data lives in 1+
depots; those are
generally persisted
----
A depot can also have
just code; then
it is essentially
a dynamically
loaded library.
----
A depot is a
completely
independent
unit
----
All types or
constraints
defining a dbvar
or routine are
always kept with it
----
A depot can't have
external dependencies
to understand its
contents, implementing
DBMS aside
----
There can't be
any inter-depot
constraints, but
depots can call
each others routines
----
A DBMS can mount
multiple depots at
once, under their
own namespaces,
like a filesystem
----
You can perform
cross-database
queries or updates
on multiple depots by
mounting them at once
----
They are like
one database
during that time,
definition
isolation aside
----
So cloning a
database is
essentially just
a variable
assignment
----
A transaction will
subjugate all mounted
depots together, so
they commit or
rollback as a unit
----
You can't unmount
a depot while
a transaction
is active
----
A depot can
be mounted
read-only
----
A depot can
be persistent
or transient
----
Database and
application vars
treated the same,
all in depots
used the same way
----
Authentication
details like
DB user/pass
apply per-depot
mount, not on DBMS
----
A relational DBMS is a
program that manages
relational dbvars,
associated catalogs,
and depots in general
----
A Muldis D DBMS
is a virtual
machine
----
Transactions
----
All "D" languages
are ACID compliant
and support
arbitrary depth
nested transactions
----
You can start a
transaction within
another one
----
This lets code
blocks make themselves
atomic without worry
of how calling
code uses transactions
----
Only a parent-most
trans commit will
cause actual commit
----
Child transactions
make it easy to
rollback just part
of the overall
transaction
----
Muldis D
transactions
are always
explicitly tied to
lexical scopes
----
They are also
tied to the
exception
control-flow
mechanism
----
When you enter
a "try" block,
that begins a
new child
transaction
----
If the "try"
block executes to
its end normally,
its transaction
commits
----
If the "try" block
abnormally ends with
an exception (that
it catches), its
transaction rolls back
----
So transactions are
easy to get right
even when a block has
multiple exit points,
or throws exceptions
----
No worry about
mis-matched
transaction
start/end
statement calls
----
SQL savepoints can
emulate child
transactions,
but can be more
difficult to use
----
In Muldis D, all
kinds of changes
are subject to
transactions,
including DD
----
So schema changes
due to updating
the system
catalog can also
be rolled back
----
SQL DBMSs
mutually
differ
on this
----
SQLite subjugates
everything to
transactions,
including DD,
which is right
----
MySQL will do an
implicit commit
of prior data
changes if you, say,
create a table; bad
----
Muldis D
requires
everything
to be
explicit
----
An implementation
of Muldis D over
such as MySQL will
have to fail what
it can't support
----
There, data
definition should
only be allowed
outside of
a transaction
----
All "D" languages
support multiple
assignment, to
simultaneously update
multiple variables
----
The whole of this
multi-update is
implicitly atomic,
an implicit child
/ only transaction
----
For example, you
can insert parent
and child tuples
in diff relvars
simultaneously
----
Or debit one
bank account and
credit another
simultaneously
----
Database constraints
are tested on
multi-update
statement boundaries
----
All constraints
are immediate,
can't defer to
end of transaction
----
So database is
never seen in an
invalid state
----
There is *not*
"domain check
override" in a
"D" language
----
It is the job of
a DBMS to ensure
its data always
obeys its constraints
or business rules
----
You can't count
on the main app
to check
everything
----
There might be new
applications sharing
a DB that have
different quality
control
----
Much as
you should
never trust
the user
----
Thanks to
multi-update,
you can be strict
without losing
flexability
----
A Muldis D DBMS
*must* rollback
on disconnect;
only an explicit
success can commit
----
Many SQL DBMSs
do that too; some
will auto-commit an
incomplete transac;
AFAIK, so does ODBC
----
Implicit commit on
disconnect is bad,
making a DBMS
unreliable with any
unexpected failure
----
Dialects
----
Muldis D
code has
several
layers of
abstraction
----
Inner
Abstraction
----
You write code
by writing data;
****
This is
homoiconic
----
Conceptually,
you make ASTs,
but actually
tuples and
relations
----
Code becomes
runnable as
side-effect
of insertion
in sys catalog
----
There is no
concrete syntax,
only abstract
syntax
----
Code is
somewhat
verbose, as
typical
for ASTs
----
High
determinism
extremely
important
----
Muldis D
is not DWIM,
where DWIM
means
guessing
----
Code has
exact same
semantics
everywhere
----
Traditional
implicit semantic
diffs made
explicit choices
----
Semantics with
numeric rounding
made explicit
----
Any logical
difference
is a big
difference
----
Strongly
typed, is
type safe
----
No implicit /
automatic
sideways type
conversion /
coercion
----
For example,
converting
char data to
a number must
be explicit
----


[less organized
notes follow,
to flesh out]
----
Entity names
are case
sensitive, can
be anything,
even empty str
----
Like most
languages,
or like
quoted SQL
identifiers
----
Invoke entities
fully qualified
with namespaces
----
No unqualified
name searches,
prevents
ambiguity, bugs
----
System-defined
and user defined
entities in
separate
namespaces
----
No reserved
words; they
aren't needed
----
Character data
is always case,
accent, whitespace
sensitive
----
If you want
insensitive,
explicitly
fold case, etc
----
Numbers are
big numbers
----
No multiplicity
of types like
in SQL where
essentially
the same
----
A selector is a
routine that captures
an appearance of a
value for use in a
variable or expression
----
The term constructor
is not used because
all values in Muldis D
are conceptually
eternal and immutable
----
So it does not make
sense to say that we
are "building" one;
we are "selecting" one
----
[content goes here]
----
Copyright Â© 2008,
Darren Duncan
----
http://www.muldis.com
for email, see above
----
This slideshow text is
free documentation for software;
you can redistribute it and/or
modify it under the terms of the
GNU General Public License (GPL) as
published by the Free Software Foundation
(L<http://www.fsf.org/>); either
version 3 of the License,
or (at your option) any later version.
----
END
]]>
</html:textarea>

<deck flex="1" id="deck">

<vbox flex="1" onmousemove="Presentation.onMouseMoveOnCanvas(event);">
  <toolbox id="canvasToolbar">
    <toolbar>
      <toolbarbutton oncommand="Presentation.home()" label="|&lt;&lt;"
        observes="canBack"/>
      <toolbarbutton oncommand="Presentation.back()" label="&lt;"
        observes="canBack"/>
      <toolbarbutton oncommand="Presentation.forward()" label="&gt;"
        observes="canForward"/>
      <toolbarbutton oncommand="Presentation.end()" label="&gt;&gt;|"
        observes="canForward"/>
      <toolbarseparator/>
      <hbox align="center">
        <textbox id="current_page" size="4"
          oninput="if (this.value) Presentation.showPage(parseInt(this.value)-1);"/>
        <description value="/"/>
        <description id="max_page"/>
      </hbox>
      <toolbarseparator/>
      <vbox flex="2">
        <spacer flex="1"/>
        <scrollbar id="scroller"
          align="center" orient="horizontal"
          oncommand="Presentation.showPage(parseInt(event.target.getAttribute('curpos')));"
          onclick="Presentation.showPage(parseInt(event.target.getAttribute('curpos')));"
          onmousedown="Presentation.onScrollerDragStart();"
          onmousemove="Presentation.onScrollerDragMove();"
          onmouseup="Presentation.onScrollerDragDrop();"/>
        <spacer flex="1"/>
      </vbox>
      <toolbarseparator/>
      <spacer flex="1"/>
      <toolbarseparator/>
      <toolbarbutton id="toggleEva" label="Eva"
        type="checkbox"
        autoCheck="false"
        oncommand="Presentation.toggleEvaMode();"/>
      <toolbarseparator/>
      <toolbarbutton label="Edit"
        oncommand="Presentation.toggleEditMode();"/>
      <toolbarbutton oncommand="Presentation.reload();" label="Reload"/>
    </toolbar>
  </toolbox>
  <vbox flex="1" id="canvas"
    onclick="Presentation.onPresentationClick(event);">
    <spacer flex="1"/>
    <hbox flex="1">
      <spacer flex="1"/>
      <vbox id="content"/>
      <spacer flex="1"/>
    </hbox>
    <spacer flex="1"/>
  </vbox>
</vbox>

<vbox flex="1" id="edit">
  <toolbox>
    <toolbar>
      <toolbarbutton label="New Page"
        oncommand="Presentation.addPage()"/>
      <spacer flex="1"/>
      <toolbarseparator/>
      <toolbarbutton label="View"
        oncommand="Presentation.toggleEditMode();"/>
      <toolbarbutton oncommand="Presentation.reload();" label="Reload"/>
    </toolbar>
  </toolbox>
  <textbox id="textField" flex="1" multiline="true"
    oninput="Presentation.onEdit()"/>
  <hbox collapsed="true">
    <iframe id="dataLoader" onload="if (window.Presentation) Presentation.onDataLoad();"/>
  </hbox>
</vbox>

</deck>

<broadcasterset>
  <broadcaster id="canBack"/>
  <broadcaster id="canForward"/>
</broadcasterset>

<commandset>
  <command id="cmd_forward"
    oncommand="if (Presentation.isPresentationMode) Presentation.forward();"/>
  <command id="cmd_back"
    oncommand="if (Presentation.isPresentationMode) Presentation.back();"/>
  <command id="cmd_home"
    oncommand="if (Presentation.isPresentationMode) Presentation.home();"/>
  <command id="cmd_end"
    oncommand="if (Presentation.isPresentationMode) Presentation.end();"/>
</commandset>

<keyset>
  <key keycode="VK_ENTER"    command="cmd_forward"/>
  <key keycode="VK_RETURN"   command="cmd_forward"/>
  <key keycode="VK_PAGE_DOWN"  command="cmd_forward"/>
  <key keycode="VK_RIGHT"    command="cmd_forward"/>
  <key keycode="VK_DOWN"     command="cmd_forward"/>
  <!-- key keycode="VK_BACK_SPACE" command="cmd_back"/-->
  <key keycode="VK_PAGE_UP"  command="cmd_back"/>
    <!-- <key keycode="VK_BACK_UP"  command="cmd_back"/>-->
    <!-- <key keycode="VK_BACK_LEFT"  command="cmd_back"/>-->
  <key keycode="VK_HOME"     command="cmd_home"/>
  <key keycode="VK_END"    command="cmd_end"/>
  <key key="n" modifiers="accel" oncommand="Presentation.addPage();"/>
  <key key="r" modifiers="accel" oncommand="window.location.reload();"/>
  <key key="e" modifiers="accel" oncommand="Presentation.toggleEditMode();"/>
  <key key="a" modifiers="accel" oncommand="Presentation.toggleEvaMode();"/>
</keyset>

<script src="takahashi.js" type="application/x-javascript" />

</page>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1
   -
   - The contents of this file [except for the slideshow text in the CDATA
   - block, which is independent user data to display by the rest of the file]
   - are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is the Takahashi-Method-based Presentation Tool in XUL.
   -
   - The Initial Developer of the Original Code is SHIMODA Hiroshi.
   - Portions created by the Initial Developer are Copyright (C) 2005
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s): SHIMODA Hiroshi <piro@p.club.ne.jp>
   -
   - ***** END LICENSE BLOCK ***** -->
