=pod

=encoding utf8

=head1 NAME

Muldis::D::Ext::Temporal -
Muldis D extension for temporal data types and operators

=head1 VERSION

This document is Muldis::D::Ext::Temporal version 0.113.0.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

=head1 DESCRIPTION

B<TODO: PARTIALLY REWRITE THIS DOCUMENT; REFACTOR THE TEMPORAL TYPES!>

Muldis D has a mandatory core set of system-defined (eternally available)
entities, which is referred to as the I<Muldis D core> or the I<core>; they
are the minimal entities that all Muldis D implementations need to provide;
they are mutually self-describing and are either used to bootstrap the
language or they constitute a reasonable minimum level of functionality for
a practically useable industrial-strength (and fully I<TTM>-conforming)
programming language; any entities outside the core, called I<Muldis D
extensions>, are non-mandatory and are defined in terms of the core or each
other, but the reverse isn't true.

This current C<Temporal> document describes the system-defined I<Muldis D
Temporal Extension>, which consists of temporal data types and operators,
particularly calendar dates and intervals.  The bundled data types describe
common kinds of temporal artifacts according to modern calendars.  They can
represent a variety of precisions and epochs so that users can employ them
in a way that most accurately represents what they actually know about
their data.  Any types whose names start with C<TAI> are TAI temporal
artifacts expressed simply as a count of seconds from a TAI epoch,
and any whose names start with C<UTC> or C<Float> are based on
year-month-day-hour-minute-second components in the Gregorian calendar,
either the UTC time zone or a "floating" time zone.

The I<Muldis D Temporal Extension> is expressly not meant to be complete by
any means, as a solution for working with temporal data.  Rather it is
meant to be "good enough" for many common uses.  Moreover it isn't intended
to have a scope much greater than the temporal data handling abilities of
the ISO/IEC 9075 (SQL) standard and the Perl L<DateTime> module.  In many
situations, users may be better off ignoring this extension, and using
Muldis D's core facilities for user-defined types and routines, and code an
alternate temporal data solution that works best for them, building over
Muldis D's basic integer or such types, or alternately using third-party
Muldis D temporal extensions.  This current extension exists primarily to
ease the porting of SQL databases to Muldis D, and save users accustomed to
SQL's facilities and the Perl DateTime module's facilities from having to
frequently reinvent the wheel.  The details of this Muldis D extension are
typically just the same as those in ISO/IEC 9075 (SQL) section "4.6
Datetimes and intervals", but with some alterations.  As with SQL and
DateTime, dates and times are specified as YYYY.MM.DD.HH.II.SS+ in the
proleptic Gregorian calendar, specifically the version with a year zero and
negative year numbers, either in the UTC time-zone or floating / no-zone.
Matters of "local time" or specifications of other time-zones or daylight
savings time are not supported for encoding into values, due partly to
various logical problems and complexity such as an inability to distinguish
between duplicated times of day around a daylight savings adjustment.  If
you want to work with "local time", you generally will have to convert to
UTC on input and from UTC on output with the I<Muldis D Temporal
Extension>; UTC is better for storage, local is maybe better for display.

Now the general practice of working with calendar-centric temporal data is
an imperfect process and can not be done with perfect mathematical
precision.  This is partly because our temporal data in general comes from
measurements of environmental cycles (such as rotations of the Earth,
revolutions of the Earth's moon around it, and revolutions of the Earth
around its sun), which not only are rounded approximations, but we also
know for a fact that the actual amount of time these events takes slowly
varies over time (such as that the rotation of the Earth is gradually
slowing as the moon gradually drifts away from it each year).  Also our
typical calendaring systems change over time, sometimes to deal with our
improved ability to measure the environmental cycles or compensate for
drift; witness for example a large part of the world's moving from the
Julian to the Gregorian calendar.  So the best we have to work with in
general will involve rounding, and sometimes a conceptually commutative or
associative sequence of operations on temporal data may not yield an
identical result from identical inputs when the operations are rearranged
into a conceptually equivalent but different form; a simple example being
adding or subtracting dates.  All the issues can be complicated.

This current document does not describe the polymorphic operators that all
types, or some types including core types, have defined over them; said
operators are defined once for all types in L<Muldis::D::Core>.

I<This documentation is pending.>

=head1 TYPE SUMMARY

Following are all the data types described in this document, arranged in a
type graph according to their proper sub|supertype relationships:

    sys.std.Core.Type.Universal

        sys.std.Core.Type.Empty

        sys.std.Core.Type.Scalar
            sys.std.Core.Type.DHScalar
                sys.std.Core.Type.Cat.OVLScalar

                    # The following are all regular ordered scalar types.

                    sys.std.Temporal.Type.TAIInstant
                    sys.std.Temporal.Type.TAIDuration

                    sys.std.Temporal.Type.UTCInstant
                        sys.std.Temporal.Type.UTCDateTime
                        sys.std.Temporal.Type.UTCDate
                        sys.std.Temporal.Type.UTCTime

                    sys.std.Temporal.Type.FloatInstant
                        sys.std.Temporal.Type.FloatDateTime
                        sys.std.Temporal.Type.FloatDate
                        sys.std.Temporal.Type.FloatTime

                    sys.std.Temporal.Type.UTCDuration

                    sys.std.Core.Type.Int

                        sys.std.Core.Type.NNInt

                            sys.std.Core.Type.PInt

                                # These are all finite positive int types.

                                sys.std.Temporal.Type.PInt[12|31]

                            # These are all finite non-negative int types.

                            sys.std.Temporal.Type.NNInt[23|59]

                    sys.std.Core.Type.Rat
                        sys.std.Core.Type.NNRat

                            # These're all infinite non-neg rational types.

                            sys.std.Temporal.Type.NNRatLT62

I<This documentation is pending.>

=head1 DATA TYPES FOR TEMPORAL ARTIFACTS

These non-core data types are all ordered scalar types.

=head2 sys.std.Temporal.Type.PInt[12|31]

C<PInt[12|31]> is a proper subtype of
C<PInt> where all member values are not greater than 12|31.  Its default
and minimum value is 1; its maximum value is 12|31.  The significance is
that in proleptic Gregorian dates, the [month|month-day] portion is a
positive integer not greater than 12|31.

=head2 sys.std.Temporal.Type.NNInt[23|59]

C<NNInt[23|59]> is a proper subtype of
C<NNInt> where all member values are not greater than 23|59.  Its default
and minimum value is 0; its maximum value is 23|59.  The significance is
that in the time portion of proleptic Gregorian dates, the [hour|minute]
portion is a non-negative integer not greater than 23|59.

=head2 sys.std.Temporal.Type.NNRatLT62

C<NNRatLT62> is a proper subtype of
C<NNRat> where all member values are less than 62.  Its default and minimum
value is 0; its maximum value is conceptually infinitessimally less than 62
and practically impossible.  The significance is that in the time portion
of proleptic Gregorian dates, the 'second' portion is a non-negative
rational less than 62.  The cardinality of this type is infinity; to define
a most-generalized finite C<NNRatLT62> subtype, you must specify the
greatest magnitude value denominator of its C<ratio> possrep, that is, its
maximum precision (that denominator is 10^9 if we're working to nanosecond
precision).

=head2 sys.std.Temporal.Type.TAIInstant

A C<TAIInstant> is a single point in time
which is specified with arbitrary precision in terms of atomic seconds
with fractions.  That is, a C<TAIInstant> is defined as a point on the
canonical continuous timeline of International Atomic Time (TAI; this is a
perfectly linear scale with no discontinuities), specified by a scalar
number of TAI seconds since the TAI epoch, which is exactly midnight at the
start of January 1st of the year 1958 CE.  Put another way, the
C<TAIInstant> type is intended to have exactly the same meaning as the
same-named type of Perl 6 (see L<http://perlcabal.org/syn/S02.html> for
details).  I<Or at least that used to be true; TODO: update this.>

A C<TAIInstant> has 1 system-defined possrep named C<tai_instant> which
consists of 1 C<Rat>-typed attribute named C<seconds>.  A C<TAIInstant> is
a simple wrapper for a C<Rat> and all of its other details such as default
and minimum and maximum values and cardinality and default ordering
algorithm all correspond directly.  But C<TAIInstant> is explicitly
disjoint from C<Rat> due to having a different intended interpretation.

The C<TAIInstant> type is intended more for use with system event
time-stamps or sensitive scientific applications and is not necessarily the
best choice for common human-specified temporal artifacts according to
various calendars, since there is no fixed conversion rate between them in
the general case that includes future dates, and also calendar-based
artifacts may be very non-specific; see also the C<UTCInstant> data type,
which is defined in terms of calendars.

=head2 sys.std.Temporal.Type.TAIDuration

A C<TAIDuration> is a single amount of
time, which is specified with arbitrary precision in terms of the same
units as a C<TAIInstant> is structured with.  A C<TAIDuration> is not fixed
to any point in time.  A C<TAIDuration> is the result type of taking the
difference between two C<TAIInstant> values, but it is not defined in terms
of said two values.  The C<TAIDuration> type is intended to have exactly
the same meaning as the same-named type of Perl 6, as per C<TAIInstant>.  A
C<TAIDuration> has 1 system-defined possrep named C<tai_duration> which
consists of 1 C<Rat>-typed attribute named C<seconds>.  A C<TAIDuration> is
a simple wrapper for a C<Rat> in all ways as per C<TAIInstant>.  But
C<TAIDuration> is explicitly disjoint from C<TAIInstant> due to having a
different intended interpretation.  The C<TAIDuration> type is intended
more for benchmarking or scientific applications and is not intended for
human-specified calendar based artifacts; again see the C<UTCDuration> data
type for alternatives.

=head2 sys.std.Temporal.Type.UTCInstant

A C<UTCInstant> is a single point in time,
or a periodic multiplicity of points in time, which is specified with
arbitrary precision using a set of unit quantities involving multiple
units, where the units do not generally have a fixed conversion rate with
each other.  A C<UTCInstant> is defined against the proleptic Gregorian
calendar and uses these 6 units: terrestrial year, month within year, day
within month, hour within day, minute within hour, second and possibly
fraction of a second within minute; the only fixed conversion rates are: 1
year is 12 months, 1 hour is 60 minutes.  A C<UTCInstant> is defined
against the UTC time-zone specifically, so you use it when you I<do know>
that the instant you are specifying was experienced in the UTC time-zone
with the specified unit values; if you are otherwise working according to
your local time-zone, you would be selecting your C<UTCInstant> values in
terms of a time-zone offset (and daylight-savings time offset if
applicable) from your local time.

A C<UTCInstant> has 1 system-defined possrep whose name is C<instant>,
which has 6 attributes: C<year> (a C<maybe_of.Int>), C<month> (a
C<maybe_of.PInt12>), C<day> (a C<maybe_of.PInt31>), C<hour> (a
C<maybe_of.NNInt23>), C<minute> (a C<maybe_of.NNInt59>), C<second> (a
C<maybe_of.NNRatLT62>).  For each attribute, that attribute should be a
C<Single> if a quanity in that unit is known, and it should be C<Nothing>
if there is no applicable or known quantity in that unit.  The C<year>
values greater than zero are CE, those less than zero are BCE.  The
C<month> value C<1> corresponds to the month of January, and C<12>
corresponds to the month of December.  The value of C<day> is further
restricted depending on the combined values of C<year> and C<month>, such
that all 3 together may only represent a valid date of the proleptic
Gregorian calendar (taking into account leap-days); so for example you
can't select April 31st or February 30th.  The value of C<second> is
further restricted as per C<day>, as leap-seconds are only valid on certain
days, and perhaps only when the hour-minute is 23-59.  These further
restrictions do not apply if any of the attributes needed to calculate
whether they apply are C<Nothing>.

The default value of C<UTCInstant> is exactly midnight at the start of
January 1st of the year 1 CE (which also happens to be the proleptic
Gregorian calendar's epoch); its minimum and maximum values are
conceptually infinities and practically impossible.  The cardinality of
this type is infinity; to define a most-generalized finite C<UTCInstant>
subtype, you must specify the earliest and latest dates it includes
(minimally, the earliest and latest C<year>), as well as the granularity of
the type as a fraction of a second (minimally, the largest value
denominator for C<second>).

The C<UTCInstant> type has a default ordering algorithm; for 2 distinct
C<UTCInstant> values, the earlier value is ordered before the later value.
To make full ordering of C<UTCInstant> values possible and deterministic
(though semi-meaningless) in the face of unknown/inapplicable attributes;
the algorithm works like this: 1. ordering is done numerically one
attribute at a time, from the largest units to the smallest; 2. for each
attribute, the C<Nothing> value will order before any C<Single> value.

=head2 sys.std.Temporal.Type.UTCDateTime

A C<UTCDateTime> is a single specific
time on a specific date, with precision to arbitrary fractions of a second.
A C<UTCDateTime> is a proper subtype of C<UTCInstant> where all 6
attributes of its C<instant> possrep have C<Single> / known values.  A
C<UTCDateTime> adds 1 system-defined possrep whose name is C<datetime>,
which has 6 attributes: C<year> (an C<Int>), C<month> (a C<PInt12>), C<day>
(a C<PInt31>), C<hour> (a C<NNInt23>), C<minute> (a C<NNInt59>), C<second>
(a C<NNRatLT62>).  The default and minimum and maximum values are the same
as for C<UTCInstant>.

=head2 sys.std.Temporal.Type.UTCDate

A C<UTCDate> is a single specific
terrestrial day, at no particular time of day.  A C<UTCDate> is a proper
subtype of C<UTCInstant> where the 3 attributes of its C<instant> possrep
named [C<year>, C<month>, C<day>] have C<Single> / known values, and the
other 3 C<instant> possrep attributes each have the C<Nothing> / unknown
value.  A C<UTCDate> adds 1 system-defined possrep whose name is C<date>,
which has 3 attributes: C<year> (an C<Int>), C<month> (a C<PInt12>), C<day>
(a C<PInt31>).  The default value of C<UTCDate> is January 1st of the year
1 CE; its minimum and maximum values are conceptually infinities and
practically impossible.  The cardinality of this type is infinity; to
define a most-generalized finite C<UTCDate> subtype, you must specify the
earliest and latest dates it includes (minimally, the earliest and latest
C<year>).

=head2 sys.std.Temporal.Type.UTCTime

A C<UTCTime> is a single specific time
that isn't on any day in particular (or alternately that is repeating on
multiple days), with a precision to arbitrary fractions of a second; its
allowed range is between zero seconds (inclusive) and 1 terrestrial day
(exclusive).  A C<UTCTime> is a proper subtype of C<UTCInstant> where the 3
attributes of its C<instant> possrep named [C<hour>, C<minute>, C<second>]
have C<Single> / known values, and the other 3 C<instant> possrep
attributes each have the C<Nothing> / unknown value.  A C<UTCTime> adds 1
system-defined possrep whose name is C<time>, which has 3 attributes:
C<hour> (a C<NNInt23>), C<minute> (a C<NNInt59>), C<second> (a
C<NNRatLT62>).  The default and minimum value of C<UTCTime> is exactly
midnight at the start of its day (all of its C<time> possrep attributes are
zero-valued); its maximum value is conceptually infinitessimally less than
the midnight at the end of its day and practically impossible.  The
cardinality of this type is infinity; to define a most-generalized finite
C<UTCTime> subtype, you must specify the granularity of the type as a
fraction of a second (minimally, the largest value denominator for
C<second>).

=head2 sys.std.Temporal.Type.FloatInstant

A C<FloatInstant> is exactly the same as
C<UTCInstant>, but that it is not defined against any specific time-zone,
but rather is floating; you use it when you I<do not know> in what
time-zone the specified date+time is supposed to refer to (it was just
I<somewhere>), or when that detail is not significant.  The C<FloatInstant>
type is disjoint from the C<UTCInstant> type, but all of its details save
its name and one aspect of its interpretation (representation, cardinality,
default values, ordering algorithm, etc) are identical.

=head2 sys.std.Temporal.Type.FloatDateTime

C<FloatDateTime> is to C<UTCDateTime>
as C<FloatInstant> is to C<UTCInstant>.

=head2 sys.std.Temporal.Type.FloatDate

C<FloatDate> is to C<UTCDate> as C<FloatInstant> is to C<UTCInstant>.

=head2 sys.std.Temporal.Type.FloatTime

C<FloatTime> is to C<UTCTime> as C<FloatInstant> is to C<UTCInstant>.

=head2 sys.std.Temporal.Type.UTCDuration

A C<UTCDuration> is a single amount of
time, which is specified with arbitrary precision using 6 quantities in the
same units as a C<UTCInstant> is structured with.  It is not fixed to any
date or time and is agnostic to the calendar, other than the interpretation
of units' size.  A C<UTCDuration> is the result type of taking the
difference between two C<UTCInstant> values or between two C<FloatInstant>
values, but it is not defined in terms of said two values.

A C<UTCDuration> has 1 system-defined possrep whose name is C<duration>,
which has 6 attributes: C<years>, C<months>, C<days>, C<hours>, C<minutes>,
(all 5 each a C<maybe_of.Int>), C<seconds> (a C<maybe_of.Rat>).  Each
attribute value is C<Nothing> when it is unknown or not applicable, and a
C<Single> when it is known and applicable, as per a C<UTCInstant>.

The default value of C<UTCDuration> is zero; its minimum and maximum values
are conceptually infinities and practically impossible.  The cardinality of
this type is infinity; to define a most-generalized finite C<UTCDuration>
subtype, you must specify the maximum amount of time that its values may
be, plus the granularity of the type in fractions of a second; in other
words, you specify C<seconds> as per a C<Rat> and the other attributes as
per C<Int>.

The C<UTCDuration> type has a default ordering algorithm which is
structurally the same as for C<UTCInstant>: 1. ordering is done numerically
one attribute at a time, from the largest units to the smallest; 2. for
each attribute, the C<Nothing> value will order before any C<Single> value.
However, because the unit values are unconstrained, this algorithm will
sort [0 months and 40 days] before [1 month and 0 days] even though common
sense says the second should be before the first.  So for ordering to make
sense, either in general leave all attributes C<Nothing> except one
(recommended), or otherwise be careful to just set compatible attribute
values.

=head1 FUNCTIONS FOR TEMPORAL MATH

These functions implement commonly used temporal math operations.

=head1 TAIInstant

=head2 sys.std.Temporal.TAIInstant.diff

C<< function sys.std.Temporal.TAIInstant.diff (TAIDuration <--
$minuend : TAIInstant, $subtrahend : TAIInstant) >>

This function results in the duration-typed difference when its
instant-typed C<subtrahend> argument is subtracted from its instant-typed
C<minuend> argument.  The result is the amount of time between the 2
arguments, which may be positive or negative depending on which argument
was earlier.

=head2 sys.std.Temporal.TAIInstant.abs_diff

C<< function sys.std.Temporal.TAIInstant.abs_diff (TAIDuration <--
$topic : TAIInstant, $other : TAIInstant) >>

This symmetric function results in the absolute difference between its 2
arguments.  The result is the amount of time between the 2 arguments, which
is always non-negative.

=head2 sys.std.Temporal.TAIInstant.later

C<< function sys.std.Temporal.TAIInstant.later (TAIInstant <--
$instant : TAIInstant, $duration : TAIDuration) >>

This function results in the instant that is later than its C<instant>
argument by the amount of time in the C<duration> argument.

=head2 sys.std.Temporal.TAIInstant.earlier

C<< function sys.std.Temporal.TAIInstant.earlier (TAIInstant <--
$instant : TAIInstant, $duration : TAIDuration) >>

This function results in the instant that is earlier than its C<instant>
argument by the amount of time in the C<duration> argument.

=head1 TAIDuration

=head2 sys.std.Temporal.TAIDuration.abs

C<< function sys.std.Temporal.TAIDuration.abs (TAIDuration <--
$topic : TAIDuration) >>

This function results in the absolute value of its argument.

=head2 sys.std.Temporal.TAIDuration.sum

C<< function sys.std.Temporal.TAIDuration.sum (TAIDuration <--
$topic? : bag_of.TAIDuration) >>

This function results in the sum of the N element values of its argument;
it is a reduction operator that recursively takes each pair of input values
and adds (which is both commutative and associative) them together until
just one is left, which is the result.  If C<topic> has zero values, then
C<sum> results in the duration zero, which is the identity value for
addition.

=head2 sys.std.Temporal.TAIDuration.diff

C<< function sys.std.Temporal.TAIDuration.diff (TAIDuration <--
$minuend : TAIDuration, $subtrahend : TAIDuration) >>

This function results in the difference when its C<subtrahend> argument is
subtracted from its C<minuend> argument.

=head1 UTCInstant

=head2 sys.std.Temporal.UTCInstant.diff

C<< function sys.std.Temporal.UTCInstant.diff (UTCDuration <--
$minuend : UTCInstant, $subtrahend : UTCInstant) >>

This function results in the duration-typed difference when its
instant-typed C<subtrahend> argument is subtracted from its instant-typed
C<minuend> argument.  The result is the amount of time between the 2
arguments, which may be positive or negative depending on which argument
was earlier.

=head2 sys.std.Temporal.UTCInstant.abs_diff

C<< function sys.std.Temporal.UTCInstant.abs_diff (UTCDuration <--
$topic : UTCInstant, $other : UTCInstant) >>

This symmetric function results in the absolute difference between its 2
arguments.  The result is the amount of time between the 2 arguments, which
is always non-negative.

=head2 sys.std.Temporal.UTCInstant.later

C<< function sys.std.Temporal.UTCInstant.later (UTCInstant <--
$instant : UTCInstant, $duration : UTCDuration) >>

This function results in the instant that is later than its C<instant>
argument by the amount of time in the C<duration> argument.

=head2 sys.std.Temporal.UTCInstant.earlier

C<< function sys.std.Temporal.UTCInstant.earlier (UTCInstant <--
$instant : UTCInstant, $duration : UTCDuration) >>

This function results in the instant that is earlier than its C<instant>
argument by the amount of time in the C<duration> argument.

=head1 FloatInstant

=head2 sys.std.Temporal.FloatInstant.diff

C<< function sys.std.Temporal.FloatInstant.diff (UTCDuration <--
$minuend : FloatInstant, $subtrahend : FloatInstant) >>

This function results in the duration-typed difference when its
instant-typed C<subtrahend> argument is subtracted from its instant-typed
C<minuend> argument.  The result is the amount of time between the 2
arguments, which may be positive or negative depending on which argument
was earlier.

=head2 sys.std.Temporal.FloatInstant.abs_diff

C<< function sys.std.Temporal.FloatInstant.abs_diff (UTCDuration <--
$topic : FloatInstant, $other : FloatInstant) >>

This symmetric function results in the absolute difference between its 2
arguments.  The result is the amount of time between the 2 arguments, which
is always non-negative.

=head2 sys.std.Temporal.FloatInstant.later

C<< function sys.std.Temporal.FloatInstant.later (FloatInstant <--
$instant : FloatInstant, $duration : UTCDuration) >>

This function results in the instant that is later than its C<instant>
argument by the amount of time in the C<duration> argument.

=head2 sys.std.Temporal.FloatInstant.earlier

C<< function sys.std.Temporal.FloatInstant.earlier (FloatInstant <--
$instant : FloatInstant, $duration : UTCDuration) >>

This function results in the instant that is earlier than its C<instant>
argument by the amount of time in the C<duration> argument.

=head1 UTCDuration

Note that all inter-duration operators in general will just do the math on
each corresponding attribute individually and not normalize between
attributes.  This is subject to be revised in the future.

=head2 sys.std.Temporal.UTCDuration.abs

C<< function sys.std.Temporal.UTCDuration.abs (UTCDuration <--
$topic : UTCDuration) >>

This function results in the absolute value of its argument.

=head2 sys.std.Temporal.UTCDuration.sum

C<< function sys.std.Temporal.UTCDuration.sum (UTCDuration <--
$topic? : bag_of.UTCDuration) >>

This function results in the sum of the N element values of its argument;
it is a reduction operator that recursively takes each pair of input values
and adds (which is both commutative and associative) them together until
just one is left, which is the result.  If C<topic> has zero values, then
C<sum> results in the duration zero, which is the identity value for
addition.

=head2 sys.std.Temporal.UTCDuration.diff

C<< function sys.std.Temporal.UTCDuration.diff (UTCDuration <--
$minuend : UTCDuration, $subtrahend : UTCDuration) >>

This function results in the difference when its C<subtrahend> argument is
subtracted from its C<minuend> argument.

=head1 FUNCTIONS FOR CONVERSION BETWEEN UTC AND TAI

These functions convert between C<UTCDateTime> values and equal or nearly
equal C<TAIInstant> values.  I<WARNING:  These functions may not produce
consistent results over time when dealing with future dates because it is
unknown in advance when leap seconds will be added to the UTC time scale,
and TAI has no leap seconds.>

=head2 sys.std.Temporal.UTCInstant.UTC_from_TAI

C<< function sys.std.Temporal.UTCInstant.UTC_from_TAI (UTCDateTime <--
$tai : TAIInstant) >>

This selector function results in the C<UTCDateTime> value that is
conceptually equal to its C<TAIInstant> argument, insofar as relevant leap
seconds are known.

=head2 sys.std.Temporal.UTCInstant.TAI_from_UTC

C<< function sys.std.Temporal.UTCInstant.TAI_from_UTC (TAIInstant <--
$utc : UTCDateTime) >>

This selector function results in the C<TAIInstant> value that is
conceptually equal to its C<UTCDateTime> argument, insofar as relevant leap
seconds are known.

=head1 SYSTEM-SERVICES FOR CURRENT DATES AND TIMES

These system-service routines provide ways to get the current date or time
from the system.

=head2 sys.std.Temporal.TAIInstant.fetch_curr_instant

C<system-service sys.std.Temporal.TAIInstant.fetch_curr_instant
(&$target : TAIInstant)>

This system-service routine will update the variable supplied as its
C<target> argument so that it holds the value of the current TAI instant as
taken with the full precision that the implementation's system clock or
used time server supports.

=head2 sys.std.Temporal.UTCInstant.fetch_curr_datetime

C<system-service sys.std.Temporal.UTCInstant.fetch_curr_datetime
(&$target : UTCDateTime)>

This system-service routine will update the variable supplied as its
C<target> argument so that it holds the value of the current UTC date and
time (YMDHIS) as taken with the full precision that the implementation's
system clock or used time server supports.

=head2 sys.std.Temporal.UTCInstant.fetch_curr_date

C<system-service sys.std.Temporal.UTCInstant.fetch_curr_date
(&$target : UTCDate)>

This system-service routine is the same as
C<sys.std.Temporal.UTCInstant.fetch_curr_date> except that it only
produces an instant value with the date (YMD) attributes set.

=head2 sys.std.Temporal.UTCInstant.fetch_curr_time

C<system-service sys.std.Temporal.UTCInstant.fetch_curr_time
(&$target : UTCTime)>

This system-service routine is the same as
C<sys.std.Temporal.UTCInstant.fetch_curr_date> except that it only
produces an instant value with the time (HIS) attributes set; it still
retains the full precision.

=head2 sys.std.Temporal.FloatInstant.fetch_curr_datetime

C<system-service sys.std.Temporal.FloatInstant.fetch_curr_datetime
(&$target : FloatDateTime)>

This system-service routine will update the variable supplied as its
C<target> argument so that it holds the value of the current floating date
and time (YMDHIS) as taken with the full precision that the
implementation's system clock or used time server supports.

=head2 sys.std.Temporal.FloatInstant.fetch_curr_date

C<system-service sys.std.Temporal.FloatInstant.fetch_curr_date
(&$target : FloatDate)>

This system-service routine is the same as
C<sys.std.Temporal.FloatInstant.fetch_curr_date> except that it only
produces an instant value with the date (YMD) attributes set.

=head2 sys.std.Temporal.FloatInstant.fetch_curr_time

C<system-service sys.std.Temporal.FloatInstant.fetch_curr_time
(&$target : FloatTime)>

This system-service routine is the same as
C<sys.std.Temporal.FloatInstant.fetch_curr_date> except that it only
produces an instant value with the time (HIS) attributes set; it still
retains the full precision.

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::SeeAlso> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright Â© 2002-2010, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
