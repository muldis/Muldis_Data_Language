=pod

=encoding utf8

=head1 NAME

Muldis::D::Core::Types_Catalog -
Muldis D catalog-defining data types

=head1 VERSION

This document is Muldis::D::Core::Types_Catalog version 0.52.0.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document before
you read this one, which provides subservient details.  Moreover, you
should read the L<Muldis::D::Core> document before this current
document, as that forms its own tree beneath a root document branch.

=head1 DESCRIPTION

This document contains one or more sections that were moved here from
L<Muldis::D::Core> so that that other document would not be too
large.

These core data types are more special-purpose in nature and are intended
for use in defining or working with the system catalog.  Those types that
are nonscalar are completely defined types.

Note that whenever an attribute of one of the nonscalar types isn't
significant, given the context (determined by other attributes of the same
type), and should be ignored, its value is the default for its type.

Note that many of the tuple types might conceptually have C<name>
attributes, but those would actually be provided by any larger types in
which they are embedded, rather than by these types themselves.

I<To keep things simpler for now, most constraint definitions for these
types are missing, or just defined informally.>

=head1 TYPE SUMMARY

These system-defined subtypes are specific to defining the system catalog,
more or less:

    sys.std.Core.Type.Universal

        sys.std.Core.Type.Empty

        sys.std.Core.Type.Scalar

            # The following are all regular ordered scalar types.

            sys.std.Core.Type.Cat.Name
            sys.std.Core.Type.Cat.NameChain
                sys.std.Core.Type.Cat.OrdDetFuncNameChain
            sys.std.Core.Type.Cat.DeclNameChain
            sys.std.Core.Type.Cat.Comment
            sys.std.Core.Type.Cat.Order

        sys.std.Core.Type.Tuple

            # The following are all regular tuple types.

            sys.std.Core.Type.Cat.FuncHead
            sys.std.Core.Type.Cat.UpdHead
            sys.std.Core.Type.Cat.ProcHead
            sys.std.Core.Type.Cat.FuncBody
            sys.std.Core.Type.Cat.UpdBody
            sys.std.Core.Type.Cat.ProcBody
            sys.std.Core.Type.Cat.InnerFuncBody
            sys.std.Core.Type.Cat.InnerUpdBody
            sys.std.Core.Type.Cat.InnerProcBody
            sys.std.Core.Type.Cat.Type
            sys.std.Core.Type.Cat.InnerScalarType
            sys.std.Core.Type.Cat.InnerNonscalarType
            sys.std.Core.Type.Cat.InnerUnionType
            sys.std.Core.Type.Cat.InnerRestrType
            sys.std.Core.Type.Cat.IfThenMap

            sys.std.Core.Type.Database

                # The following are all regular database types.

                sys.std.Core.Type.Cat.System
                sys.std.Core.Type.Cat.MountControlCat
                sys.std.Core.Type.Cat.Federation
                sys.std.Core.Type.Cat.Depot
                sys.std.Core.Type.Cat.Package
                sys.std.Core.Type.Cat.ExprNodeSet
                sys.std.Core.Type.Cat.StmtNodeSet
                sys.std.Core.Type.Cat.InnerTypeSet

        sys.std.Core.Type.Relation

            # The following are all regular relation types.

            sys.std.Core.Type.Cat.SysNspSet
            sys.std.Core.Type.Cat.Sys(Func|Upd|Proc)Set
            sys.std.Core.Type.Cat.SysSpecTypeSet
            sys.std.Core.Type.Cat.SysScaNPRTypeSet
            sys.std.Core.Type.Cat.SysTypeSet
            sys.std.Core.Type.Cat.SysCatSet
            sys.std.Core.Type.Cat.MountControlSet
            sys.std.Core.Type.Cat.DepotMountSet
            sys.std.Core.Type.Cat.FedTypeMapSet
            sys.std.Core.Type.Cat.FedTypeMap
            sys.std.Core.Type.Cat.SubdepotSet
            sys.std.Core.Type.Cat.PackageSet
            sys.std.Core.Type.Cat.Dep(Func|Upd|Proc)Set
            sys.std.Core.Type.Cat.DepTypeSet
            sys.std.Core.Type.Cat.Pkg(Func|Upd|Proc)Set
            sys.std.Core.Type.Cat.PkgTypeSet
            sys.std.Core.Type.Cat.Inner(Func|Upd|Proc)Set
            sys.std.Core.Type.Cat.ScaLitExprNodeSet
            sys.std.Core.Type.Cat.ScaPRLitExprNodeSet
            sys.std.Core.Type.Cat.TupLitExprNodeSet
            sys.std.Core.Type.Cat.RelLitExprNodeSet
            sys.std.Core.Type.Cat.FuncInvoExprNodeSet
            sys.std.Core.Type.Cat.IfElseExprNodeSet
            sys.std.Core.Type.Cat.GivenWhenDefExprNodeSet
            sys.std.Core.Type.Cat.(Func|Proc|Type)RefLitExprNodeSet
            sys.std.Core.Type.Cat.OrdDetFuncRefLitExprNodeSet
            sys.std.Core.Type.Cat.MultiUpdStmt
            sys.std.Core.Type.Cat.LeaveStmtNodeSet
            sys.std.Core.Type.Cat.CompoundStmtNodeSet
            sys.std.Core.Type.Cat.ProcInvoStmtNodeSet
            sys.std.Core.Type.Cat.IfElseStmtNodeSet
            sys.std.Core.Type.Cat.GivenWhenDefStmtNodeSet
            sys.std.Core.Type.Cat.IterateStmtNodeSet
            sys.std.Core.Type.Cat.LoopStmtNodeSet
            sys.std.Core.Type.Cat.Inner(Sca|Nonsca|Uni|Restr)TypeSet
            sys.std.Core.Type.Cat.PossrepSet
            sys.std.Core.Type.Cat.PossrepMapSet
            sys.std.Core.Type.Cat.VirtualAttrMapSet
            sys.std.Core.Type.Cat.ConstraintSet
            sys.std.Core.Type.Cat.KeySet
            sys.std.Core.Type.Cat.DistribKeySet
            sys.std.Core.Type.Cat.DKMemRelAttrMap
            sys.std.Core.Type.Cat.DKRelAttrKeyAttrMap
            sys.std.Core.Type.Cat.ForeignKeySet
            sys.std.Core.Type.Cat.ForeignDistribKeySet
            sys.std.Core.Type.Cat.FKChildAttrParentAttrMap
            sys.std.Core.Type.Cat.NameTypeMap
            sys.std.Core.Type.Cat.NameExprMap
            sys.std.Core.Type.Cat.NameDNCMap
            sys.std.Core.Type.Cat.AttrRenameMap
            sys.std.Core.Type.Cat.WhenThenMap

These system-defined subtypes can never be used as components of a system
catalog, or any database, but they may be used temporarily at runtime:

    sys.std.Core.Type.Universal

        sys.std.Core.Type.Empty

        sys.std.Core.Type.Reference

            # The following are special-purpose reference types.

            sys.std.Core.Type.Cat.FuncRef
            sys.std.Core.Type.Cat.ProcRef
            sys.std.Core.Type.Cat.TypeRef
            sys.std.Core.Type.Cat.OrdDetFuncRef

=head1 SIMPLE GENERIC SCALAR TYPES

=head2 sys.std.Core.Type.Cat.Name

This is a structure data type.  A C<Name> (scalar) is a canonical short
name for any kind of DBMS entity (or named component) when declaring it;
this short name is sufficient to identify the entity within its immediate
namespace.  Similarly, a DBMS entity can often be invoked or referred to
using just its C<Name>, depending on the context; other times, a
C<NameChain> must be used instead to also qualify the reference with a
namespace.  Every detail of C<Name>'s representation (its 1 possrep,
default value and ordering algorithm, etc) is the same as C<Text> but it is
explicitly disjoint due to having a different intended interpretation; it
is specifically intended for use in naming DBMS entities rather than being
for general-purpose user data.

=head2 sys.std.Core.Type.Cat.NameChain

This is a structure data type.  A C<NameChain> (scalar) is a canonical long
name for invoking or referring to a DBMS entity, when its name needs to be
qualified with a namespace.  A C<NameChain> is conceptually a sequence of
2..N C<Name>, the 2..N elements being ordered from parent-most to
child-most component name.  A C<NameChain> has 1 system-defined possrep
named C<array> which directly matches the conception of the type; it
consists of 1 attribute whose name is the empty string; the attribute is an
C<Array> whose C<value> attribute has a declared type of C<Name> and that
must have at least 2 elements.  The default and minimum value of
C<NameChain> is a 2 element sequence where each element is the default
value of C<Name> (the empty string); its maximum value is an infinite
sequence where each element is the maximum value of C<Name> (an
infinite-length string) and practically impossible.  The cardinality of
this type is infinity; to define a most-generalized finite C<NameChain>
subtype, you must specify a maximum number of sequence elements of its
values, and each element must be of a finite C<Name> subtype.  The
C<NameChain> type has a default ordering algorithm; for 2 distinct
C<NameChain> values, their order is determined as follows:  First eliminate
any identical parent-most elements from both chains as those alone would
make the chains compare as same (if the remainder of both chains was the
empty chain, then the chains are identical).  Then, iff the remainder of
just one chain is the empty chain, then that chain is ordered before the
non-empty one; otherwise, compare the first element of each of the chain
remainders according to the default ordering algorithm of C<Name> to get
the order of their respective chains.

=head2 sys.std.Core.Type.Cat.DeclNameChain

This is a structure data type.  A C<DeclNameChain> (scalar) is exactly the
same in structure as a C<NameChain> but that it is a sequence of 0..N
rather than 2..N.  A C<DeclNameChain> is used in declaring system catalogs
where DBMS entities live under a potentially N-depth namespace, such as
depot entities grouped in a subdepot hierarchy.  The default and minimum
value of C<DeclNameChain> is a zero element sequence.  The C<DeclNameChain>
type has a default ordering algorithm; it is the same as for C<NameChain>.

=head2 sys.std.Core.Type.Cat.Comment

This is a structure data type.  A C<Comment> (scalar) is the text of a
Muldis D code comment, which programmers can populate as an attribute of
several catalog data types, such as whole routines or statements or
expression nodes.  Every detail of C<Comment>'s representation (its 1
possrep, default value and ordering algorithm, etc) is the same as C<Name>
but it is explicitly disjoint due to having a different intended
interpretation; it is intended just for commenting Muldis D code.  One main
intended use of this type is to help preserve comments in code translated
to or from other languages; though only a subset of those (FoxPro?) keep
comments in the AST rather than discarding them.

=head2 sys.std.Core.Type.Cat.Order

This is a structure data type.  C<Order> (order determination) consists of
just the 3 values C<increase>, C<same>, C<decrease>.  When some context
(such as within a list sort or range check operation) needs to know the
relative order of 2 values according to some criteria, it can invoke a
function that applies that criteria to those 2 values, which are its
main/only arguments, and that function results in a C<Order> value for the
context to make use of.  An C<Order> has 2 system-defined possreps, named
C<name> and C<int>.  The C<name> possrep directly matches the conception of
the type as consisting of 3 character string values; it consists of 1
C<Name>-typed attribute whose name is the empty string.  The C<int> possrep
consists of 1 C<Int>-typed attribute whose name is the empty string and
whose value must be one of [C<-1>, C<0>, C<1>]; the 3 values of each
possrep correspond in the same order as they are documented here.  The
default value of C<Order> is C<same>; its minimum and maximum values are,
respectively, C<increase> and C<decrease>.  The cardinality of this type is
3.  The C<Order> type has a default ordering algorithm that corresponds
directly to that of its C<int> possrep attribute; C<increase> is ordered
before C<same>, and C<same> before C<decrease>.  The C<Order> type has an
implementation hint for less intelligent Muldis D implementations, that
suggests using the C<int> possrep as the basis for the physical
representation.

=head2 sys.std.Core.Type.Cat.OrdDetFuncNameChain

This is an enumeration data type.  The C<OrdDetFuncNameChain> type is
defined as a non-proper / identical subtype of the C<NameChain> type that
has a different default value, which is C<sys.std.Core.Scalar.order> rather
than C<.>.  This type is conceptually intended for use as the declared type
of a routine parameter that would take the name of an
C<order_determination> function, but that parameter is optional and should
default to the system-defined scalar ordering function when no argument is
given to it.

=head1 TYPES FOR DEFINING SYSTEM-DEFINED ENTITIES

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.System

A C<System> is a C<Database>.  It specifies the public interfaces of
system-defined entities, specifically all the system-defined types,
routines, and catalogs.  Both standard system-defined entities and
implementation-specific system-defined entities are specified here,
specifically all the relcons and relvars with the names
C<(sys|mnt|fed|dep|sdp|pkg).cat>.  The system catalog constant named
C<sys.cat> is of the C<System> type.

A C<System> has these 9 attributes:

=over

=item C<comment> - C<single_of.Cat.Comment>

This is an optional programmer comment about the collection of
system-defined entities as a whole.

=item C<namespaces> - C<SysNspSet>

These are all the system-defined namespaces where DBMS entities may live,
or that otherwise always exist due to being system-defined.  Specifically,
it declares these 27 standard language namespaces:
C<.(sys|mnt|fed|dep|sdp|pkg|inn|lex).> (which have the nameless global root
namespace as their parent, spelled C<.>, that isn't also declared here),
C<.sys.(cat|std|imp).>, C<.mnt.cat.>,
C<.(fed|dep|sdp|pkg).(cat|lib|data).>, C<.sys.std.Core.>,
C<.sys.std.Core.Type.>, C<.sys.std.Core.Type.Cat.>; it also declares other
C<Core> namespaces, and where applicable, standard extensions or
implementation-specific extensions.

=item C<functions|updaters|procedures> - C<Sys(Func|Upd|Proc)Set>

These are the interfaces of all the system-defined
functions|updaters|procedures.

=item C<special_types> - C<SysSpecTypeSet>

These are the few central system-defined data types that have special
hard-coded meanings and are not defined like any other types.
Specifically, it declares these 14 standard types: in the
C<sys.std.Core.Type> namespace, C<Universal>, C<Empty>, C<Scalar>,
C<Tuple>, C<Relation>, C<QuasiScalar>, C<QuasiTuple>, C<QuasiRelation>,
C<Reference>, C<Remnant>; in the C<sys.std.Core.Type.Cat> namespace,
C<(Func|Proc|Type|OrdDetFunc)Ref>.

=item C<sca_npr_types> - C<SysScaNPRTypeSet>

These are all the system-defined (|quasi-)scalar root (not union etc) types
that have no possreps, the likes of which users can not define, and values
of which can only be selected using either system-defined literal syntax or
mapping functions.  Specifically, it declares these 2 standard types (all
in the C<sys.std.Core.Type> namespace): C<Int>, C<String>.

=item C<types> - C<SysTypeSet>

These are all the system-defined (|quasi-)scalar types with possreps, and
complete (|quasi-)nonscalar types, and union types, and restriction types.

=item C<catalogs> - C<SysCatSet>

These are the interfaces of all the catalog relcons and relvars.
Specifically, it declares these 6 standard catalogs:
C<(sys|mnt|fed|dep|sdp|pkg).cat>; the first is a relcon, the others not.

=back

The default value of C<System> defines a system with zero builtins.

=head2 sys.std.Core.Type.Cat.SysNspSet

A C<SysNspSet> is a C<Relation> that specifies the set of system
namespaces that exist for organizing DBMS public entities, mostly the
system-defined ones; these system namespaces are organized into a tree
whose root has no name.  A C<SysNspSet> only specifies that a system
namespace exists, not which public entities it contains; see the
C<System> which contains it for that.

A C<SysNspSet> has these 3 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the nameless global root namespace, of
the system namespace's parent system namespace.

=item C<name> - C<Name>

This is the declared name of the system namespace within the namespace
defined by C<parent>; other Muldis D code would reference it with the
combination of C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about this specific system
namespace.

=back

A C<SysNspSet> has a binary primary key on the C<parent> plus
C<name> attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.Sys(Func|Upd|Proc)Set

A C<Sys(Func|Upd|Proc)Set> is a C<Relation> that specifies a set of
system-defined functions|updaters|procedures.

A C<Sys(Func|Upd|Proc)Set> has these 4 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the nameless global root namespace, of
the function|updater|procedure's parent system namespace.

=item C<name> - C<Name>

This is the declared name of the function|updater|procedure within the
namespace defined by C<parent>; other Muldis D code would reference it with
the combination of C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about the function|updater|procedure
as a whole.

=item C<head> - C<Cat.(Func|Upd|Proc)Head>

This defines the entire function|updater|procedure heading, that is its
public interface sans the name, which is all the details of how to use it
and no more detail than necessary about how it is implemented.

=back

A C<Sys(Func|Upd|Proc)Set> has a binary primary key on the C<parent>
plus C<name> attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.SysSpecTypeSet

A C<SysSpecTypeSet> is a C<Relation> that specifies a set of
system-defined types which are particularly special and unlike other types.

A C<SysSpecTypeSet> has these 3 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the nameless global root namespace, of
the type's parent system namespace.

=item C<name> - C<Name>

This is the declared name of the type within the namespace defined by
C<parent>; other Muldis D code would reference it with the combination of
C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about the type as a whole.

=back

A C<SysSpecTypeSet> has a binary primary key on the C<parent> plus
C<name> attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.SysScaNPRTypeSet

A C<SysSpecTypeSet> is a C<Relation> that specifies a set of
system-defined (|quasi-)scalar root (not union etc) types that have no
possreps.

A C<SysScaNPRTypeSet> has these 4 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the nameless global root namespace, of
the type's parent system namespace.

=item C<name> - C<Name>

This is the declared name of the type within the namespace defined by
C<parent>; other Muldis D code would reference it with the combination of
C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about the type as a whole.

=item C<is_quasi> - C<Bool>

This is C<Bool:true> if the type is a quasi-scalar type; it is
C<Bool:false> if the type is a scalar type.

=back

A C<SysScaNPRTypeSet> has a binary primary key on the C<parent> plus
C<name> attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.SysTypeSet

A C<SysTypeSet> is a C<Relation> that specifies a set of system-defined
types.

A C<SysTypeSet> has these 4 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the nameless global root namespace, of
the type's parent system namespace.

=item C<name> - C<Name>

This is the declared name of the type within the namespace defined by
C<parent>; other Muldis D code would reference it with the combination of
C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about the type as a whole.

=item C<type> - C<Type>

This defines the entire type sans the name.

=back

A C<SysTypeSet> has a binary primary key on the C<parent> plus C<name>
attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.SysCatSet

A C<SysCatSet> is a C<Relation> that specifies a set of system-defined
catalog dbvars; each tuple specifies one catalog dbvar.

A C<SysCatSet> has these 4 attributes:

=over

=item C<name> - C<NameChain>

This is the fully-qualified name of the catalog dbvar.

=item C<comment> - C<Comment>

This is an optional programmer comment about the catalog dbvar as a whole.

=item C<is_readonly> - C<Bool>

This is C<Bool:true> if a catalog relcon is being described; it is
C<Bool:false> if a catalog relvar is being described.

=item C<catalog> - C<NameChain>

This is the declared data type of the catalog dbvar.

=back

A C<SysCatSet> has a unary primary key on the C<name> attribute.  Its
default value is empty.

=head1 TYPES FOR DEFINING MOUNT CONTROLS

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.MountControlCat

A C<MountControlCat> is a C<Database>.  It specifies the control
interface for mounting and unmounting (and creating and deleting) depots
within the current in-DBMS process.  The scope of these controls includes
specifying what name the depot is mounted with, whether the mount is
readonly vs updateable, or is temporary vs persistant, and implementation
specific details like storage file names or network login credentials.
Updates to this catalog have side-effects in what other user-updateable
catalogs exist, making them appear or disappear.  This catalog may only be
updated when the current process has no active transaction.  The system
catalog variable named C<mnt.cat> is of the C<MountControlCat> type.

A C<MountControlCat> has these 2 attributes:

=over

=item C<comment> - C<single_of.Cat.Comment>

This is an optional programmer comment about the depot mount control
catalog as a whole.

=item C<mounts> - C<MountControlSet>

These are the controls for the current depot mounts.

=back

The default value of C<MountControlCat> has zero depot mount controls.

=head2 sys.std.Core.Type.Cat.MountControlSet

A C<MountControlSet> is a C<Relation> that specifies a set of controls
per depot mounts, such that each tuple is a single control for a depot
mount, and each depot mount has 1 mount control.  Inserting a tuple will
result in either an existing depot being mounted or a new depot being
created (if possible) and mounted; updating a tuple will change some
details of that depot mount's status, such as making it readonly or
updateable; deleting a tuple will result in a mounted depot being either
unmounted or unmounted plus deleted (if possible).

A C<MountControlSet> has these 7 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the depot mount; other Muldis D code would
reference it with this name.

=item C<comment> - C<Comment>

This is an optional programmer comment about this specific mount of the
depot.

=item C<is_temporary> - C<Bool>

This is C<Bool:true> if the depot mount is for a transient depot that would
automatically be created when mounted I<and> automatically be deleted when
unmounted, because it is only intended for use as the application's current
working memory, and its maximum lifetime is the lifetime of the in-DBMS
process.  This is C<Bool:false> (the default) if the depot mount is for a
depot that either should already exist before being mounted, I<or> that
should continue to exist after being unmounted, because it is intended for
persistent data.  Note that the C<is_temporary> status is orthogonal to
whether the depot's storage is in volatile memory (eg, RAM) or in stable
memory (eg, on disk); a I<not-temporary> depot is simply one that is meant
to be reusable by multiple depot mounts or processes.  The C<is_temporary>
status may not be updated on an existing depot mount control.  I<These
details are subject to revision.>

=item C<create_on_mount> - C<Bool>

This is C<Bool:true> if the depot mount must represent a depot that was
newly created at the time the depot mount was created, where the depot
creation is a direct side-effect of the mount operation.  This is
C<Bool:false> (the default) if the depot being mounted must already exist
without the mounting process having any hand in creating it.  Note that
there is no option provided to conditionally create a depot depending on
whether it already exists, as a perceived safety feature (this detail is
subject to change); to get that behaviour, first try creating the depot
mount control with this attribute C<Bool:false>, and if that fails due to
nonexistence, then try again with it set to C<Bool:true>.  This attribute
is ignored / not applicable when C<is_temporary> is true.

=item C<delete_on_unmount> - C<Bool>

This is C<Bool:true> if the depot should be deleted at the same time it is
unmounted, that is, when this depot mount control tuple is deleted.  This
is C<Bool:false> (the default) if the depot should not be deleted as part
of the unmount process.  This attribute is ignored / not applicable when
C<is_temporary> is true.

=item C<we_may_update> - C<Bool>

This is C<Bool:true> if the depot mount will permit the current in-DBMS
process to make any kind of update to the depot, such as data manipulation,
data definition, or creating/deleting it.  This is C<Bool:false> (the
default) if the depot mount is only providing readonly access to the depot.
When a depot mount is readonly, any attempt to update the depot through it
will throw a runtime exception.  The C<we_may_update> attribute may be set
to C<Bool:false> at any time (when there is no active transaction), but it
may only be set to C<Bool:true> at the time the depot is mounted; this is
for safety, such that if a depot mount won't let you update the depot now,
there's no way it will let you update it later, save by unmounting and
remounting the depot (the result of which is a different depot mount).
Note that the C<we_may_update> status is orthogonal to the depot locking
mechanism; it won't block any other process from reading or updating that
depot, so unless you have locks on the depot using some other means, it may
still be updated by others while mounted readonly for you, so consistent
reads between distinct statements outside of transactions are not
guaranteed.  I<These details are subject to revision, such as in regards to
what autonomous child processes of the current process may do.>

=item C<details> - C<ScaLitExprNodeSet>

These are the 0..N other miscellaneous details that define this depot mount
control.  Each tuple in C<details> specifies an implementation-specific
attribute name and (scalar) value.  Example such implementation-specific
details include the name of a local file that the depot is stored as, or
the name of a DBMS server on the network plus authentication credentials to
connect to it with.  See each Muldis D implementation for details.  Note
that C<details> generally corresponds to the Perl DBI's concept of a data
source name or connection string.  But C<details> can also have other
details like customizations on how to map a foreign DBMS' concepts to
native Muldis D equivalents, or maybe information on where to find extra
meta-data that has such info, or info to instruct a Muldis D interface to
fill in functionality missing in the actual depot of a less capable DBMS,
like constraints or stored invokable routines.

=back

A C<MountControlSet> has a unary primary key on the C<name> attribute.
Its default value is empty.  It also has a transition constraint that
prevents changing some attributes of a depot mount control once set.  Note
that the 3 attributes [C<is_temporary>, C<create_on_mount>,
C<delete_on_unmount>] may be merged into a single enumerated-typed
attribute or otherwise be reorganized.

=head1 TYPES FOR DEFINING FEDERATIONS

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.Federation

A C<Federation> is a C<Database>.  It specifies a federation of depot
mounts, that is, all the depot mounts that an in-DBMS process can see or
update, and that defines the scope of an active transaction.  There is
exactly one of these per process and it doesn't have a name.  The system
catalog variable named C<fed.cat> is of the C<Federation> type.

A C<Federation> has these 3 attributes:

=over

=item C<comment> - C<single_of.Cat.Comment>

This is an optional programmer comment about the federation as a whole.

=item C<mounts> - C<DepotMountSet>

These are the depot mounts that comprise the federation.

=item C<type_maps> - C<FedTypeMapSet>

When this federation has more than one depot mount, and the depots have
copies of the same data types, then C<type_maps> is used to specify which
types in each depot correspond to types in others, so that during the time
period of common mounting, those data types can be treated as aliases and
so be used interchangeably.  Mainly this is used when either a procedure in
one depot wants to access or update a dbvar of another depot, or when a
procedure in one depot wants to invoke a routine in another depot, that
have parameters/etc of some user-defined data type.  The expected most
common use case would be when there are 2 depot mounts, one being a
persistent database and the other being transient application-specific code
that creates or otherwise works with that persistent database.

=back

The default value of C<Federation> has zero depot mounts.

=head2 sys.std.Core.Type.Cat.DepotMountSet

A C<DepotMountSet> is a C<Relation> that specifies a set of depot
mounts, such that each tuple is a single depot mount.  A depot mount is a
named in-DBMS context by which a depot is referenced from either other
depots or by the main application, and it also specifies the catalog
content of the depot itself.

A C<DepotMountSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the depot mount; other Muldis D code would
reference it with this name.

=item C<comment> - C<Comment>

This is an optional programmer comment about this specific mount of the
depot.

=item C<depot> - C<Depot>

This defines the entire system catalog of the depot that this mount has
made visible to the DBMS.

=back

A C<DepotMountSet> has a unary primary key on the C<name> attribute.
Its default value is empty.

=head2 sys.std.Core.Type.Cat.FedTypeMapSet

A C<FedTypeMapSet> is a C<Relation> such that each tuple in it
specifies which of multiple depots have a copy of the same data type, for
the purpose of treating all the copies as being interchangeable, so to
support cross-depot interaction.

A C<FedTypeMapSet> has these 2 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about this type mapping.

=item C<map> - C<FedTypeMap>

This lists the fully-qualified names of 0..N data types that are all
considered to be copies of the same 1 type, and should be treated
interchangeably by the DBMS.

=back

A C<FedTypeMapSet> has a primary key on the C<map> attribute.  Its
default value is empty.

=head2 sys.std.Core.Type.Cat.FedTypeMap

A C<FedTypeMap> is a C<Relation>.  It lists the fully-qualified names of
0..N data types that are all considered to be copies and of the same 1
type, and should be treated interchangeably by the DBMS.  A C<FedTypeMap>
has 2 attributes, C<depot> (a C<Name>) and C<type> (a C<NameChain>); the
C<depot> is the declared name of the depot mount that the data type lives
in; the C<type> is the C<dep.>-qualified name of the data type living in
it.  Its default value has zero tuples.

=head1 TYPES FOR DEFINING DEPOTS AND SUBDEPOTS

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.Depot

A C<Depot> is a C<Database>.  It specifies the entire system catalog of
a single depot, that is, the widest scope within which all entities must be
fully defined in terms of just user-defined entities within the same scope
or of system-defined entities.  It also doubles to specify the system
catalog of a subdepot, which is an arbitrary subset of a depot's entities
that internally looks like a depot; a depot can have 0..N subdepots, and
any that exist are arranged in a hierarchy with the depot as the root.  The
system catalog variables named C<dep.cat> and C<sdp.cat> are both of the
C<Depot> type.

A C<Depot> has these 8 attributes:

=over

=item C<comment> - C<single_of.Cat.Comment>

This is an optional programmer comment about the (|sub)depot as a whole.

=item C<subdepots> - C<SubdepotSet>

These are all the subdepots that this (|sub)depot contains.

=item C<packages> - C<PackageSet>

These are all the packages that this (|sub)depot contains.

=item C<functions|updaters|procedures> - C<Dep(Func|Upd|Proc)Set>

These are all the function|updater|procedure definitions that this
(|sub)depot contains.

=item C<types> - C<DepTypeSet>

These are all the definitions that this (|sub)depot contains of
(|quasi-)scalar types with possreps, and complete (|quasi-)nonscalar types,
and union types, and restriction types.

=item C<data> - C<maybe_of.Cat.NameChain>

This is the declared data type of the self-local dbvar that this
(|sub)depot contains, iff C<data> is a C<Single>; if C<data> is C<Nothing>
(the default), then this (|sub)depot does not have a self-local dbvar.

=back

The default value of C<Depot> defines an empty (|sub)depot that does
not have any self-local dbvar.

=head2 sys.std.Core.Type.Cat.SubdepotSet

A C<SubdepotSet> is a C<Relation> that specifies the set of subdepots
that a depot might optionally have for organizing its public entities;
these subdepots are organized into a tree whose root is the depot.  A
C<SubdepotSet> only specifies that a subdepot exists, not which depot
entities it contains; see the C<Depot> which contains it for that.

A C<SubdepotSet> has these 3 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the C<dep.(cat|lib|data)> namespace,
of the subdepot's parent subdepot, which is often just the depot itself.

=item C<name> - C<Name>

This is the declared name of the subdepot within the namespace defined by
C<parent>; other Muldis D code would reference it with the combination of
C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about this specific subdepot.

=back

A C<SubdepotSet> has a binary primary key on the C<parent> plus
C<name> attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.PackageSet

A C<PackageSet> is a C<Relation> that specifies the set of packages
that a depot might optionally have for organizing its possibly private
entities.

A C<PackageSet> has these 4 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the C<dep.(cat|lib|data)> namespace,
of the packages's parent (|sub)depot.

=item C<name> - C<Name>

This is the declared name of the package within the namespace defined by
C<parent>; other Muldis D code would reference it with the combination of
C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about the package definition as
associated with this package name.

=item C<package> - C<Package>

This defines the entire system catalog of the package.

=back

A C<PackageSet> has a binary primary key on the C<parent> plus
C<name> attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.Dep(Func|Upd|Proc)Set

A C<Dep(Func|Upd|Proc)Set> is a C<Relation> that specifies a set of
functions|updaters|procedures that a (|sub)depot might directly contain.

A C<Dep(Func|Upd|Proc)Set> has these 5 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the C<dep.(cat|lib|data)> namespace,
of the function|updater|procedure's parent (|sub)depot.

=item C<name> - C<Name>

This is the declared name of the function|updater|procedure within the
namespace defined by C<parent>; other Muldis D code would reference it with
the combination of C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about the function|updater|procedure
as a whole.

=item C<head> - C<Cat.(Func|Upd|Proc)Head>

This defines the entire function|updater|procedure heading, that is its
public interface sans the name, which is all the details of how to use it
and no more detail than necessary about how it is implemented.

=item C<body> - C<Cat.(Func|Upd|Proc)Body>

This defines the entire function|updater|procedure body, that is its
implementation, besides what C<interface> defines.

=back

A C<Dep(Func|Upd|Proc)Set> has a binary primary key on the C<parent>
plus C<name> attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.DepTypeSet

A C<DepTypeSet> is a C<Relation> that specifies a set of types that a
(|sub)depot might directly contain.

A C<DepTypeSet> has these 4 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the C<dep.(cat|lib|data)> namespace,
of the type's parent (|sub)depot.

=item C<name> - C<Name>

This is the declared name of the type within the namespace defined by
C<parent>; other Muldis D code would reference it with the combination of
C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about the type as a whole.

=item C<type> - C<Type>

This defines the entire type sans the name.

=back

A C<DepTypeSet> has a binary primary key on the C<parent> plus C<name>
attributes.  Its default value is empty.

=head1 TYPES FOR DEFINING PACKAGES

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.Package

A C<Package> is a C<Database>.  It specifies the entire system catalog
of a single package, which provides a privatizing namespace for a subset of
a depot's entities; entities outside a package can only invoke that
package's entities which have been declared part of its public interface.
A package internally looks like a depot but that it doesn't contain
subdepots or other packages.  The system catalog variable named C<pkg.cat>
is of the C<Package> type.

A C<Package> has these 6 attributes:

=over

=item C<comment> - C<single_of.Cat.Comment>

This is an optional programmer comment about the package as a whole.

=item C<functions|updaters|procedures> - C<Pkg(Func|Upd|Proc)Set>

These are all the function|updater|procedure definitions that this package
contains.

=item C<types> - C<PkgTypeSet>

These are all the definitions that this package contains of (|quasi-)scalar
types with possreps, and complete (|quasi-)nonscalar types, and union
types, and restriction types.

=item C<data> - C<maybe_of.Cat.NameChain>

This is the declared data type of the dbvar that this package contains, iff
C<data> is a C<Single>; if C<data> is C<Nothing> (the default), then this
package does not have a self-local dbvar.

=back

The default value of C<Package> defines an empty package that does not
have any self-local dbvar.

=head2 sys.std.Core.Type.Cat.Pkg(Func|Upd|Proc)Set

A C<Pkg(Func|Upd|Proc)Set> is a C<Relation> that specifies a set of
functions|updaters|procedures that a package might contain, where each
function|updater|procedure may be either public for the DBMS as a whole or
private to the package.

A C<Pkg(Func|Upd|Proc)Set> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the function|updater|procedure.

=item C<comment> - C<Comment>

This is an optional programmer comment about the function|updater|procedure
as a whole.

=item C<is_public> - C<Bool>

This is C<Bool:true> if the function|updater|procedure is part of the
package's own public interface and may be invoked from outside the package;
it is C<Bool:false> if it is just part of the package's internals.

=item C<head> - C<Cat.(Func|Upd|Proc)Head>

This defines the entire function|updater|procedure heading, that is its
public interface sans the name, which is all the details of how to use it
and no more detail than necessary about how it is implemented.

=item C<body> - C<Cat.(Func|Upd|Proc)Body>

This defines the entire function|updater|procedure body, that is its
implementation, besides what C<interface> defines.

=back

A C<Pkg(Func|Upd|Proc)Set> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.PkgTypeSet

A C<PkgTypeSet> is a C<Relation> that specifies a set of types that a
package might contain, where each type may be either public for the DBMS as
a whole or private to the package.

A C<PkgTypeSet> has these 4 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the type.

=item C<comment> - C<Comment>

This is an optional programmer comment about the type as a whole.

=item C<is_public> - C<Bool>

This is C<Bool:true> if the type is part of the package's own public
interface and may be directly invoked from outside the package; it is
C<Bool:false> if it is just part of the package's internals.

=item C<type> - C<Type>

This defines the entire type sans the name.

=back

A C<PkgTypeSet> has a unary primary key on the C<name> attribute.  Its
default value is empty.

=head1 TYPES FOR DEFINING ROUTINE HEADINGS

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.FuncHead

A C<FuncHead> is a C<Tuple>.  It specifies the entire heading or public
interface of a function or inner function, except for its name and
public/private status; the latter are provided by any type embedding this
one when applicable.

A C<FuncHead> has these 4 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the function heading.

=item C<result_type> - C<NameChain>

This is the declared result data type of the function as a whole.

=item C<params> - C<NameTypeMap>

This is the declared parameter list of the function, which has 0..N named
and typed parameters.

=item C<opt_params> - C<set_of.Cat.Name>

This indicates the subset of the function's parameters that are optional,
that is, do not need to be supplied explicit arguments when the function is
invoked; any function parameters not named here must be supplied explicit
arguments.  Any parameter marked as optional which is not given an explicit
argument will implicitly default to the default value of its declared type.
Each element of C<opt_params> must match a parameter name in C<params>.

=back

The default value of C<FuncHead> has zero parameters and a result type
of C<Bool>; by default, its parameters are all non-optional.

=head2 sys.std.Core.Type.Cat.UpdHead

A C<UpdHead> is a C<Tuple>.  It specifies the entire heading or public
interface of an updater or inner updater, except for its name and
public/private status; the latter are provided by any type embedding this
one when applicable.

A C<UpdHead> has these 4 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the updater heading.

=item C<upd_params> - C<NameTypeMap>

This is the declared subject-to-update parameter list of the updater, which
has 1..N named and typed such parameters.  It must have at least 1 element.

=item C<ro_params> - C<NameTypeMap>

This is the declared read-only parameter list of the updater, which has
0..N named and typed such parameters.

=item C<opt_params> - C<set_of.Cat.Name>

This indicates the subset of the updater's subject-to-update or read-only
parameters that are optional, that is, do not need to be supplied explicit
arguments when the function is invoked; any updater parameters not named
here must be supplied explicit arguments.  Any parameter marked as optional
which is not given an explicit argument will implicitly default to the
default value of its declared type; any subject-to-update parameter marked
as optional which is not given an explicit argument will implicitly bind to
a new anonymous variable (with the aforementioned default value) which is
discarded after the updater finishes executing.  Each element of
C<opt_params> must match a parameter name in either C<upd_params> or
C<ro_params>.

=back

There is a distributed primary key over the C<name> attributes of
C<upd_params> and C<ro_params>.

The default value of C<UpdHead> has 1 subject-to-update parameter whose
name is C<topic> and whose declared type is C<Bool>; it has zero read-only
parameters; by default, its parameters are all non-optional.

=head2 sys.std.Core.Type.Cat.ProcHead

A C<ProcHead> is a C<Tuple>.  It specifies the entire heading or public
interface of a procedure or inner procedure, except for its name and
public/private status; the latter are provided by any type embedding this
one when applicable.

A C<ProcHead> has these 4 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the procedure heading.

=item C<upd_params> - C<NameTypeMap>

This is the declared subject-to-update parameter list of the procedure,
which has 0..N named and typed such parameters.

=item C<ro_params> - C<NameTypeMap>

This is the declared read-only parameter list of the procedure, which has
0..N named and typed such parameters.

=item C<opt_params> - C<set_of.Cat.Name>

This is as per the same-named attribute of C<UpdHead>.

=back

There is a distributed primary key over the C<name> attributes of
C<upd_params> and C<ro_params>.

The default value of C<ProcHead> has zero parameters; by default, its
parameters are all non-optional.

=head1 TYPES FOR DEFINING ROUTINE BODIES

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.FuncBody

A C<FuncBody> is a C<Tuple>.  It specifies the entire body or
implementation of a function, besides the details that a C<FuncHead>
has, one of which each C<FuncBody> typically must be paired with.

A C<FuncBody> has these 4 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the function body.

=item C<main_body> - C<InnerFuncBody>

This defines the entire main body of the function, namely what's left of
the function body after parts of it are optionally factored out into inner
routines or inner types.  It must consist of a value expression whose
result type is of the result type of the function, and which invokes all of
the function's parameters.

=item C<inner_funcs> - C<InnerFuncSet>

These are all the inner function definitions that this function contains.

=item C<inner_types> - C<InnerTypeSet>

These are all the inner type definitions that this function contains.

=back

There is a distributed primary key over both the C<name> attributes of
C<inner_funcs> and the C<name> attributes of all the attributes of
C<inner_types>.

The default value of C<FuncBody> directly corresponds to the default value
of C<FuncHead> and unconditionally results in the value C<Bool:false>.

=head2 sys.std.Core.Type.Cat.UpdBody

A C<UpdBody> is a C<Tuple>.  It specifies the entire body or
implementation of an updater, besides the details that a C<UpdHead>
has, one of which each C<UpdBody> typically must be paired with.

A C<UpdBody> has these 5 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the updater body.

=item C<main_body> - C<InnerUpdBody>

This defines the entire main body of the updater, namely what's left of the
updater body after parts of it are optionally factored out into inner
routines or inner types.  It must consist of a multi-update statement which
invokes all of the updater's parameters.

=item C<inner_upds> - C<InnerUpdSet>

These are all the inner updater definitions that this updater contains.

=item C<inner_funcs> - C<InnerFuncSet>

These are all the inner function definitions that this updater contains.

=item C<inner_types> - C<InnerTypeSet>

These are all the inner type definitions that this updater contains.

=back

There is a distributed primary key over both the C<name> attributes of
C<inner_(upds|funcs)> and the C<name> attributes of all the attributes of
C<inner_types>.

The default value of C<UpdBody> directly corresponds to the default
value of C<UpdHead> and unconditionally updates its C<topic> argument
to the value C<Bool:false>.

=head2 sys.std.Core.Type.Cat.ProcBody

A C<ProcBody> is a C<Tuple>.  It specifies the entire body or
implementation of a procedure, besides the details that a C<ProcHead>
has, one of which each C<ProcBody> typically must be paired with.

A C<ProcBody> has these 6 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the procedure body.

=item C<main_body> - C<InnerProcBody>

This defines the entire main body of the procedure, namely what's left of
the procedure body after parts of it are optionally factored out into inner
routines or inner types.

=item C<inner_procs> - C<InnerProcSet>

These are all the inner procedure definitions that this procedure contains.

=item C<inner_upds> - C<InnerUpdSet>

These are all the inner updater definitions that this procedure contains.

=item C<inner_funcs> - C<InnerFuncSet>

These are all the inner function definitions that this procedure contains.

=item C<inner_types> - C<InnerTypeSet>

These are all the inner type definitions that this procedure contains.

=back

There is a distributed primary key over both the C<name> attributes of
C<inner_(procs|upds|funcs)> and the C<name> attributes of all the
attributes of C<inner_types>.

The default value of C<ProcBody> directly corresponds to the default
value of C<ProcHead> and is a no-op, having zero statements.

=head2 sys.std.Core.Type.Cat.Inner(Func|Upd|Proc)Set

A C<Inner(Func|Upd|Proc)Set> is a C<Relation> that specifies a set of
inner functions|updaters|procedures that a function|updater|procedure might
contain.

A C<Inner(Func|Upd|Proc)Set> has these 4 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the inner function|updater|procedure.

=item C<comment> - C<Comment>

This is an optional programmer comment about the inner
function|updater|procedure as a whole.

=item C<head> - C<Cat.(Func|Upd|Proc)Head>

This defines the entire inner function|updater|procedure heading, that is
its public interface sans the name, which is all the details of how to use
it and no more detail than necessary about how it is implemented.

=item C<body> - C<Inner(Func|Upd|Proc)Body>

This defines the entire inner function|updater|procedure body, that is its
implementation, besides what C<interface> defines.

=back

A C<Inner(Func|Upd|Proc)Set> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head1 TYPES FOR DEFINING INNER ROUTINE BODIES

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.InnerFuncBody

A C<InnerFuncBody> is a C<Tuple>.  It specifies the entire body or
implementation of an inner function (or the main body of a function),
besides the details that a C<FuncHead> has, one of which each
C<InnerFuncBody> typically must be paired with.

A C<InnerFuncBody> has these 2 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the (|inner )function body.

=item C<expr> - C<ExprNodeSet>

This defines the value expression tree that comprises the entire (|inner
)function body.

=back

There is a distributed primary key over the C<name> attributes of all the
attributes of C<expr>; and if this C<InnerFuncBody> is paired with a
C<FuncHead>, then the distributed key also extends over the head's
parameter names.

A C<InnerFuncBody> specifies a simple value expression tree of named
expression nodes, each of which is a tuple of one of its C<expr.\w+_exprs>
attributes.  It must have at least 1 member node, except that it may have
zero member nodes iff the (|inner )function it is composed into has exactly
1 parameter, in which case the value expression tree implicitly results in
the argument to said parameter.  Otherwise:  All member nodes must define a
simple expression node tree, such that every member except one (which is
the root node) has one of its peers as a parent node, and no direct cycles
between members are permitted (only indirect cycles based on (|inner
)function invocations are allowed); the name of the root node must be the
empty string.  Note that the composed-into (|inner )function's parameters
are also implicitly tree nodes, and are referenced by name into the
expression the same way as any other named expression node is.  Regardless
of whether the node count is zero or 1+, the tree must denote a value
expression whose result type is of the result type of the (|inner )function
it is composed into, and which invokes all of the (|inner )function's
parameters.

The default value of C<InnerFuncBody> directly corresponds to the
default value of C<FuncHead> and unconditionally results in the value
C<Bool:false>.

=head2 sys.std.Core.Type.Cat.ExprNodeSet

A C<ExprNodeSet> is a C<Database> that specifies a set of named value
expression nodes.  It is typically composed into a (|inner
)(function|updater).  Each tuple of a C<ExprNodeSet> attribute is a
named expression node, which is the majority component of functional Muldis
D code.  All arbitrarily complex Muldis D expression trees, including
relational queries, are composed of just expression nodes, either directly,
or indirectly by way of (|inner )function invocations, as each (|inner
)function body is itself composed entirely of a single expression tree (of
at least 1 node).  Only functions and updaters may contain expression
nodes, so for any procedures that would conceptually include them, those
portions of the procedures need to be separated out and encapsulated by
named (|inner )functions or (|inner )updaters.  Note that, while the
general case has expression trees simply denoting a value, in some cases
they may instead define a pseudo-variable / virtual variable; that only
happens in (|inner )updaters where the expression is used as an argument
for a subject-to-update parameter of an (|inner )update operator call; in
that case the leaf nodes / only node of the expression must map to a
subject-to-update parameter of the containing (|inner )update operator.

A C<ExprNodeSet> has these 11 attributes:

=over

=item C<sca_lit_exprs> - C<ScaLitExprNodeSet>

These are expression nodes that define scalar literals of types such that
the Muldis D dialect provides special literal syntax specific to the type,
and the type may not have any possreps.

=item C<sca_pr_lit_exprs> - C<ScaPRLitExprNodeSet>

These are expression nodes that define (|quasi-)scalar literals of types
such that each type has at least 1 possrep, and each literal is specified
simply in terms of possrep attributes.

=item C<tup_lit_exprs> - C<TupLitExprNodeSet>

These are expression nodes that define (|quasi-)tuple literals.

=item C<rel_lit_exprs> - C<RelLitExprNodeSet>

These are expression nodes that define (|quasi-)relation literals.

=item C<func_invo_exprs> - C<FuncInvoExprNodeSet>

These are expression nodes that invoke (|inner )functions.

=item C<if_else_exprs> - C<IfElseExprNodeSet>

These are expression nodes that represent if-else control flow expressions.

=item C<given_when_def_exprs> - C<GivenWhenDefExprNodeSet>

These are expression nodes that represent given-when-default control flow
expressions.

=item C<(func|proc|type|ord_det_func)_ref_lit_exprs> -
C<Cat.(Func|Proc|Type|OrdDetFunc)RefLitExprNodeSet>

These are expression nodes that define
function|imperative-routine|type|order-determination-function reference
literals.

=back

There is a distributed primary key over the C<name> attributes of all of a
C<ExprNodeSet>'s attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.ScaLitExprNodeSet

A C<ScaLitExprNodeSet> is a C<Relation> that specifies a set of value
expression nodes where each node is a hard-coded scalar literal of one of a
certain collection of system-defined core scalar types (or subtype
thereof).

A C<ScaLitExprNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about the expression (leaf) node.

=item C<value> - C<Scalar>

This is the actual literal value that the expression node represents.
I<That is, any Scalar value could be used here, but in practice that is
either dialect-defined (what literals are supported), and possibly
implementation defined/limited.>

=back

A C<ScaLitExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.ScaPRLitExprNodeSet

A C<ScaPRLitExprNodeSet> is a C<Relation> that specifies a set of value
expression nodes where each node represents a (|quasi-)scalar literal of a
type that has at least 1 possrep, and the literal is specified simply in
terms of possrep attributes.

A C<ScaPRLitExprNodeSet> has these 6 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<is_quasi> - C<Bool>

This is C<Bool:true> if the node denotes a quasi-scalar literal; it is
C<Bool:false> if the node just denotes a scalar literal.

=item C<type_name> - C<NameChain>

This is the name of the type that the (|quasi-)scalar value belongs to.

=item C<possrep_name> - C<Name>

This is the name of the possrep, of the type named by C<scalar_type_name>,
in terms of whose attributes the (|quasi-)scalar value is being selected.

=item C<possrep_attrs> - C<NameExprMap>

These are the attributes (names and values) of the C<possrep_name> possrep
of the (|quasi-)scalar literal.

=back

A C<ScaPRLitExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.TupLitExprNodeSet

A C<TupLitExprNodeSet> is a C<Relation> that specifies a set of value
expression nodes where each node represents a (|quasi-)tuple literal.

A C<TupLitExprNodeSet> has these 4 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<is_quasi> - C<Bool>

This is C<Bool:true> if the node denotes a quasi-tuple literal; it is
C<Bool:false> if the node just denotes a tuple literal.

=item C<attrs> - C<NameExprMap>

These are the attributes (names and values) of the (|quasi-)tuple literal.

=back

A C<TupLitExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.RelLitExprNodeSet

A C<RelLitExprNodeSet> is a C<Relation> that specifies a set of value
expression nodes where each node represents a (|quasi-)relation literal.

A C<RelLitExprNodeSet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<is_quasi> - C<Bool>

This is C<Bool:true> if the node denotes a quasi-relation literal; it is
C<Bool:false> if the node just denotes a relation literal.

=item C<head> - C<set_of.Cat.Name>

These are the names of all of this (|quasi-)relation literal's attributes.

=item C<body> - C<set_of.Cat.NameExprMap>

These are the (|quasi-)tuples of the (|quasi-)relation literal.

=back

A C<RelLitExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.FuncInvoExprNodeSet

A C<FuncInvoExprNodeSet> is a C<Relation> that specifies a set of value
expression nodes where each node represents the result of invoking a named
(|inner )function with specific arguments.

A C<FuncInvoExprNodeSet> has these 4 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<function> - C<NameChain>

This is the name of the (|inner )function being invoked.

=item C<args> - C<NameExprMap>

These are the arguments for the (|inner )function invocation.  Each element
defines one argument value, with the element C<name> matching the invoked
(|inner )function's parameter name, and the element C<expr> naming another
local expression node which defines the value.

=back

A C<FuncInvoExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.IfElseExprNodeSet

A C<IfElseExprNodeSet> is a C<Relation> that specifies a set of value
expression nodes where each node represents an N-way if-else control flow
expression.

The reason that the C<IfElseExprNodeSet> expression node type exists,
rather than this functionality being provided by an ordinary function
invocation, is because the semantics of an if-else expression require its
sub-expressions to be evaluated in a specific sequence and that later
elements in the sequence are evaluated only conditionally based on the
results of earlier elements in the sequence, whereas with ordinary
functions the operands are all independent of each other, can be done in
any order, and can all be evaluated prior to the function.  The main
scenario that requires the special semantics is when an earlier conditional
part of the sequence is testing whether it is even logically possible to
evaluate a later part of the sequence; for example, the first condition may
test if a value is a member of a certain data type, and a later part of the
sequence may want to use some operator on the value that is only defined
for the certain data type (invoking it on something else would result in a
failure/exception); so only known-safe/appropriate expressions then get
evaluated.

A C<IfElseExprNodeSet> has these 4 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<if_then> - C<array_of.Cat.IfThenMap>

This is a sequence of 0..N conditional expressions, each of which has an
associated result expression.  Each conditional expression will evaluate in
order while the previous conditional resulted in C<Bool:false>; once a
conditional results in C<Bool:true>, its associated result expression will
evaluate and be the result of the larger if-else sequence, and no more
conditionals will be evaluated; no result expressions will be evaluated
except the one with the true conditional.

=item C<else> - C<NameChain>

Iff none of the conditionals in C<if_then> result in C<Bool:true> (or as a
trivial case, if C<if_then> is an empty sequence), then the result
expression represented by the local expression node (or parameter) named by
C<else> will be evaluated, and be the result of the larger if-else.

=back

A C<IfElseExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.GivenWhenDefExprNodeSet

A C<GivenWhenDefExprNodeSet> is a C<Relation> that specifies a set of
value expression nodes where each node represents an N-way
given-when-default switch control flow expression that dispatches based
on matching a single value with several options.

A C<GivenWhenDefExprNodeSet> is essentially a more specialized version
of a C<IfElseExprNodeSet> where every condition expression is a simple
value equality test and one of the operands is the same for all the
conditions in the set; also, with a given-when-default it doesn't matter
what order the conditionals are tested to find a true resulting one.

A C<GivenWhenDefExprNodeSet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<given> - C<NameChain>

This is the single operand value that is common to all the conditions; it
is the control value for the expression.

=item C<when_then> - C<WhenThenMap>

This is a set of distinct condition operand values, each of which has an
associated result expression.  If a condition operand matches the value of
C<given>, its associated result expression will evaluate and be the result
of the larger if-else sequence; no result expressions will be evaluated
except the one with the matching conditional operand.

=item C<default> - C<NameChain>

Iff none of the condition operand values in C<when_then> matches the value
of C<given> (or as a trivial case, if C<when_then> has no tuples), then the
result expression represented by the local expression node (or parameter)
named by C<default> will be evaluated, and be the result of the larger
given-when-default.

=back

A C<GivenWhenDefExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.(Func|Proc|Type|OrdDetFunc)RefLitExprNodeSet

A C<Cat.(Func|Proc|Type|OrdDetFunc)RefLitExprNodeSet> is a C<Relation> that
specifies a set of expression nodes where each node represents a value of
the special C<sys.std.Core.Type.Cat.(Func|Proc|Type|OrdDetFunc)Ref> type.

A C<Cat.(Func|Proc|Type|OrdDetFunc)RefLitExprNodeSet> has these 3
attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about the expression leaf node.

=item C<referencing> - C<NameChain>

This is the name, from the point of view of the routine embedding this
expression node, of the
function|imperative-routine|type|order-determination-function that the new
special reference value is supposed to facilitate portable invoking of.

=back

A C<Cat.(Func|Proc|Type|OrdDetFunc)RefLitExprNodeSet> has a unary (unique)
key on the C<name> attribute, plus another such key on the C<referencing>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.InnerUpdBody

A C<InnerUpdBody> is a C<Tuple>.  It specifies the entire body or
implementation of an inner updater (or the main body of a updater), besides
the details that a C<UpdHead> has, one of which each
C<InnerUpdBody> typically must be paired with.

A C<InnerUpdBody> has these 3 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the (|inner )updater body.

=item C<exprs> - C<ExprNodeSet>

This defines the expression trees that are arguments to the update
operators that C<stmt> invokes.  These expression trees must reference all
of the read-only parameters that the inner update operator has.

=item C<stmt> - C<MultiUpdStmt>

This defines the entire body of the (|inner )updater, which is composed of
a single multi-update statement.  This multi-update statement must
reference all of the parameters that the (|inner )updater has.

=back

There is a distributed primary key over the C<name> attributes of all the
attributes of C<exprs>; and if this C<InnerUpdBody> is paired with a
C<UpdHead>, then the distributed key also extends over the head's
parameter names.

The default value of C<InnerUpdBody> directly corresponds to the
default value of C<UpdHead> and unconditionally updates its C<topic>
argument to the value C<Bool:false>.

=head2 sys.std.Core.Type.Cat.MultiUpdStmt

A C<MultiUpdStmt> is a C<Relation> that specifies a multi-update
statement (of 1..N variables), which is the narrowest scope implicitly
atomic component of procedural Muldis D code.  It is the most fundamental
component of procedural Muldis D code.  The variables being updated are
accessed via the host (|inner )updater's subject-to-update parameters.  All
arbitrarily complex Muldis D value assignments, including relational
assignments, are composed of just C<MultiUpdStmt>, either directly, or
indirectly by way of (|inner )updater invocations, as each (|inner )updater
body is itself composed entirely of 1 multi-update statement (plus
supporting value expressions).  Only (|inner )updaters may contain
C<MultiUpdStmt>, so for any procedures that would conceptually include
them, those portions of the procedures need to be separated out and
encapsulated by named (|inner )updaters.  Each tuple of a multi-update
statement is a single update statement, which represents a single
invocation of an (|inner )updater, and at least 1 tuple is required.

A C<MultiUpdStmt> has these 4 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the single update statement as
a whole.

=item C<updater> - C<NameChain>

This is the name of the (|inner )updater being invoked.

=item C<upd_args> - C<NameExprMap>

These are the 1..N subject-to-update arguments to the (|inner )updater
invocation, as-per C<ro_args>.  But since each expression tree in
C<upd_args> is binding to a subject-to-update parameter, the expression
tree actually is defining a pseudo-variable / virtual-variable over 1..N
containing routine subject-to-update parameters; in the most trivial (and
common) case, the parameter is referenced directly.

=item C<ro_args> - C<NameExprMap>

These are the 0..N read-only arguments to the (|inner )updater invocation.
Each element defines one argument value, with the element C<name> matching
the invoked routine's parameter name, and the element C<expr> naming a
local expression node (or parameter) which defines the value.

=back

There is a distributed primary key over the C<name> attributes of
C<upd_args> and C<ro_args>.

The default value of C<MultiUpdStmt> directly corresponds to the
default value of C<InnerUpdBody> and unconditionally updates its
containing (|inner )updater's C<topic> argument to the value C<Bool:false>.

=head2 sys.std.Core.Type.Cat.InnerProcBody

A C<InnerProcBody> is a C<Tuple>.  It specifies the entire body or
implementation of an inner procedure (or the main body of a procedure),
besides the details that a C<ProcHead> has, one of which each
C<InnerProcBody> typically must be paired with.

A C<InnerProcBody> has these 3 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the (|inner )procedure body.

=item C<vars> - C<NameTypeMap>

This defines the 0..N (non-parameter) lexical variables of the (|inner
)procedure; they initialize to the default values of their declared types.

=item C<stmt> - C<StmtNodeSet>

This defines the statement tree that comprises the entire (|inner
)procedure body.

=back

There is a distributed primary key over the C<name> attribute of C<vars>
and the C<name> attributes of all the attributes of C<stmt>; and if this
C<InnerProcBody> is paired with a C<ProcHead>, then the distributed
key also extends over the head's parameter names.

A C<InnerProcBody> specifies a simple statement tree of named statement
nodes, each of which is a tuple of one of its C<stmt.\w+_stmts> attributes.
If it has zero member nodes, then the (|inner )procedure is a no-op.
Otherwise:  All member nodes must define a simple statement node tree, such
that every member except one (which is the root node) has one of its peers
as a parent node, and no direct cycles between members are permitted (only
indirect cycles based on (|inner )procedure invocations are allowed); the
name of the root node must be the empty string.  Note that the
composed-into (|inner )procedure's parameters are also implicitly tree
nodes, and are referenced by name into the statement tree the same way as
any other named statement node is.  The statement tree should reference all
of the parameters and lexical variables that the (|inner )procedure has,
but this isn't a strict requirement.

The default value of C<InnerProcBody> directly corresponds to the default
value of C<ProcHead> and is a no-op, having an empty statement tree.

=head2 sys.std.Core.Type.Cat.StmtNodeSet

A C<StmtNodeSet> is a C<Database> that specifies a set of named
statement nodes.  It is typically composed into a (|inner )procedure.  Each
tuple of a C<StmtNodeSet> attribute is a named statement node, from
which non-implicitly-atomic procedural Muldis D code is composed.

Note that, regarding Muldis D's feature of a statement node having an
explicit C<name> that can be referenced by "leave" and "iterate" control
flow statements to leave or re-iterate the corresponding block, both SQL
and Perl have native counterpart features in the form of block labels.

A C<StmtNodeSet> has these 7 attributes:

=over

=item C<leave_stmts> - C<LeaveStmtNodeSet>

These are statement nodes that represent abnormal block exit statements.

=item C<compound_stmts> - C<CompoundStmtNodeSet>

These are statement nodes that each represent a compound statement having a
sequence of 0..N procedure statements.

=item C<proc_invo_stmts> - C<ProcInvoStmtNodeSet>

These are statement nodes that invoke (|inner )procedures.

=item C<if_else_stmts> - C<IfElseStmtNodeSet>

These are statement nodes that represent if-else control flow statements.

=item C<given_when_def_stmts> - C<GivenWhenDefStmtNodeSet>

These are statement nodes that represent given-when-default control flow
statements.

=item C<iterate_stmts> - C<IterateStmtNodeSet>

These are statement nodes that represent abnormal block restart statements.

=item C<loop_stmts> - C<LoopStmtNodeSet>

These are statement nodes that represent generic looping block statements.

=back

There is a distributed primary key over the C<name> attributes of all of a
C<StmtNodeSet>'s attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.LeaveStmtNodeSet

A C<LeaveStmtNodeSet> is a C<Relation> that specifies a set of
statement leaf nodes where each node represents an instruction to
abnormally exit the block defined by a parent statement node (a normal exit
is to simply execute to the end of the block).  If the parent node in
question is the root statement node for the containing (|inner )procedure,
then the latter will be exited; this is how a "return" statement is
represented, but "return" is still easy to recognize because the root node
always has the empty string as its name.  If the parent node in question is
an iterating or looping statement, then any remaining iterations it might
have had are skipped, especially useful if it was an infinite loop.

A C<LeaveStmtNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about the statement leaf node.

=item C<leave> - C<NameChain>

This is the name of the parent statement node we wish to abnormally exit;
note that this reference does not count as making the other node a child of
the current one, so this reference does not contribute to a cycle.

=back

A C<LeaveStmtNodeSet> has a unary primary key on the C<name> attribute,
plus a unary (unique) key on the C<leave> attribute.  Its default value is
empty.

=head2 sys.std.Core.Type.Cat.CompoundStmtNodeSet

A C<CompoundStmtNodeSet> is a C<Relation> that specifies a set of
statement nodes where each node is a compound statement composed of a
sequence of 0..N other statements.

A C<CompoundStmtNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the statement node or
the statement node (sub-)tree it is the root of.

=item C<stmts> - C<array_of.Cat.NameChain>

This is a sequence of names of 0..N other local statement nodes; the
current compound statement consists of having those other statements
execute in this given sequence.

=back

A C<CompoundStmtNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.ProcInvoStmtNodeSet

A C<ProcInvoStmtNodeSet> is a C<Relation> that specifies a set of
statement nodes where each node is an invocation of some other procedural
routine (eg, procedure, update operator, system service, 'inner' variant)
with specific arguments.  The invoked routine can be either user-defined or
system-defined.

A C<ProcInvoStmtNodeSet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the statement node or
the statement node (sub-)tree it is the root of.

=item C<procedure> - C<NameChain>

This is the name of the procedural routine being invoked.

=item C<upd_args> - C<NameExprMap>

These are the 0..N subject-to-update arguments to the routine invocation,
as-per C<ro_args>.

=item C<ro_args> - C<NameExprMap>

These are the 0..N read-only arguments to the routine invocation.  Each
element defines one argument value, with the element C<name> matching the
invoked routine's parameter name, and the element C<expr> naming a local or
global variable or statement-containing routine parameter which defines the
value.

=back

A C<ProcInvoStmtNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.  There is a distributed primary
key over the C<name> attributes of C<upd_args> and C<ro_args>.

=head2 sys.std.Core.Type.Cat.IfElseStmtNodeSet

A C<IfElseStmtNodeSet> is a C<Relation> that specifies a set of
statement nodes where each node represents an N-way if-else control flow
statement.  A C<IfElseStmtNodeSet> is essentially the imperative
version of the functional C<IfElseExprNodeSet>, except that for design
simplicity, all of the conditionals need to be pre-evaluated and their
boolean results stored in variables (but this could be a lazy though still
necessarily deterministic operation, so work isn't actually done if the
results aren't needed); if any conditionals could only be conditionally
evaluated, then the necessary logic means this if-else statement must be
broken up into multiple nested if-else.

A C<IfElseStmtNodeSet> has these 4 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the statement node or
the statement node (sub-)tree it is the root of.

=item C<if_then> - C<array_of.Cat.IfThenMap>

This is a sequence of 0..N conditional result variable names, each of which
has an associated statement.  Each conditional result will be tested in
order while the previous conditional result is C<Bool:false>; once a
conditional result is C<Bool:true>, its associated statement will be
invoked; no statements will be invoked except the one with the true
conditional result.

=item C<else> - C<maybe_of.Cat.NameChain>

Iff none of the conditional results in C<if_then> is C<Bool:true> (or as a
trivial case, if C<if_then> is an empty sequence), then the statement
represented by the local statement node named by C<else> will be invoked
iff C<else> is a C<Single>; if under the first circumstance C<else> is a
C<Nothing>, then the whole if-else will have been a no-op.

=back

A C<IfElseStmtNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.GivenWhenDefStmtNodeSet

A C<GivenWhenDefStmtNodeSet> is a C<Relation> that specifies a set of
statement nodes where each node represents an N-way given-when-default
switch control flow statement that dispatches based on matching a single
value with several options.  A C<GivenWhenDefStmtNodeSet> is essentially
the imperative version of the functional C<GivenWhenDefExprNodeSet>.

A C<GivenWhenDefStmtNodeSet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the statement node or
the statement node (sub-)tree it is the root of.

=item C<given> - C<NameChain>

This is name of the local parameter or variable that supplies the single
operand value that is common to all the conditions; it is the control value
for the statement.

=item C<when_then> - C<WhenThenMap>

This is a set of distinct condition operand values, each of which has an
associated statement.  If a condition operand matches the value of
C<given>, its associated statement will be invoked; no statements will be
invoked except the one with the matching conditional operand.

=item C<default> - C<maybe_of.Cat.NameChain>

Iff none of the condition operand values in C<when_then> matches the value
of C<given> (or as a trivial case, if C<when_then> has no tuples), then the
statement represented by the local statement node named by C<default> will
be invoked iff C<default> is a C<Single>; if under the first circumstance
C<default> is a C<Nothing>, then the whole given-when-default will have
been a no-op.

=back

A C<GivenWhenDefStmtNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.IterateStmtNodeSet

A C<IterateStmtNodeSet> is a C<Relation> that specifies a set of
statement leaf nodes where each node represents an instruction to
abnormally end the current iteration of a looping block defined by a parent
statement node, and then start at the beginning of the next iteration of
that loop if there are any left ("normal" is to simply execute to the end
of the block before starting the next iteration).  The same semantics apply
for the beginning of the next loop as if the current block iteration had
executed to the end before repeating.

A C<IterateStmtNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about the statement leaf node.

=item C<iterate> - C<NameChain>

This is the name of the parent statement node we wish to abnormally exit
and restart; note that this reference does not count as making the other
node a child of the current one, so this reference does not contribute to a
cycle.

=back

A C<IterateStmtNodeSet> has a unary primary key on the C<name>
attribute, plus a unary (unique) key on the C<iterate> attribute.  Its
default value is empty.

=head2 sys.std.Core.Type.Cat.LoopStmtNodeSet

A C<LoopStmtNodeSet> is a C<Relation> that specifies a set of statement
nodes where each node represents a generic looping statement block which
iterates until a child "leave" statement executes.

A C<LoopStmtNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the statement node or
the statement node (sub-)tree it is the root of.

=item C<do> - C<NameChain>

This is the name of the local statement node that will get executed for
each iteration of the loop; typically it has a sub-tree of statement nodes.

=back

A C<LoopStmtNodeSet> has a unary primary key on the C<name> attribute.
Its default value is empty.

=head1 TYPES FOR DEFINING DATA TYPES

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.Type

A C<Type> is a C<Tuple>.  Its purpose is as per
C<Inner(Scalar|Nonscalar|Union|Restr)Type>, one of which it is a
wrapper for along with other inner types that are composed into it.

A C<Type> has these 3 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the type as a whole.

=item C<inner_types> - C<InnerTypeSet>

These are all the inner type definitions that this type contains.  There
must be at least 1 inner type here, and exactly 1 of the inner types must
have the empty string as its name; that inner type defines the actual main
type that the C<Type> is a wrapper for, and the other inner types, if
any, support it.

=item C<inner_funcs> - C<InnerFuncSet>

These are all the inner function definitions that this type contains, which
support the main type or inner types.

=back

There is a distributed primary key over both the C<name> attributes of all
the attributes of C<inner_types> and the C<name> attributes of
C<inner_funcs>.

The default value of C<Type> is as per C<InnerRestrType>.

=head2 sys.std.Core.Type.Cat.InnerTypeSet

A C<InnerTypeSet> is a C<Database> that specifies a set of named inner
types.  It is typically composed into a
function|updater|procedure|outer-type.

A C<InnerTypeSet> has these 4 attributes:

=over

=item C<inner_(sca|nonsca|uni|restr)_types> -
C<Inner(Sca|Nonsca|Uni|Restr)TypeSet>

These are all the inner scalar|nonscalar|union|restriction type definitions
that this type contains.

=back

There is a distributed primary key over the C<name> attributes of all of a
C<InnerTypeSet>'s attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.Inner(Sca|Nonsca|Uni|Restr)TypeSet

A C<Inner(Sca|Nonsca|Uni|Restr)TypeSet> is a C<Relation> that specifies
a set of inner scalar|nonscalar|union|restriction types that a
function|updater|procedure or scalar|nonscalar|union|restriction type might
contain.

A C<Inner(Sca|Nonsca|Uni|Restr)TypeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the inner scalar|nonscalar|union|restriction
type.

=item C<comment> - C<Comment>

This is an optional programmer comment about the inner
scalar|nonscalar|union|restriction type as a whole.

=item C<type> - C<Inner(Scalar|Nonscalar|Union|Restr)Type>

This defines the entire inner scalar|nonscalar|union|restriction type sans
the name.

=back

A C<Inner(Sca|Nonsca|Uni|Restr)TypeSet> has a unary primary key on the
C<name> attribute.  Its default value is empty.

=head1 TYPES FOR DEFINING INNER DATA TYPES

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.InnerScalarType

A C<InnerScalarType> is a C<Tuple>.  It defines either a new
(|quasi-)scalar root type with at least 1 possrep, or it defines a subtype
of some other (|quasi-)scalar type which also adds at least one possrep to
the other type.  Either way, every possrep defines a candidate
representation that can handle every value of the (|sub)type it is defined
with, and the Muldis D implementation may choose for itself which of these,
or some other alternative, is the actual/physical representation.

A C<InnerScalarType> has these 7 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the (|quasi-)scalar
(|sub-)type as a whole.

=item C<base_type> - C<maybe_of.Cat.NameChain>

Iff the type being defined is a (|quasi-)scalar root type, then
C<base_type> is not applicable and is a C<Nothing>.  Iff the type being
defined is a subtype of some other (|quasi-)scalar type, then C<base_type>
is a C<Single> whose sole element is the name of that other type.  Note
that any type named by C<base_type> must itself have at least 1 possrep.

=item C<is_quasi> - C<maybe_of.Bool>

Iff the type being defined is a (|quasi-)scalar root type, then C<is_quasi>
is a C<Single> whose sole element is C<Bool:true> if the type is a
quasi-scalar type; the element is C<Bool:false> if the type is a scalar
type.  Iff the type being defined is a subtype of some other type, then
C<is_quasi> is not applicable (would be redundant) and is a C<Nothing>.

=item C<possreps> - C<PossrepSet>

These are the 1..N possrep definitions that comprise this type such that
each one fully defines a set of attributes plus restrictions on their
collective values whereby it defines a representation of all values of this
type.  Note that if multiple (|quasi-)scalar types are related to each
other such that more than one declares possreps for at least one common
value, then the C<name> attribute of the C<possreps> attributes of all of
those types' definitions have a distributed primary key over them.  Note
that, to keep things simple and deterministic under the possibility of
diamond subtype/supertype relationships (such that the generic
system-defined scalar possrep attribute accessors can work), Muldis D
requires all of the possreps of all scalar types having a common scalar
root type to have mutually distinct names, regardless of whether any
subtypes have values in common; this can be enforced at
type-definition-in-catalog time since all types that can interact are in
the same depot.

=item C<possrep_maps> - C<PossrepMapSet>

When this type has more than one possrep applicable to all of its values,
these are the definitions of mapping functions for deriving the
representation of a value in one possrep directly from the representation
in another possrep, and also directly in the reverse.  Every one of this
type's possreps must be mapped bidirectionally to every other one of its
possreps, either directly or indirectly.  So for C<P> total possreps, the
total number of bidirectional maps C<M> is in C<< (P-1) <= M <= ((P-1)*P/2)
>>.  When a subtype is adding possreps to an other base type, all of the
mapping functions are defined with the subtype.

=item C<default> - C<InnerFuncBody>

This defines the entire (main) body of a C<type_default> function that
results in the default (|quasi-)scalar value of the (|sub-)type; it has
zero parameters and its result type is the same as the (|quasi-)scalar type
whose declaration it is part of.

=item C<order> - C<maybe_of.Cat.InnerFuncBody>

A (|quasi-)scalar root type definition may optionally have a type-default
total ordering function associated with it (a type being defined as a
subtype may not); iff the type being defined qualifies and desires such an
associated function, then C<order> is a C<Single> whose sole element
defines the entire (main) body of a C<order_determination> function.  The
implicit function heading that this goes with has 3 parameters; the first
two parameters, named C<topic> and C<other>, each have declared types that
are the same as the (|quasi-)scalar root type whose declaration the
function is part of, and this function is said root type's type-default
ordering function; the third parameter, named C<assuming>, is
C<Tuple>-typed; the function's implicit result type is C<Order>.  Iff
the type being defined is a subtype of some other type or does not desire
the function, then C<order> is a C<Nothing>.

=back

The default value of C<InnerScalarType> defines a scalar root type with
a single possrep whose name is the empty string and that has no attributes;
it is a singleton type, whose default value is its only value.

=head2 sys.std.Core.Type.Cat.PossrepSet

A C<PossrepSet> is a C<Relation> that specifies a set of possreps that
a (|quasi-)scalar (|sub-)type might consist primarily of.

A C<PossrepSet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the possrep.

=item C<comment> - C<Comment>

This is an optional programmer comment about the possrep as a whole.

=item C<attrs> - C<NameTypeMap>

This defines the 0..N attributes of the possrep.

=item C<constraint> - C<InnerFuncBody>

This defines the entire (main) body of a C<type_constraint> function that
determines what combinations of possrep attribute values denote values of
the (|sub-)type, besides the restrictions imposed by the declared types of
the attributes individually.  The implicit function heading that this goes
with has a single C<topic> parameter whose declared type is a tuple whose
attributes match those declared by C<attrs> and whose argument denotes the
value to test; the function's implicit result type is C<Bool>.  If the
function unconditionally results in C<Bool:true>, then all possible
combinations of attribute-allowable values are collectively allowed.  Note
that, strictly speaking, any constraint defined as part of a possrep (where
there are multiple possreps) may actually be less restrictive than the
total constraint of (|sub-)type as a whole, because the total constraint is
defined by I<and>-ing the constraints of all the possreps of the
(|sub-)type; therefore, mainly any given possrep's constraints need to be
just restricting enough so that the inter-possrep mapping functions can
handle the arguments that it accepts, so it is possible to apply the other
possreps' constraints.

=item C<is_base> - C<Bool>

This is an optimization hint for Muldis D implementations that are not
intelligent enough to decide on a best physical representation for the
(|sub-)type.  At most one of the type's possreps is singled out by having a
C<Bool:true> value here, so an implementation doesn't have to think and can
just use that as the basis for the physical representation.  To keep things
simple, only a possrep of a root type may be marked C<Bool:true>, so it can
apply consistently to all subtypes as well.  More intelligent
implementations are free to ignore C<is_base>, or just use it as a
tie-breaker if applicable.

=back

A C<PossrepSet> has a unary primary key on the C<name> attribute.  Its
default value is empty.  The default value of a tuple of C<PossrepSet>
has a C<name> that is the empty string, its C<attrs> is empty, and its
C<constraint> unconditionally results in C<Bool:true>.

=head2 sys.std.Core.Type.Cat.PossrepMapSet

A C<PossrepMapSet> is a C<Relation> such that each tuple in it
specifies a pair of mapping functions to bidirectionally derive a value of
a type between 2 of its possreps.

A C<PossrepMapSet> has these 5 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about this bidirectional mapping.

=item C<p1> - C<Name>

This is the declared name of one possrep.

=item C<p2> - C<Name>

This is the declared name of a second possrep.  The value of C<p2> must be
distinct from that of C<p1>, and moreover, the 2 values must be mutually
ordered so that the value of C<p1> is before the value of C<p2>; the latter
constraint defines a C<PossrepMapSet>'s canonical form.

=item C<p2_from_p1> - C<InnerFuncBody>

This defines the entire (main) body of a C<possrep_map> function that
derives the representation of the possrep named by C<p2> from that of the
possrep named by C<p1>.  The implicit function heading that this goes with
has a single C<topic> parameter whose declared type is a tuple whose
attributes match those of C<p1>; the function's implicit result type is a
tuple whose attributes match those of C<p2>.  Note that every distinct
argument (domain) value of this function must have a distinct result
(range) value.

=item C<p1_from_p2> - C<InnerFuncBody>

This defines the entire (main) body of the inverse C<possrep_map> function
to that of C<p2_from_p1>.  I<Note that it would often be feasible for a
Muldis D implementation to automatically infer a reverse function, but for
now we still require it to be explicitly stated; the explicitly stated
inverse function could be generated though.  This design is subject to
change.>

=back

A C<PossrepMapSet> has a binary primary key on the C<p1> plus C<p2>
attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.InnerNonscalarType

A C<InnerNonscalarType> is a C<Tuple>.  It defines either a new
(|quasi-)nonscalar heading (set of attributes) with associated constraints
for a tuple and relation type having that heading, or it defines a subtype
of some other (|quasi-)nonscalar type.  That is, it defines 2 new data
types, a tuple type and a relation type with matching headings.  Note that
you also declare a database type using C<InnerNonscalarType>, by
declaring a tuple type whose attributes are all relation or database typed.
Note that you can not use a C<InnerNonscalarType> to declare or
subtype an incomplete type, as it (or its supertype) must specify a
complete set of attributes.

A C<InnerNonscalarType> has these 14 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the (|quasi-)nonscalar
(|sub-)type as a whole.

=item C<base_type> - C<maybe_of.Cat.NameChain>

Iff the type being defined is a (|quasi-)nonscalar root type, then
C<base_type> is not applicable and is a C<Nothing>.  Iff the type being
defined is a subtype of some other (|quasi-)nonscalar type, then
C<base_type> is a C<Single> whose sole element is the name of that other
type.

=item C<is_quasi> - C<maybe_of.Bool>

Iff the type being defined is a (|quasi-)nonscalar root type, then
C<is_quasi> is a C<Single> whose sole element is C<Bool:true> if the type
is a quasi-nonscalar type; the element is C<Bool:false> if the type is a
nonscalar type.  Iff the type being defined is a subtype of some other
type, then C<is_quasi> is not applicable (would be redundant) and is a
C<Nothing>.

=item C<is_tuple_first> - C<Bool>

Iff this is C<Bool:true> then the type being defined is primarily
considered a tuple type; that is, when either the type name is referenced
normally (not using the C<type> namespace), or the type definition is
embedded (and nameless), then it is simply considered to be a tuple type;
iff this is C<Bool:false> then the type being defined is primarily
considered to be a relation type.  When a type is primarily considered a
tuple or relation type, the only way to reference it as the other kind of
type is by using the C<type.(tuple|relation)_from.\w+> referencing syntax.

=item C<attrs> - C<NameTypeMap>

Iff the type being defined is a (|quasi-)nonscalar root type, then C<attrs>
defines the 0..N attributes of the type.  Iff the type being defined is a
subtype of some other type, then the parent type's attribute list is used
by default, but C<attrs> of the current type may be used to apply
additional constraints by overriding the declared types of a subset of the
parent's attributes with types that are subtypes of the originals; an
override is done using matching C<name> attribute values of C<attrs>.  It
is indeed valid for a (|quasi-)nonscalar type to have zero attributes; in
this case, a tuple type consists of exactly one value, and a relation type
consists of exactly two values.

=item C<virtual_attr_maps> - C<VirtualAttrMapSet>

This defines the proper subset of this type's attributes that are virtual,
and how they are defined in terms of the rest of this type's attributes.
Note that the special functional dependencies between attributes defined
herein mean that some kinds of tuple constraints would be redundant.

=item C<tuple_constraints> - C<ConstraintSet>

This defines the entire (main) bodies of 0..N C<type_constraint> functions
that (when I<and>-ed together) determine what combinations of tuple
attribute values denote values of the (|sub-)type, besides the restrictions
imposed by the declared types of the attributes individually; they are
generalized type constraints that together validate a tuple as a whole.
The implicit function heading that each of these goes with has a single
C<topic> parameter whose declared type is a tuple whose attributes match
those declared by C<attrs> and whose argument denotes the value to test;
the function's implicit result type is C<Bool>.  If the functions
unconditionally result in C<Bool:true>, then all possible combinations of
attribute-allowable values are collectively allowed.  Each function is
invoked either once to test a tuple value, or multiple times to
individually test every tuple in a relation value.

=item C<relation_constraints> - C<ConstraintSet>

This is like C<tuple_constraint> but that each function's parameter is
relation-typed rather than tuple-typed; each is a generalized type
constraint that validates a relation as a whole.

=item C<keys> - C<KeySet>

These are the 0..N explicit (unique) keys that are applicable to relation
values of the type being defined; they apply either as candidate keys or as
unique key constraints, depending on context.  If there are no explicit
keys, then there is an implicit (unique) key over all attributes of the
relation type being defined, meaning that every possible tuple that may
individually be an element of a relation value of the type being defined,
may be in it at once.  If any explicit keys are defined, then every one
must be over a distinct proper subset of the type's attributes, and
moreover no key's attributes may be a proper subset of any other key's
attributes; if 2 such candidates appear, just use the one that has the
subset.  It is valid for a key to consist of zero attributes; in this case,
that key is the only key of the type, and values of the type may each
consist of no more than one tuple.  At most one key in C<keys> may be
privileged as the I<primary key>.  Note that C<keys> is logically an
abstraction syntax (the canonical simplest form) for a particular kind of
C<relation_constraint> of the type being defined, one that compares the
cardinality of a projection of a relation on its key attributes with the
cardinality of the original relation; the attribute values comprise a key
if the cardinalities are equal.

=item C<distrib_keys> - C<DistribKeySet>

These are the 0..N explicit simple distributed (unique) keys that are
applicable to tuple/database values of the type being defined, that range
over specified relation-typed attributes of it.  At most one key in
C<distrib_keys> may be privileged as the I<primary key>.  Note that
C<distrib_keys> is logically an abstraction syntax (the canonical simplest
form) for a particular kind of C<tuple_constraint> of the type being
defined, one that compares the cardinality of the union of the projection
of distributed key attributes of all key-participating relation-valued
attributes, with the sum of cardinalities of the source relation-valued
attributes; the attribute values comprise a distributed key if the
cardinalities are equal.

=item C<foreign_keys> - C<ForeignKeySet>

These are the 0..N explicit simple foreign (non-distributed) keys that are
applicable to tuple/database values of the type being defined, that range
over and relate tuples of specified relation-typed attributes of it; they
are a kind of referential constraint.  Each tuple of a child attribute must
have a corresponding tuple in a specific single parent attribute, where
they correspond on the attributes of the parent attribute that comprise a
(unique) key of the latter.  Note that C<foreign_keys> is logically an
abstraction syntax (the canonical simplest form) for a particular kind of
C<tuple_constraint> of the type being defined, one that tests if the
relational difference, where a projection of the parent relation is
subtracted from a corresponding projection of the child relation (with
attribute renaming if necessary), is an empty relation; if the difference
is an empty relation, then the foreign key is satisfied; otherwise, any
difference tuples are from child tuples that violate the foreign key.

=item C<foreign_distrib_keys> - C<ForeignDistribKeySet>

These are the 0..N explicit simple foreign distributed keys that are
applicable to tuple/database values of the type being defined, that range
over and relate tuples of specified relation-typed attributes of it; they
are a kind of referential constraint.  Each tuple of a child attribute must
have a corresponding tuple in one member of a specific set of
parent-alternative attributes (that have a distributed key ranging over
them), where they correspond on the attributes of the parent-alternative
attribute that comprise a distributed key on the latter.  Note that
C<foreign_distrib_keys> is logically an abstraction syntax (the canonical
simplest form) for a particular kind of C<tuple_constraint> of the type
being defined; it is as per C<foreign_keys> except that the parent relation
is the result of unioning appropriately renamed projections of the member
relations of the distributed key.

=item C<default_tuple> - C<InnerFuncBody>

This defines the entire (main) body of a C<type_default> function that
results in the default (|quasi-)tuple value of the (|sub-)type; it has zero
parameters and its result type is the same as the (|quasi-)tuple type whose
declaration it is part of.

=item C<default_relation> - C<InnerFuncBody>

This defines the entire (main) body of a C<type_default> function that
results in the default (|quasi-)relation value of the (|sub-)type; it has
zero parameters and its result type is the same as the (|quasi-)relation
type whose declaration it is part of.

=back

There is a distributed primary key over the C<name> attributes of
C<(tuple|relation)_constraint> and C<(|foreign_)(|distrib_)keys>.

The default value of C<InnerNonscalarType> defines a relation type that
is the same as C<RelationD0>, having zero attributes, whose default value
is the one with zero tuples.

=head2 sys.std.Core.Type.Cat.VirtualAttrMapSet

A C<VirtualAttrMapSet> is a C<Relation> that defines special functional
dependencies between attributes of a (|quasi-)nonscalar data type, such
that, on a per-tuple basis, some attributes can be generated purely from
other attributes, and hence the former attributes may be virtual.  Each
tuple of a C<VirtualAttrMapSet> specifies 2 disjoint subsets of the
(|quasi-)nonscalar's attributes, which are I<determinant> and I<dependent>
attributes respectively, where the values of the second set are generated
from the first using a C<virtual_attr_map> function.  Whether I<dependent>
attributes are computed when needed or pre-computed and stored (a trade-off
of storage space for speed) is implementation dependent, though users may
give hints to govern that performance decision.

The main reason for virtual attributes to exist is to provide a fundamental
feature of a relational database where multiple perceptions of the same
data can exist at once; each user can perceive the same data being
organized according to their own preferences, and even if the actual means
of storing the data changes over time, the users continue to be able to
perceive it in the same ways as before the change.

The most important use case of virtual attributes is when the data type
having them is a database type, all of whose attributes are relations (or
databases); and so these attributes define database relvars, with
non-virtual and virtual attributes being base and virtual relvars,
respectively (which correspond to the SQL concepts of base tables and
views, respectively).  The idea in general is that users can work with any
relvar without knowing whether it is base or virtual, and so if
implementations change later such that real relvars become virtual or
vice-versa, users could continue as if nothing changed.

A less common use case of virtual attributes is in (typically non-database)
nonscalar types when users want to treat non-identical values as being
distinct in some situations and non-distinct in others.  For example they
want to do case-insensitive matching of character data, or alternately they
want a case-insensitive (unique) key constraint on such, but either way
they want the case of the data preserved.  In this situation, a base
attribute can exist with the original case-preserved data, and a dependent
virtual attribute can exist with the first's values folded to uppercase
(eliminating any case differences); so then the key constraint can be
placed on the virtual attribute to get the desired semantics, and the
matching can be done against the same.

All permissable operations on virtual (|pseudo-)variables are such that the
semantics of updating them is the same as for updating base
(|pseudo-)variables, with respect to I<The Assignment Principle>: Following
assignment of a value C<v> to a variable C<V>, the comparison C<v = V>
evaluates to TRUE.  Just as an update to determinant variables will have
the cascade effect of updating their dependent variables such that the
functional dependency between them continues to hold, the reverse also must
happen.  Any update to dependent variables must have the side effect of
updating their determinant variables.  Specifically, the implementing code
of an update to dependents must be rewritten behind the scenes to become
instead an update to their determinants, as if the latter was what the
users had actually written, such that following the then-first update of
the determinants, the cascading update to the dependents by the functional
dependency must result in the same dependents' values that they would have
had if the dependents were just base variables being updated by the
original code.  If such a code rewrite can not be done, such as due to
information lost in the functional dependency, then the operation
attempting to update the dependent attributes must fail.  Sometimes the
code rewrite can be done automatically by the DBMS, and sometimes it can
succeed if the map definer gives explicit details on how to accomplish it.

Because Muldis D requires a strong degree of determinism in the whole
system, sometimes users have to provide explicit details on how to
accomplish a reverse mapping, even if it is possible to automatically
generate such, because there may be multiple ways to do a reverse map that
satisfy I<The Assignment Principle>, so the explicitness would be to pick
exactly one of those, so that how determinants are updated is predictable
in an implementation-portable manner.  For example, if a virtual relvar
C<V> is defined as the simple relational union of 2 other relvars C<R1> and
C<R2>, then a tuple insertion into C<V> could be rewritten at least 3 ways,
which are an insertion into just C<R1>, or into just C<R2>, or into both
C<R1> and C<R2>; so for predictability's sake, the map should specify which
option to do (which can vary on a case-by-case basis).

I<This all being said, for the moment the C<VirtualAttrMapSet> type
does not give a way to manually specify a reverse function, so for now all
the virtuals are either read-only or updatable due to an automatically
generated reverse function, which might vary by implementation.  Fixing
this matter is TODO.  Note that the reverse functions might have to be
defined as per-tuple operations, separately for insert/substitute/delete.>

A C<VirtualAttrMapSet> has these 5 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about this virtual attribute map.

=item C<determinant_attrs> - C<NameDNCMap>

These are the names of the determinant attributes.  Each name is given in 2
forms, called C<name> and C<dnc>; C<dnc> is the actual name of the
attribute as existing in the host type, and it may actually be a component
attribute of a host type attribute to any recursive depth (a single C<dnc>
element means it is the actual host type element); C<name> is an alias by
which the attribute will be known in the C<virtual_attr_map> function; this
mapping exists so to make the determinant attributes look like direct
sibling attributes whereas in reality they can be further-away relatives,
just common components somewhere under the host type.

=item C<dependent_attrs> - C<NameDNCMap>

These are the names of the dependent attributes; the structure of
C<dependent_attrs> is as per C<determinant_attrs>; none of these may be the
same as the names of the determinant attributes, since a virtual attribute
can't be defined in terms of itself.

=item C<virtual_attr_map> - C<InnerFuncBody>

This defines the entire (main) body of a C<virtual_attr_map> function that
derives a tuple of dependent attribute values from a tuple of determinant
attribute values.  The implicit function heading that this goes with has a
single C<topic> parameter whose declared type is a tuple whose attributes
match those of C<determinant_attrs>; the function's implicit result type is
a tuple whose attributes match those of C<dependent_attrs>.  Note that the
range of this function is typically smaller than its domain, though it
might not be.

=item C<is_updateable> - C<Bool>

This is C<Bool:true> if all of the dependent attributes should be treated
as updateable, because they have enough information to map any kinds of
updates (all of tuple insert/substitute/delete) back to their determinant
attributes, and the system should try to support updates against them.
This is C<Bool:false> if all of the dependent attributes should not be
considered updateable, either because it is known they don't have enough
information, or because we expect users will never try to update them, so
don't go to the trouble of supporting updates.

=back

A C<VirtualAttrMapSet> has a binary primary key on the
C<determinant_attrs> plus C<dependent_attrs> attributes; it also has a
distributed primary key over the C<dependent_attrs> attribute of all
tuples.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.ConstraintSet

A C<ConstraintSet> is a C<Relation> that specifies a set of named
generic constraints for data types or variables; each tuple is one named
constraint.  Each constraint in the set can be either a C<type_constraint>
or C<state_constraint> or C<transition_constraint>, but when a set has
multiple constraints, all of them must be the same kind, and they must all
correspond to the same implicit function heading.  One or more (possibly
empty) C<ConstraintSet> is composed into the definition each nonscalar
type and union type and restriction type and dbvar.

A C<ConstraintSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the constraint function.

=item C<comment> - C<Comment>

This is an optional programmer comment about the constraint as a whole.

=item C<body> - C<InnerFuncBody>

This defines the entire (main) body of the constraint function.

=back

A C<ConstraintSet> has a unary primary key on the C<name> attribute.
Its default value is empty.  The default value of a tuple of
C<ConstraintSet> has a C<name> that is the empty string, and its
C<body> unconditionally results in C<Bool:true>.

=head2 sys.std.Core.Type.Cat.KeySet

A C<KeySet> is a C<Relation> that specifies a set of candidate keys or
unique key constraints for a relation type; each tuple specifies one
candidate key.

A C<KeySet> has these 4 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the key.

=item C<comment> - C<Comment>

This is an optional programmer comment about the key as a whole.

=item C<attrs> - C<set_of.Cat.Name>

This defines the 0..N host relation attributes comprising the key.  If this
set is empty, then we have a nullary key which restricts the host relation
to have a maximum of 1 tuple.

=item C<is_primary> - C<Bool>

This is C<Bool:true> if this key has been designated the I<primary key> of
the relation (a relation may have at most one, or none, of those); it is
C<Bool:false> otherwise.  A primary key is privileged over candidate keys
in general, in that all of the attributes comprising the primary key are
likely to be treated as immutable in practice for the relation's tuples,
and hence are the best candidates for identifying tuples within a relation
over an extended term (if multiple keys conceptually have all those
qualities, then you could choose either as the primary, or perhaps such a
situation may indicate a flaw in your database design).  The common concept
of a tuple having an identity that is distinct from the sum total of all
its attribute values, such that one can say that a tuple is being "updated"
(rather than its host relation being the only thing that is updated to hold
a different set of tuples) is dependent in Muldis D on the host relation
having a primary key; if a tuple in a relation is replaced by a distinct
tuple whose values in the primary key attributes are identical, it is only
in this situation that we can consider that we still have the same tuple,
which was just updated, and that we have not lost the old tuple and gained
a new one.  The relation attributes comprising a primary key are the best
mapping values for automatic new foreign keys and join conditions if the
host relation type has to be auto-split into several associated ones, for
example because the physical representation of this relation doesn't
support RVAs; in fact, some implementations may require that any relation
having an RVA must also have an explicit primary key, so it is easier for
them to choose the key to automatically relate a split relation on.

=back

A C<KeySet> has a unary primary key on the C<name> attribute, and a
unary (unique) key on its C<attrs> attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.DistribKeySet

A C<DistribKeySet> is a C<Relation> that specifies a set of candidate
distributed (unique) keys over relation-valued attributes of a
tuple/database; each tuple specifies one distributed (unique) key.

A C<DistribKeySet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the distributed (unique) key.

=item C<comment> - C<Comment>

This is an optional programmer comment about the distributed (unique) key
as a whole.

=item C<attrs> - C<set_of.Cat.Name>

This declares the 0..N attributes comprising the distributed (unique) key.
If this set is empty, then we have a nullary key which restricts all of the
relations participating in the distributed key to have a maximum of 1 tuple
between them.  Note that the distributed key attribute names don't have to
match the names of any participating relation attributes.

=item C<relations> - C<DKMemRelAttrMap>

This names the 0..N relation-valued attributes of the host tuple/database
type that are participating in the distributed key, and says which of each
of their attributes maps to the attributes of the distributed key itself.
If this set is empty, then the distributed key has no effect.  The unary
projection of every tuple of the C<key_attr> attribute of C<relations> must
be identical to C<attrs>.

=item C<is_primary> - C<Bool>

This has the same meaning as C<is_primary> of C<KeySet> but for being
distributed as if the relations distributed over were one relation.

=back

A C<DistribKeySet> has a unary primary key on the C<name> attribute,
and a unary (unique) key on its C<relations> attribute.  Its default value
is empty.

=head2 sys.std.Core.Type.Cat.DKMemRelAttrMap

A C<DKMemRelAttrMap> is a C<Relation> that names the 0..N
relation-valued attributes of a host tuple/database type that are
participating in a distributed key, and says which of each of their
attributes maps to the attributes of the distributed key itself.

A C<DKMemRelAttrMap> has these 3 attributes:

=over

=item C<rel_name> - C<DeclNameChain>

This is the name of the relation-valued attribute that is participating in
the distributed key.  But the attribute named by C<rel_name> is only a
direct attribute of the host type if C<rel_name> has 1 chain element; if it
has more, then the host type attribute is a tuple/database and any further
elements serve to make C<rel_name> actually address a component of said.

=item C<comment> - C<Comment>

This is an optional programmer comment about the participation.

=item C<attr_map> - C<DKRelAttrKeyAttrMap>

This maps 0..N attributes of the relation with the same number of
attributes of the distributed key.  Every tuple of C<attr_map> must have an
identical value for the unary projection on its C<key_attr> attribute; in
other words, they must all map with the same distributed key attributes.

=back

A C<DKMemRelAttrMap> has a unary primary key on the C<rel_name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.DKRelAttrKeyAttrMap

A C<DKRelAttrKeyAttrMap> is a C<Relation>.  It maps 0..N attributes of
a relation-valued attribute of a host tuple/database type participating in
a distributed key, to the same number of attributes of the distributed key
itself.  A C<DKRelAttrKeyAttrMap> has 2 attributes, C<rel_attr> and
C<key_attr>, each of those being a C<Name>, and each of those being a
unary key.  Its default value has zero tuples.

=head2 sys.std.Core.Type.Cat.ForeignKeySet

A C<ForeignKeySet> is a C<Relation> that specifies a set of foreign
(non-distributed) keys over relation-valued attributes of a tuple/database;
each tuple specifies one foreign key, which is a kind of referential
constraint, that relates tuples of such attributes.  Each tuple of a child
attribute must have a corresponding tuple in a specific single parent
attribute, where they correspond on the attributes of the parent attribute
that comprise a (unique) key of the latter.  Note that it is valid to
define a foreign key involving zero attributes, but its effect would be a
no-op / a constraint that rejects nothing.

A C<ForeignKeySet> has these 6 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the foreign key.

=item C<comment> - C<Comment>

This is an optional programmer comment about the foreign key as a whole.

=item C<parent> - C<DeclNameChain>

This is the name of the relation-valued attribute that is the parent in the
foreign (non-distributed) key relationship.  But the attribute named by
C<parent> is only a direct attribute of the host type if C<parent> has 1
chain element; if it has more, then the host type attribute is a
tuple/database and any further elements serve to make C<parent> actually
address a component of said.

=item C<parent_key> - C<Name>

This is the name of the explicitly declared candidate key or unique key
constraint of C<parent> which defines the attributes of C<parent> that are
being matched on in the foreign key.

=item C<child> - C<DeclNameChain>

This is the name of the relation-valued attribute that is the child in the
foreign (non-distributed) key relationship; its structure is as per
C<parent>.  Note that C<child> and C<parent> are allowed to be one and the
same.

=item C<attr_map> - C<FKChildAttrParentAttrMap>

This maps 0..N attributes of the child relation with the same number of
attributes of the parent relation; the mapped attribute names may or may
not be the same.

=back

A C<ForeignKeySet> has a unary primary key on the C<name> attribute.
Its default value is empty.

=head2 sys.std.Core.Type.Cat.ForeignDistribKeySet

A C<ForeignDistribKeySet> is a C<Relation> that specifies a set of
foreign distributed keys over relation-valued attributes of a
tuple/database; each tuple specifies one foreign key, which is a kind of
referential constraint, that relates tuples of such attributes.  Each tuple
of a child attribute must have a corresponding tuple in one member of a
specific set of parent-alternative attributes (that have a distributed key
ranging over them), where they correspond on the attributes of the
parent-alternative attribute that comprise a distributed key on the latter.
Note that it is valid to define a foreign key involving zero attributes,
but its effect would be a no-op / a constraint that rejects nothing.

A C<ForeignDistribKeySet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the foreign key.

=item C<comment> - C<Comment>

This is an optional programmer comment about the foreign key as a whole.

=item C<parent_distrib_key> - C<DeclNameChain>

This is the name of the explicitly declared distributed (unique) key that
is the parent in the foreign distributed key relationship; it defines by
proxy the attributes that are being matched on in the foreign key.  But the
distributed key named by C<parent_distrib_key> may not be directly declared
by the host type of this foreign key; it might be declared by the type of
an attribute of the host type, if said attribute is a tuple/database; so
the only or last C<parent_distrib_key> chain element is a key name, and any
preceeding names are attribute names.

=item C<child> - C<DeclNameChain>

This is the name of the relation-valued attribute that is the child in the
foreign distributed key relationship.  But the attribute named by C<child>
is only a direct attribute of the host type if C<child> has 1 chain
element; if it has more, then the host type attribute is a tuple/database
and any further elements serve to make C<child> actually address a
component of said.

=item C<attr_map> - C<FKChildAttrParentAttrMap>

This maps 0..N attributes of the child relation with the same number of
attributes of the parent distributed key; the mapped attribute names may or
may not be the same.

=back

A C<ForeignDistribKeySet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.FKChildAttrParentAttrMap

A C<FKChildAttrParentAttrMap> is a C<Relation>.  It maps 0..N
attributes of a child relation-valued attribute of a host tuple/database
type participating in a foreign non-distributed or distributed key, to the
same number of attributes of a parent such attribute or a distributed key
of the host.  A C<FKChildAttrParentAttrMap> has 2 attributes,
C<child_attr> and C<parent_attr>, each of those being a C<Name>, and
each of those being a unary key.  Its default value has zero tuples.

=head2 sys.std.Core.Type.Cat.InnerUnionType

A C<InnerUnionType> is a C<Tuple>.  It defines a new data type whose
values are all drawn from one or more specified other types (which can be
any not-C<Empty> types at all), and that generally speaking it is an
arbitrary subset of C<Universal> (and it has its own default value).  The
value set of the new data type is determined by taking a set of source
types' values and subtracting from it a set of filter types' values (and
then optionally applying 0..N type constraint functions to the values
remaining).  The likely most common such type definition scenario is
defining a simple explicit union type of 2+ scalar source types.  Less
likely for usage, you can also define simple explicit intersection or
difference or exclusion types.  A union type does not define any changes or
supplements to the interfaces available for working with its values,
instead simply using those of its declared parent types.  A data type
defined in this way is typically not considered to exist when the system
wants to determine the MST (most specific type) of one of its values.

A C<InnerUnionType> has these 7 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the inner union type as a
whole.

=item C<sources> - C<set_of.Cat.NameChain>

These are the names of the 1..N other not-C<Empty> types that all the
values of the new data type are drawn from; the complete set of source
values is determined by either unioning (the default) or intersecting the
values of these types.

=item C<is_source_intersection> - C<Bool>

Iff this is C<Bool:true> then the set of source data types will be
intersected to determine the complete set of source values; iff this is
C<Bool:false> then the set of source data types will be unioned to
determine the complete set of source values.

=item C<filters> - C<set_of.Cat.NameChain>

These are the names of the 0..N other types (which are generally subtypes
of those of C<sources>) that determine values which the new data type will
I<not> contain; the complete set of filter values is determined by either
unioning (the default) or intersecting the values of these types.

=item C<is_filter_intersection> - C<Bool>

Iff this is C<Bool:true> then the set of filter data types will be
intersected to determine the complete set of filter values, and if
C<filters> has no elements then the filter set is just C<Universal>; iff
this is C<Bool:false> then the set of filter data types will be unioned to
determine the complete set of filter values, and if C<filters> has no
elements then the filter set is just C<Empty>.

=item C<constraints> - C<ConstraintSet>

This defines the entire (main) bodies of 0..N C<type_constraint> functions
that (when I<and>-ed together) determine what filter-type-passing
source-type values are part of the union type.  The implicit function
heading that each of these goes with has a single C<topic> parameter whose
declared type is C<Universal>, unless there is exactly 1 C<sources> element
whereupon the declared type is the same as the source type, and whose
argument is the value to test; the function's implicit result type is
C<Bool>.  If the functions unconditionally result in C<Bool:true>, then all
filter-type-passing values are allowed.

=item C<default> - C<InnerFuncBody>

This defines the entire (main) body of a C<type_default> function that
results in the default value of the union type; it has zero parameters and
its result type is the same as the union type whose declaration it is part
of.

=back

The default value of C<InnerUnionType> defines an alias for
C<Universal>, with the same default value; it has just the source type
C<Universal> and zero filter types, both type lists are unioned, and
C<constraints> is empty (unconditionally C<Bool:true>).  Note that there is
no valid combination of C<InnerUnionType> attribute values that would
result in an alias for the C<Empty> type, due to C<default> being
mandatory.

=head2 sys.std.Core.Type.Cat.InnerRestrType

A C<InnerRestrType> is a C<Tuple>.  It provides a relatively terse
method to define a simple restriction-defined subtype of a single other
type (which can be any not-C<Empty> type at all), which is a common kind of
type to have.  The new type is either a proper or non-proper subset of the
other type, whose values are determined from applying 0..N type constraint
functions to the parent type; either way, the new type does declare its own
default value.  An alternate common scenario is to define a non-proper
subtype of its parent type that serves just to supply a different default
value for the context in which the new type is used.  A restriction type
does not define any changes or supplements to the interfaces available for
working with its values, instead simply using those of its declared parent
type.  A data type defined in this way is typically not considered to exist
when the system wants to determine the MST (most specific type) of one of
its values.

A C<InnerRestrType> has these 4 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the inner restriction type as
a whole.

=item C<base_type> - C<NameChain>

This is the name of the not-C<Empty> other type that all the values of the
new data type are drawn from; the new type is being declared as a subtype
of that named by C<base_type>.

=item C<constraints> - C<ConstraintSet>

This defines the entire (main) bodies of 0..N C<type_constraint> functions
that (when I<and>-ed together) determine what base type values are part of
the restriction type.  The implicit function heading that each of these
goes with has a single C<topic> parameter whose declared type is that named
by C<base_type>, and whose argument is the value to test; the function's
implicit result type is C<Bool>.  If the functions unconditionally result
in C<Bool:true>, then the new type is a non-proper subtype of the base
type.

=item C<default> - C<InnerFuncBody>

This defines the entire (main) body of a C<type_default> function that
results in the default value of the restriction type; it has zero
parameters and its result type is the same as the restriction type whose
declaration it is part of.

=back

The default value of C<InnerRestrType> defines an alias for
C<Universal>, with the same default value; it has the base type
C<Universal> and C<constraints> is empty (unconditionally C<Bool:true>).
Note that there is no valid combination of C<InnerRestrType> attribute
values that would result in an alias for the C<Empty> type, due to
C<default> being mandatory.

=head1 SIMPLE GENERIC NONSCALAR TYPES

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.NameTypeMap

A C<NameTypeMap> is a C<Relation>.  It defines a basic component list,
meaning a set of names, with a declared data type name for each.  It forms
the foundation for most componentized type definitions, including all tuple
and relation types (for which it is named I<heading>), and it is used also
for the components list of a scalar possrep.  It is also used to define
parameter lists for routines.  A C<NameTypeMap> has 2 attributes,
C<name> (a C<Name>) and C<type> (a C<NameChain>); the C<name> is
the declared name of the attribute or parameter, and comprises a unary key;
the C<type> is the declared data type of the attribute or parameter.  Its
default value has zero tuples.

=head2 sys.std.Core.Type.Cat.NameExprMap

A C<NameExprMap> is a C<Relation>.  It defines a basic component-values
list, meaning a set of names, with a declared local expression node (or
parameter or variable) name for each.  It is used to define collection
literals; one C<NameExprMap> defines a whole C<Tuple> value.  It is
also used to define argument lists for routine invocations.  A
C<NameExprMap> has 2 attributes, C<name> (a C<Name>) and C<expr> (a
C<NameChain>); the C<name> is the name of the tuple/etc attribute or
routine argument, and comprises a unary key; the C<expr> is the declared
local name of the expression node (or parameter or variable) which defines
the value for the attribute or argument.  Note that while the C<expr>
attribute could conceivably just be a C<Name> because most of its
allowed values would be in the C<lex> namespace, the C<NameChain> is
used instead so that value expressions can take advantage of terse syntax
for addressing value attributes.  Its default value has zero tuples.

=head2 sys.std.Core.Type.Cat.NameDNCMap

A C<NameDNCMap> is a C<Relation>.  It defines an association of a short
name with a declaration name chain, to be used for aliasing the latter with
the former in a particular context.  A C<NameDNCMap> has 2 attributes,
C<name> (a C<Name>) and C<dnc> (a C<DeclNameChain>); each of those
is a unary key.  Its default value has zero tuples.

=head2 sys.std.Core.Type.Cat.AttrRenameMap

A C<AttrRenameMap> is a C<Relation>.  It is used as a specification for
how to rename attributes of some collection.  A C<AttrRenameMap> has 2
attributes, C<before> and C<after>, each of those being a C<Name>, and
each of those being a unary key.  Its default value has zero tuples.

=head2 sys.std.Core.Type.Cat.IfThenMap

A C<IfThenMap> is a C<Tuple>.  It defines an element of an if-else
sequential expression or statement.  A C<IfThenMap> has 2 attributes,
C<if> and C<then>, each of which is a C<NameChain>; C<if> has the name
of a local expression node (or parameter or variable), and C<then> in the
case of an if-else expression has likewise, or in the case of an if-else
statement has the name of a statement node.  For an if-else expression, the
C<if> node is the condition to evaluate; if that condition evaluates to
C<Bool:true>, then the C<then> node is evaluated and its result is the
result of the whole if-else expression; otherwise, C<then> is not
evaluated.  For an if-else statement, the C<if> node is the conditional
result variable name; if that conditional result is C<Bool:true>, then the
C<then> statement node is invoked; otherwise, C<then> is not invoked.  Its
default value has the default value of the C<NameChain> type in both
attributes.

=head2 sys.std.Core.Type.Cat.WhenThenMap

A C<WhenThenMap> is a C<Relation>.  It defines a set of dispatch
options for a given-when-default expression or statement.  A
C<WhenThenMap> has 2 attributes, C<when> and C<then>, each of which is
a C<NameChain>; C<when> has the name of a local expression node (or
parameter or variable), and C<then> in the case of a g-w-d expression has
likewise, or in the case of a g-w-d statement has the name of a statement
node.  The C<when> node is the not-common / distinct operand for each
condition.  For a g-w-d expression, if a C<when> value is matched, then the
C<then> node is evaluated and its result is the result of the whole g-w-d
expression; otherwise, C<then> is not evaluated.  For a g-w-d statement, if
a C<when> value is matched, then the C<then> statement node is invoked;
otherwise, C<then> is not invoked.  Its default value has zero tuples.

=head1 TYPES FOR SPECIAL ENTITY REFERENCES

Muldis D needs to support the concept of a closure or higher-order
function, mainly for functions but also to a smaller extent for imperative
routines.  For example, the generic relational restriction operator is
designed to conceptually take a function as an argument and then invoke
that function on each tuple of a relation it is filtering, and the function
has the criteria for whether the tuple passes the filter.

Conceptually, all that is needed is to pass the fully-qualified name of the
routine as such an argument, which in the system catalog is represented as
a C<NameChain>.  But using an actual C<NameChain> frequently
doesn't work to support closures because the typical closure is defined as
an I<inner routine> and those are expressly private to the context of the
outer entity that the inner is embedded in.  There is no valid
C<NameChain> value for referencing it from outside that context
(likewise for routines declared private to a package), and outside that
context is typically where the routines that take closures as arguments
would live.  For example, if public function C<dep.lib.mymain> had an inner
function C<inn.mytest> and C<dep.lib.myfoo> invoked the public function
C<dep.lib.myfilter> with an argument value of C<inn.mytest>, then if
C<dep.lib.myfilter> tried to invoke the function it was passed, it would
actually be trying to invoke an inner function of C<dep.lib.myfilter> named
C<inn.mytest>, which won't work.  Conceptually, a solution to this problem
is to actually pass a routine name in a more fully-qualified form,
conceptually like C<dep.lib.mymain.mytest>, which then C<dep.lib.myfilter>
could correctly invoke.  However, if that was made to work literally with a
C<NameChain>, then this could cause problems where anything could
invoke C<mytest> directly without being given permission from C<mymain>.

As an at-least-initial solution to this problem, here are a few black box
data types (specifically, quasi-scalar types with no possreps) which will
provide fully-qualified identifiers for routines, useful as alternatives to
C<NameChain> values, so any routine may be correctly invoked from any
other routine, without losing privacy.  Values of these types work their
magic by embedding knowledge about the lexical-et-al context in which they
were selected, so that when routines are to be invoked by way of those
values, the invocation of the capture effectively takes place within the
same context where the special type values were selected, as users would
conceptually expect.  Selecting one of these special values involves a
C<NameChain> argument, and the identity of the selected special value
is based on the combination of the argument and the context of selection,
more or less.  At the same time, every one of these values may incorporate
a meaningless random element to make every selection produce a distinct
value, even if more than one would have the same semantics.  However,
normal value assignment et al will preserve the same value of course, so
identity comparison of a C<V> with a C<v> that was previously assigned to
it would result in TRUE.  Currently, selecting these special values can not
be done with an ordinary routine, but only with a special catalog type for
an expression or statement node, due to the unusualness of this.  It is
also not possible to map one of these special values to another type.
There are no defined sorting orders for values of these types.  There are
default values for these types (of course), and those defaults are to
system-defined routines, for which incidentally the C<NameChain>
solution would always have worked.  These types are all infinite.

There are also similar special types here for referencing data types, but
not for as many of the reasons.  Maybe another advantage of all of the
above is that this can help compile-time type checking.

=head2 sys.std.Core.Type.Cat.FuncRef

This is a reference data type.  A C<FuncRef> is functionally like a
smart C<NameChain> that holds a function name but it remembers the
context of its creation.  It is used to implement a higher-order function
or a functional closure.  Its default value is a reference to the
C<sys.std.Core.Universal.is_identical> function.

=head2 sys.std.Core.Type.Cat.ProcRef

This is a reference data type.  A C<ProcRef> is functionally like a
smart C<NameChain> that holds an imperative routine name but it
remembers the context of its creation.  It is used to implement an
imperative closure. Its default value is a reference to the
C<sys.std.Core.Universal.assign> updater.

=head2 sys.std.Core.Type.Cat.TypeRef

This is a reference data type.  A C<TypeRef> is functionally like a
smart C<NameChain> that holds a data type name but it remembers the
context of its creation.  It is used in places where the name of a data
type to 'use' would be taken as a routine argument.  Its default value is a
reference to the C<sys.std.Core.Type.Bool> data type.

=head2 sys.std.Core.Type.Cat.OrdDetFuncRef

This is a reference data type.  A C<OrdDetFuncRef> is to a
C<OrdDetFuncNameChain> what a C<FuncRef> is to a C<NameChain>;
it implements a functional closure but its default value is a reference to
to the C<sys.std.Core.Scalar.order> function.

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::SeeAlso> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<perl@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright  2002-2008, Darren Duncan.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
