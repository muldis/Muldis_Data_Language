=pod

=encoding utf8

=head1 NAME

Muldis::D::Core::Types_Catalog -
Muldis D catalog-defining data types

=head1 VERSION

This document is Muldis::D::Core::Types_Catalog version 0.89.0.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document before
you read this one, which provides subservient details.  Moreover, you
should read the L<Muldis::D::Core> document before this current
document, as that forms its own tree beneath a root document branch.

=head1 DESCRIPTION

This document contains one or more sections that were moved here from
L<Muldis::D::Core> so that said other document would not be too
large.

These core data types are more special-purpose in nature and are intended
for use in defining or working with the system catalog.

Note that whenever an attribute of one of the nonscalar types isn't
significant, given the context (determined by other attributes of the same
type), and should be ignored, its value is the default for its type.

Note that many of the tuple types might conceptually have C<name>
attributes, but those would actually be provided by any larger types in
which they are embedded, rather than by these types themselves.

I<To keep things simpler for now, most constraint definitions for these
types are missing, or just defined informally.>

=head1 TYPE SUMMARY

These system-defined subtypes are specific to defining the system catalog,
more or less:

    sys.std.Core.Type.Universal

        sys.std.Core.Type.Empty

        sys.std.Core.Type.Scalar
            sys.std.Core.Type.DHScalar

                # The following are all regular ordered scalar types.

                sys.std.Core.Type.Cat.String
                    sys.std.Core.Type.Cat.String.*
                    sys.std.Core.Type.Cat.SEString
                    sys.std.Core.Type.Cat.BString
                    sys.std.Core.Type.Cat.OString
                    sys.std.Core.Type.Cat.UCPString
                sys.std.Core.Type.Cat.Name
                sys.std.Core.Type.Cat.NameChain
                sys.std.Core.Type.Cat.DeclNameChain
                sys.std.Core.Type.Cat.Comment
                sys.std.Core.Type.Cat.Order

                # The following are all regular non-ordered scalar types.

                sys.std.Core.Type.Cat.RatRoundMeth
                sys.std.Core.Type.Cat.RatRoundRule

        sys.std.Core.Type.Tuple
            sys.std.Core.Type.DHTuple

                # The following are all regular tuple types.

                sys.std.Core.Type.Cat.FuncHead
                sys.std.Core.Type.Cat.FuncBody
                sys.std.Core.Type.Cat.IfThenExprMap
                sys.std.Core.Type.Cat.UpdHead
                sys.std.Core.Type.Cat.UpdBody
                sys.std.Core.Type.Cat.ProcHead
                sys.std.Core.Type.Cat.ProcBody
                sys.std.Core.Type.Cat.IfThenVarStmtMap
                sys.std.Core.Type.Cat.ScalarType
                sys.std.Core.Type.Cat.NonscalarType
                sys.std.Core.Type.Cat.UnionType
                sys.std.Core.Type.Cat.RestrType
                sys.std.Core.Type.Cat.OrderByName

                sys.std.Core.Type.Database

                    # The following are all regular database types.

                    sys.std.Core.Type.Cat.System
                    sys.std.Core.Type.Cat.MountControlCat
                    sys.std.Core.Type.Cat.TopicNSControlCat
                    sys.std.Core.Type.Cat.Federation
                    sys.std.Core.Type.Cat.Depot
                    sys.std.Core.Type.Cat.ExprNodeSet
                    sys.std.Core.Type.Cat.StmtNodeSet

        sys.std.Core.Type.Relation
            sys.std.Core.Type.DHRelation

                # The following are all regular relation types.

                sys.std.Core.Type.Cat.SysNspSet
                sys.std.Core.Type.Cat.Sys[Func|Upd|Proc]Set
                sys.std.Core.Type.Cat.SysSpecTypeSet
                sys.std.Core.Type.Cat.Sys[Sca|Nonsca|Uni|Restr]TypeSet
                sys.std.Core.Type.Cat.SysCatSet
                sys.std.Core.Type.Cat.MountControlSet
                sys.std.Core.Type.Cat.DepotMountSet
                sys.std.Core.Type.Cat.FedTypeMapSet
                sys.std.Core.Type.Cat.FedTypeMap
                sys.std.Core.Type.Cat.SubdepotSet
                sys.std.Core.Type.Cat.[Func|Upd|Proc]Set
                sys.std.Core.Type.Cat.[Sca|Nonsca|Uni|Restr]TypeSet
                sys.std.Core.Type.Cat.ScaValExprNodeSet
                sys.std.Core.Type.Cat.ScaPRSelExprNodeSet
                sys.std.Core.Type.Cat.TupSelExprNodeSet
                sys.std.Core.Type.Cat.RelSelExprNodeSet
                sys.std.Core.Type.Cat.SetSelExprNodeSet
                sys.std.Core.Type.Cat.ArySelExprNodeSet
                sys.std.Core.Type.Cat.BagSelExprNodeSet
                sys.std.Core.Type.Cat.AccExprNodeSet
                sys.std.Core.Type.Cat.FuncInvoExprNodeSet
                sys.std.Core.Type.Cat.IfElseExprNodeSet
                sys.std.Core.Type.Cat.GivenWhenDefExprNodeSet
                sys.std.Core.Type.Cat.WhenThenExprMap
                sys.std.Core.Type.Cat.MaterialRefSelExprNodeSet
                sys.std.Core.Type.Cat.MultiUpdStmt
                sys.std.Core.Type.Cat.LeaveStmtNodeSet
                sys.std.Core.Type.Cat.CompoundStmtNodeSet
                sys.std.Core.Type.Cat.ImpInvoStmtNodeSet
                sys.std.Core.Type.Cat.IISArgVarMap
                sys.std.Core.Type.Cat.IfElseStmtNodeSet
                sys.std.Core.Type.Cat.GivenWhenDefStmtNodeSet
                sys.std.Core.Type.Cat.WhenThenVarStmtMap
                sys.std.Core.Type.Cat.IterateStmtNodeSet
                sys.std.Core.Type.Cat.LoopStmtNodeSet
                sys.std.Core.Type.Cat.PossrepSet
                sys.std.Core.Type.Cat.PossrepMapSet
                sys.std.Core.Type.Cat.VirtualAttrMapSet
                sys.std.Core.Type.Cat.KeySet
                sys.std.Core.Type.Cat.DistribKeySet
                sys.std.Core.Type.Cat.DKMemRelAttrMap
                sys.std.Core.Type.Cat.DKRelAttrKeyAttrMap
                sys.std.Core.Type.Cat.SubsetConstrSet
                sys.std.Core.Type.Cat.DistribSubsetConstrSet
                sys.std.Core.Type.Cat.SCChildAttrParentAttrMap
                sys.std.Core.Type.Cat.NameTypeMap
                sys.std.Core.Type.Cat.NameExprMap
                sys.std.Core.Type.Cat.NameDNCMap
                sys.std.Core.Type.Cat.AttrRenameMap

These system-defined subtypes can never be used as components of a system
catalog, or any database, but they may be used temporarily at runtime:

    sys.std.Core.Type.Universal

        sys.std.Core.Type.Empty

        sys.std.Core.Type.Reference

            # The following are special-purpose reference types.

            sys.std.Core.Type.Cat.MaterialRef
                sys.std.Core.Type.Cat.FuncRef
                    sys.std.Core.Type.Cat.OrdDetFuncRef
                    sys.std.Core.Type.Cat.ValFiltFuncRef
                    sys.std.Core.Type.Cat.ValMapFuncRef
                    sys.std.Core.Type.Cat.ValRedFuncRef
                sys.std.Core.Type.Cat.ImpRef
                    sys.std.Core.Type.Cat.UpdRef
                sys.std.Core.Type.Cat.TypeRef

=head1 SIMPLE GENERIC SCALAR TYPES

=head2 sys.std.Core.Type.Cat.String

This is an enumeration data type.  The C<String> type is a union type over
the infinite number of types having
C<sys.std.Core.Type.Cat.String.*>-format names (see also their collective
entry in the type list).  A C<String> is a string of integers, or more
specifically it is a dense sequence of 0..N elements (I<not> defined over
C<Relation>) where each element is an integer.  Its default and minimum
value is the empty sequence; its maximum value is an infinite-length
sequence and practically impossible.  The cardinality of this type is
infinity; to define a most-generalized finite C<String> subtype, you must
specify a maximum length in elements that the subtype's values can have,
and you must specify the 2 integer end-points of the inclusive range that
all its values' integer elements are in.  The C<String> type has a default
ordering algorithm; for 2 distinct C<String> values, their order is
determined as follows:  First eliminate any identical leading element
sequences from both strings as those alone would make the strings compare
as same (if the remainder of both strings was the empty string, then the
strings are identical).  Then, iff the remainder of just one string is the
empty string, then that string is ordered before the non-empty one;
otherwise, compare the first element of each of the string remainders
according to the following ordering algorithm to get the order of their
respective strings: the integer value closer to negative infinity is
ordered before the value closer to positive infinity.

=head2 sys.std.Core.Type.Cat.String.*

There are an infinite number of types having
C<sys.std.Core.Type.Cat.String.*>-format names and each one is a structure
data type; for the rest of this description, the type name C<String.Value>
will be used as a proxy for each and every one of them.  A C<String.Value>
is a string of integers, or more specifically it is a dense sequence of
0..N elements (I<not> defined over C<Relation>) where each element is an
integer.  A C<String.Value> has 1 system-defined possrep whose name is the
empty string and which has zero attributes.  The cardinality of this type
is 1, and its only value is its default and minimum and maximum value.

The sole value of C<String.Value> is the same as the decoded form of its
unqualified name, or more accurately, it is identical to the decoded form
of the sole attribute value of the sole possrep of the C<Name> value
C<Value>.  The unqualified name of the type C<String.Value> is formatted
simply as a (ordered) sequence of tokens where each token defines an
integer element of the C<String> and the token is formatted as a base-10
integer literal delimited with less-than and greater-than characters; for
example, the C<Name> value C<< <80><101><114><109> >> defines a 4-element
C<String>.  Said unqualified name format is the encoded form of the
C<String.Value> type's name.  The reason for using encoding like this is
that a C<Name> string element is limited to specific range of integer
values where a C<String> element can be any integer, so a one-to-one
element mapping isn't possible.

Now, one main rationale to have the system-defined C<String> type as a
union type over an infinite number of C<String.*> types, is to avoid any
"chicken and egg" scenario where at least one scalar root type needs to
be special and have no possreps in order to be the foundation for other
scalar root types.  Under the current system, I<every> scalar root type
has at least one possrep and the type system design does not require any
scalar root type to be special.  One can always avoid the need for some
other type to base your scalar root type off of by building your scalar
root type over singleton types with no possrep attributes.  That said, the
fact that an implicitly defined infinity of types underlie C<String>
(rather than an explicitly defined finite set of types) now is another kind
of special that user-defined types can't do, but this solution seemed to be
the lesser of evils versus some scalar root types having no possreps.

=head2 sys.std.Core.Type.Cat.SEString

This is an enumeration data type.  C<SEString> (single-element string) is a
proper subtype of C<String> where all member values have exactly one
element.  One can be used to represent an integer.

=head2 sys.std.Core.Type.Cat.BString

This is an enumeration data type.  C<BString> (bit string) is a proper
subtype of C<String> where all member value elements are between zero and
1 inclusive.  One can be used to represent a string of bits.

=head2 sys.std.Core.Type.Cat.OString

This is an enumeration data type.  C<OString> (octet string) is a proper
subtype of C<String> where all member value elements are between zero and
255 inclusive.  One can be used to represent a string of octets.

=head2 sys.std.Core.Type.Cat.UCPString

This is an enumeration data type.  C<UCPString> (Unicode abstract codepoint
string) is a proper subtype of C<String> where all member value elements
are between zero and F;D7FF inclusive or F;E000 and F;10FFFF inclusive.  As
of the Unicode standard version 5.1.0, all character abstract codepoints
exist within that range, and so each element could be used to represent any
Unicode character and the whole string can be used to represent a string of
Unicode characters.

There are no Unicode abstract codepoints between F;D800 and F;DFFF
inclusive; those numbers would only represent special surrogates that do
not define extra abstract characters and only have any meaning in
conjunction with the UTF-16 character encoding form; and so the
C<UCPString> type specifically excludes them from use in its member values;
you must just use the normal character abstract codepoints instead.

=head2 sys.std.Core.Type.Cat.Name

This is a structure data type.  A C<Name> (scalar) is a canonical short
name for any kind of DBMS entity (or named component) when declaring it;
this short name is sufficient to identify the entity within its immediate
namespace.  Similarly, a DBMS entity can often be invoked or referred to
using just its C<Name>, depending on the context; other times, a
C<NameChain> must be used instead to also qualify the reference with a
namespace.  A C<Name> has 1 system-defined possrep whose name is the empty
string, which has 1 C<Text>-typed attribute whose name is the empty
string.  A C<Name> is a simple wrapper for a C<Text> and all of its other
details such as default and minimum and maximum values and cardinality and
default ordering algorithm all correspond directly.  But C<Name> is
explicitly disjoint from C<Text> due to having a different intended
interpretation; it is specifically intended for use in naming DBMS entities
rather than being for general-purpose user data.

=head2 sys.std.Core.Type.Cat.NameChain

This is a structure data type.  A C<NameChain> (scalar) is a canonical long
name for invoking or referring to a DBMS entity, when its name needs to be
qualified with a namespace.  A C<NameChain> is conceptually a sequence of
2..N C<Name>, the 2..N elements being ordered from parent-most to
child-most component name.  A C<NameChain> has 1 system-defined possrep
named C<array> which directly matches the conception of the type; it
consists of 1 attribute whose name is the empty string; the attribute is an
C<Array> whose C<value> attribute has a declared type of C<Name> and that
must have at least 2 elements.  The default and minimum value of
C<NameChain> is a 2 element sequence where each element is the default
value of C<Name> (the empty string); its maximum value is an infinite
sequence where each element is the maximum value of C<Name> (an
infinite-length string) and practically impossible.  The cardinality of
this type is infinity; to define a most-generalized finite C<NameChain>
subtype, you must specify a maximum number of sequence elements of its
values, and each element must be of a finite C<Name> subtype.  The
C<NameChain> type has a default ordering algorithm; for 2 distinct
C<NameChain> values, their order is determined as follows:  First eliminate
any identical parent-most elements from both chains as those alone would
make the chains compare as same (if the remainder of both chains was the
empty chain, then the chains are identical).  Then, iff the remainder of
just one chain is the empty chain, then that chain is ordered before the
non-empty one; otherwise, compare the first element of each of the chain
remainders according to the default ordering algorithm of C<Name> to get
the order of their respective chains.

=head2 sys.std.Core.Type.Cat.DeclNameChain

This is a structure data type.  A C<DeclNameChain> (scalar) is exactly the
same in structure as a C<NameChain> but that it is a sequence of 0..N
rather than 2..N.  A C<DeclNameChain> is used in declaring system catalogs
where DBMS entities live under a potentially N-depth namespace, such as
depot entities grouped in a subdepot hierarchy.  The default and minimum
value of C<DeclNameChain> is a zero element sequence.  The C<DeclNameChain>
type has a default ordering algorithm; it is the same as for C<NameChain>.

=head2 sys.std.Core.Type.Cat.Comment

This is a structure data type.  A C<Comment> (scalar) is the text of a
Muldis D code comment, which programmers can populate as an attribute of
several catalog data types, such as whole routines or statements or
expression nodes.  Every detail of C<Comment>'s representation (its 1
possrep, default value and ordering algorithm, etc) is the same as C<Name>
but it is explicitly disjoint due to having a different intended
interpretation; it is intended just for commenting Muldis D code.  One main
intended use of this type is to help preserve comments in code translated
to or from other languages; though only a subset of those (FoxPro?) keep
comments in the AST rather than discarding them.

=head2 sys.std.Core.Type.Cat.Order

This is a structure data type.  C<Order> (order determination) consists of
just the 3 values C<increase>, C<same>, C<decrease>.  When some context
(such as within a list sort or range check operation) needs to know the
relative order of 2 values according to some criteria, it can invoke a
function that applies that criteria to those 2 values, which are its
main/only arguments, and that function results in an C<Order> value for the
context to make use of.  An C<Order> has 2 system-defined possreps, named
C<name> and C<int>.  The C<name> possrep directly matches the conception of
the type as consisting of 3 character string values; it consists of 1
C<Name>-typed attribute whose name is the empty string.  The C<int> possrep
consists of 1 C<Int>-typed attribute whose name is the empty string and
whose value must be one of [C<-1>, C<0>, C<1>]; the 3 values of each
possrep correspond in the same order as they are documented here.  The
default value of C<Order> is C<same>; its minimum and maximum values are,
respectively, C<increase> and C<decrease>.  The cardinality of this type is
3.  The C<Order> type has a default ordering algorithm that corresponds
directly to that of its C<int> possrep attribute; C<increase> is ordered
before C<same>, and C<same> before C<decrease>.  The C<Order> type has an
implementation hint for less intelligent Muldis D implementations, that
suggests using the C<int> possrep as the basis for the physical
representation.

=head2 sys.std.Core.Type.Cat.RatRoundMeth

This is a structure data type.  C<RatRoundMeth> (rounding method) consists
of just the 7 values C<half_down>, C<half_up>, C<half_even>, C<to_floor>,
C<to_ceiling>, C<to_zero>, C<to_inf>.  A C<RatRoundMeth> has 1
system-defined possrep whose name is the empty string, which has 1
C<Name>-typed attribute whose name is the empty string.  When a value
of some ordered type needs to be mapped into a proper subtype that doesn't
contain that value, such as when mapping an arbitrary number to one with
less precision, some rounding method is applied to determine which value of
the subtype is to be mapped to while most accurately reflecting the
original value.  The C<RatRoundMeth> type enumerates the rounding methods
that Muldis D operators can typically apply.  With C<half_down>,
C<half_up>, and C<half_even> (aka I<unbiased rounding>, I<convergent
rounding>, I<statistician's rounding>, or I<bankers' rounding>), the
original value will be mapped to the single target value that it is closest
to, if there is one; otherwise, if it is exactly half-way between 2
adjacent target values, then C<half_down> will round towards negative
infinity, C<half_up> will round towards positive infinity, and C<half_even>
will round towards the nearest "even" target.  With C<to_floor>,
C<to_ceiling>, C<to_zero> (aka I<truncate>), C<to_inf>, the original value
will always be mapped to the single adjacent value that is lower than it,
or higher than it, or towards "zero" from it, or towards the nearer
infinity from it, respectively.  The default value of C<RatRoundMeth> is
C<half_up>, since that is the most commonly used method of rounding.  The
C<RatRoundMeth> type does I<not> have a default ordering algorithm.

=head2 sys.std.Core.Type.Cat.RatRoundRule

This is a structure data type.  A C<RatRoundRule> (scalar) specifies a
controlled (and typically degrading) coercion of a real number into a
rational number having a specific radix and precision.  It is mainly used
to deterministically massage an operation, whose conceptual result is
generally an irrational number, so that its actual result is a best
approximating rational number.  It is also used to define a generic
rounding operation on a rational number that derives a typically less
precise rational.  A C<RatRoundRule> has 1 system-defined possrep whose
name is the empty string, which has these 3 attributes: C<radix> (a
C<PInt2_N>), C<min_exp> (an C<Int>), and C<round_meth> (a C<RatRoundMeth>).
The rational resulting from the operation is as close as possible to the
conceptual result but that it is an exact multiple of the rational value
resulting from C<radix> taken to the power of C<min_exp>; if rounding is
needed, then C<round_meth> dictates the rounding method.  The default value
of C<RatRoundRule> specifies a coersion to a whole number using the
C<half_up> rounding method (its radix is 2 and its min exp is 0).  The
C<RatRoundRule> type does I<not> have a default ordering algorithm.

=head1 TYPES FOR DEFINING SYSTEM-DEFINED ENTITIES

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.System

A C<System> is a C<Database>.  It specifies the public interfaces of
system-defined entities, specifically all the system-defined types,
routines, and catalogs.  Both standard system-defined entities and
implementation-specific system-defined entities are specified here,
specifically all the relcons and relvars with the names
C<[sys|mnt|fed|dep|sdp].cat>.  The system catalog constant named
C<sys.cat> is of the C<System> type.

A C<System> has these 11 attributes:

=over

=item C<comment> - C<single_of.Comment>

This is an optional programmer comment about the collection of
system-defined entities as a whole.

=item C<namespaces> - C<SysNspSet>

These are all the system-defined namespaces where DBMS entities may live,
or that otherwise always exist due to being system-defined.  Specifically,
it declares these 24 standard language namespaces:
C<[sys|mnt|tpc|fed|dep|sdp|lex]> (which have the nameless global
root namespace as their parent, spelled as the empty C<DeclNameChain>
value, that isn't also declared here), C<sys.[cat|std|imp]>,
C<[mnt|tpc].cat>, C<[fed|dep|sdp].[cat|lib|data]>, C<sys.std.Core>,
C<sys.std.Core.Type>, C<sys.std.Core.Type.Cat>; it also declares other
C<Core> namespaces, and where applicable, standard extensions or
implementation-specific extensions.

=item C<functions|updaters|procedures> - C<Sys[Func|Upd|Proc]Set>

These are the interfaces, or definitions in some cases, of all the
system-defined functions|updaters|procedures.  (Note that C<procedures>
also specifies the system-defined system services.)

=item C<special_types> - C<SysSpecTypeSet>

These are the few central system-defined data types that have special
hard-coded meanings and are not defined like any other types; these are
declarations of all of the native Muldis D types that can't be defined like
user-defined types.  Specifically, it declares these 9 standard types: in
the C<sys.std.Core.Type> namespace, C<Universal>, C<Empty>, C<Scalar>,
C<Tuple>, C<Relation>, C<Reference>, C<External>; in the
C<sys.std.Core.Type.Cat> namespace, C<String> and C<MaterialRef>.  These
constitute all 2 Muldis D primitive types, all 2 Muldis D reference types,
all 2 Muldis D type system minimal and maximal (enumeration) types, all 3
Muldis D enumeration types that are each implicit maximal types of 2 of 4
non-remnant type categories (the other 2 such maximals are primitive
types), and the 1 sole scalar enumeration type that is defined in terms of
an infinite number of singleton structure types (and those structure types
are not listed individually in the system catalog at all, for what should
be obvious reasons).

=item C<[sca|nonsca|uni|restr]_types> - C<Sys[Sca|Nonsca|Uni|Restr]TypeSet>

These are all the system-defined scalar types, except for
C<String> because it can't be defined like user-defined types, and complete
nonscalar types, and union types, and restriction types.

=item C<catalogs> - C<SysCatSet>

These are the interfaces of all the catalog relcons and relvars.
Specifically, it declares these 5 standard catalogs:
C<[sys|mnt|fed|dep|sdp].cat>; the first is a relcon, the others not.

=back

The default value of C<System> defines a system with zero builtins.

=head2 sys.std.Core.Type.Cat.SysNspSet

A C<SysNspSet> is a C<DHRelation> that specifies the set of system
namespaces that exist for organizing DBMS public entities, mostly the
system-defined ones; these system namespaces are organized into a tree
whose root has no name.  A C<SysNspSet> only specifies that a system
namespace exists, not which public entities it contains; see the
C<System> which contains it for that.

A C<SysNspSet> has these 3 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the nameless global root namespace, of
the system namespace's parent system namespace.

=item C<name> - C<Name>

This is the declared name of the system namespace within the namespace
defined by C<parent>; other Muldis D code would reference it with the
combination of C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about this specific system
namespace.

=back

A C<SysNspSet> has a binary primary key on the C<parent> plus
C<name> attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.Sys[Func|Upd|Proc]Set

A C<Sys[Func|Upd|Proc]Set> is a C<DHRelation> that specifies a set of
system-defined functions|updaters|procedures.  (Note that C<SysProcSet>
also specifies the system-defined system services.)

A C<Sys[Func|Upd|Proc]Set> has these 5|4|4 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the nameless global root namespace, of
the function|updater|procedure's parent system namespace.

=item C<name> - C<Name>

This is the declared name of the function|updater|procedure within the
namespace defined by C<parent>; other Muldis D code would reference it with
the combination of C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about the function|updater|procedure
as a whole.

=item C<head> - C<[Func|Upd|Proc]Head>

This defines the entire function|updater|procedure heading, that is its
public interface sans its name, which is all the details of how to use it
and no more detail than necessary about how it is implemented.

=item C<body> - C<maybe_of.FuncBody>

Iff the function exists for the sole purpose of being part of a
system-defined type's definition, then it is fully defined in the system
catalog as well, and C<body> is a C<Single> whose sole element defines the
entire function body, that is its implementation, besides what C<head>
defines.  Iff the function exists for another purpose, because it is a
normal system-defined function, then only the function's interface is
defined in the system catalog, and C<body> is C<nothing>.

=back

A C<Sys[Func|Upd|Proc]Set> has a binary primary key on the C<parent>
plus C<name> attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.SysSpecTypeSet

A C<SysSpecTypeSet> is a C<DHRelation> that specifies a set of
system-defined types which are particularly special and unlike other types;
it is used for declaring all system types that can't be defined like user
types.

A C<SysSpecTypeSet> has these 3 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the nameless global root namespace, of
the type's parent system namespace.

=item C<name> - C<Name>

This is the declared name of the type within the namespace defined by
C<parent>; other Muldis D code would reference it with the combination of
C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about the type as a whole.

=back

A C<SysSpecTypeSet> has a binary primary key on the C<parent> plus
C<name> attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.Sys[Sca|Nonsca|Uni|Restr]TypeSet

A C<Sys[Sca|Nonsca|Uni|Restr]TypeSet> is a C<DHRelation> that specifies a
set of scalar|nonscalar|union|restriction system-defined types.

A C<Sys[Sca|Nonsca|Uni|Restr]TypeSet> has these 4 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the nameless global root namespace, of
the scalar|nonscalar|union|restriction type's parent system namespace.

=item C<name> - C<Name>

This is the declared name of the scalar|nonscalar|union|restriction type
within the namespace defined by C<parent>; other Muldis D code would
reference it with the combination of C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about the
scalar|nonscalar|union|restriction type as a whole.

=item C<type> - C<[Scalar|Nonscalar|Union|Restr]Type>

This defines the entire scalar|nonscalar|union|restriction type sans its
name.

=back

A C<Sys[Scalar|Nonscalar|Union|Restr]TypeSet> has a binary primary key on
the C<parent> plus C<name> attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.SysCatSet

A C<SysCatSet> is a C<DHRelation> that specifies a set of system-defined
catalog dbvars; each tuple specifies one catalog dbvar.

A C<SysCatSet> has these 4 attributes:

=over

=item C<name> - C<NameChain>

This is the fully-qualified name of the catalog dbvar.

=item C<comment> - C<Comment>

This is an optional programmer comment about the catalog dbvar as a whole.

=item C<is_readonly> - C<Bool>

This is C<Bool:true> if a catalog relcon is being described; it is
C<Bool:false> if a catalog relvar is being described.

=item C<catalog> - C<NameChain>

This is the declared data type of the catalog dbvar.

=back

A C<SysCatSet> has a unary primary key on the C<name> attribute.  Its
default value is empty.

=head1 TYPES FOR DEFINING MOUNT CONTROLS

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.MountControlCat

A C<MountControlCat> is a C<Database>.  It specifies the control
interface for mounting and unmounting (and creating and deleting) depots
within the current in-DBMS process.  The scope of these controls includes
specifying what name the depot is mounted with, whether the mount is
readonly vs updateable, or is temporary vs persistant, and implementation
specific details like storage file names or network login credentials.
Updates to this catalog have side-effects in what other user-updateable
catalogs exist, making them appear or disappear.  This catalog may only be
updated when the current process has no active transaction.  The system
catalog variable named C<mnt.cat> is of the C<MountControlCat> type.

A C<MountControlCat> has these 2 attributes:

=over

=item C<comment> - C<single_of.Comment>

This is an optional programmer comment about the depot mount control
catalog as a whole.

=item C<mounts> - C<MountControlSet>

These are the controls for the current depot mounts.

=back

The default value of C<MountControlCat> has zero depot mount controls.

=head2 sys.std.Core.Type.Cat.MountControlSet

A C<MountControlSet> is a C<DHRelation> that specifies a set of controls
per depot mounts, such that each tuple is a single control for a depot
mount, and each depot mount has 1 mount control.  Inserting a tuple will
result in either an existing depot being mounted or a new depot being
created (if possible) and mounted; updating a tuple will change some
details of that depot mount's status, such as making it readonly or
updateable; deleting a tuple will result in a mounted depot being either
unmounted or unmounted plus deleted (if possible).

A C<MountControlSet> has these 7 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the depot mount; other Muldis D code would
reference it with this name.

=item C<comment> - C<Comment>

This is an optional programmer comment about this specific mount of the
depot.

=item C<is_temporary> - C<Bool>

This is C<Bool:true> if the depot mount is for a transient depot that would
automatically be created when mounted I<and> automatically be deleted when
unmounted, because it is only intended for use as the application's current
working memory, and its maximum lifetime is the lifetime of the in-DBMS
process.  This is C<Bool:false> (the default) if the depot mount is for a
depot that either should already exist before being mounted, I<or> that
should continue to exist after being unmounted, because it is intended for
persistent data.  Note that the C<is_temporary> status is orthogonal to
whether the depot's storage is in volatile memory (eg, RAM) or in stable
memory (eg, on disk); a I<not-temporary> depot is simply one that is meant
to be reusable by multiple depot mounts or processes.  The C<is_temporary>
status may not be updated on an existing depot mount control.  I<These
details are subject to revision.>

=item C<create_on_mount> - C<Bool>

This is C<Bool:true> if the depot mount must represent a depot that was
newly created at the time the depot mount was created, where the depot
creation is a direct side-effect of the mount operation.  This is
C<Bool:false> (the default) if the depot being mounted must already exist
without the mounting process having any hand in creating it.  Note that
there is no option provided to conditionally create a depot depending on
whether it already exists, as a perceived safety feature (this detail is
subject to change); to get that behaviour, first try creating the depot
mount control with this attribute C<Bool:false>, and if that fails due to
nonexistence, then try again with it set to C<Bool:true>.  This attribute
is ignored / not applicable when C<is_temporary> is true.

=item C<delete_on_unmount> - C<Bool>

This is C<Bool:true> if the depot should be deleted at the same time it is
unmounted, that is, when this depot mount control tuple is deleted.  This
is C<Bool:false> (the default) if the depot should not be deleted as part
of the unmount process.  This attribute is ignored / not applicable when
C<is_temporary> is true.

=item C<we_may_update> - C<Bool>

This is C<Bool:true> if the depot mount will permit the current in-DBMS
process to make any kind of update to the depot, such as data manipulation,
data definition, or creating/deleting it.  This is C<Bool:false> (the
default) if the depot mount is only providing readonly access to the depot.
When a depot mount is readonly, any attempt to update the depot through it
will throw a runtime exception.  The C<we_may_update> attribute may be set
to C<Bool:false> at any time (when there is no active transaction), but it
may only be set to C<Bool:true> at the time the depot is mounted; this is
for safety, such that if a depot mount won't let you update the depot now,
there's no way it will let you update it later, save by unmounting and
remounting the depot (the result of which is a different depot mount).
Note that the C<we_may_update> status is orthogonal to the depot locking
mechanism; it won't block any other process from reading or updating that
depot, so unless you have locks on the depot using some other means, it may
still be updated by others while mounted readonly for you, so consistent
reads between distinct statements outside of transactions are not
guaranteed.  I<These details are subject to revision, such as in regards to
what autonomous child processes of the current process may do.>

=item C<details> - C<ScaValExprNodeSet>

These are the 0..N other miscellaneous details that define this depot mount
control.  Each tuple in C<details> specifies an implementation-specific
attribute name and (scalar) value.  Example such implementation-specific
details include the name of a local file that the depot is stored as, or
the name of a DBMS server on the network plus authentication credentials to
connect to it with.  See each Muldis D implementation for details.  Note
that C<details> generally corresponds to the Perl DBI's concept of a data
source name or connection string.  But C<details> can also have other
details like customizations on how to map a foreign DBMS' concepts to
native Muldis D equivalents, or maybe information on where to find extra
meta-data that has such info, or info to instruct a Muldis D interface to
fill in functionality missing in the actual depot of a less capable DBMS,
like constraints or stored invokable routines.

=back

A C<MountControlSet> has a unary primary key on the C<name> attribute.
Its default value is empty.  It also has a transition constraint that
prevents changing some attributes of a depot mount control once set.  Note
that the 3 attributes [C<is_temporary>, C<create_on_mount>,
C<delete_on_unmount>] may be merged into a single enumerated-typed
attribute or otherwise be reorganized.

=head1 TYPES FOR DEFINING TOPIC NAMESPACE CONTROLS

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.TopicNSControlCat

A C<TopicNSControlCat> is a C<Database>.  It specifies the control
interface for what depot|subdepot is the current topic for DBMS
entity referencing code.  The system catalog variable named C<tpc.cat> is
of the C<TopicNSControlCat> type.

A C<TopicNSControlCat> has these 3 attributes:

=over

=item C<comment> - C<single_of.Comment>

This is an optional programmer comment about the topic namespace control
catalog as a whole.

=item C<topic_depot> - C<maybe_of.Name>

This specifies a topic depot for the DBMS if it is a C<Single>; if it is
C<nothing>, then the DBMS has no topic depot.

=item C<topic_subdepot> - C<maybe_of.DeclNameChain>

This specifies a topic subdepot for the DBMS within a specified
C<topic_depot> if it is a C<Single>; if it is C<nothing>, then the DBMS has
no topic subdepot.

=back

The default value of C<TopicNSControlCat> has all-C<nothing> attributes.

=head1 TYPES FOR DEFINING FEDERATIONS

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.Federation

A C<Federation> is a C<Database>.  It specifies a federation of depot
mounts, that is, all the depot mounts that an in-DBMS process can see or
update, and that defines the scope of an active transaction.  There is
exactly one of these per process and it doesn't have a name.  The system
catalog variable named C<fed.cat> is of the C<Federation> type.

A C<Federation> has these 3 attributes:

=over

=item C<comment> - C<single_of.Comment>

This is an optional programmer comment about the federation as a whole.

=item C<mounts> - C<DepotMountSet>

These are the depot mounts that comprise the federation.

=item C<type_maps> - C<FedTypeMapSet>

When this federation has more than one depot mount, and the depots have
copies of the same data types, then C<type_maps> is used to specify which
types in each depot correspond to types in others, so that during the time
period of common mounting, those data types can be treated as aliases and
so be used interchangeably.  Mainly this is used when either a procedure in
one depot wants to access or update a dbvar of another depot, or when a
procedure in one depot wants to invoke a routine in another depot, that
have parameters/etc of some user-defined data type.  The expected most
common use case would be when there are 2 depot mounts, one being a
persistent database and the other being transient application-specific code
that creates or otherwise works with that persistent database.

=back

The default value of C<Federation> has zero depot mounts.

=head2 sys.std.Core.Type.Cat.DepotMountSet

A C<DepotMountSet> is a C<DHRelation> that specifies a set of depot
mounts, such that each tuple is a single depot mount.  A depot mount is a
named in-DBMS context by which a depot is referenced from either other
depots or by the main application, and it also specifies the catalog
content of the depot itself.

A C<DepotMountSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the depot mount; other Muldis D code would
reference it with this name.

=item C<comment> - C<Comment>

This is an optional programmer comment about this specific mount of the
depot.

=item C<depot> - C<Depot>

This defines the entire system catalog of the depot that this mount has
made visible to the DBMS.

=back

A C<DepotMountSet> has a unary primary key on the C<name> attribute.
Its default value is empty.

=head2 sys.std.Core.Type.Cat.FedTypeMapSet

A C<FedTypeMapSet> is a C<DHRelation> such that each tuple in it
specifies which of multiple depots have a copy of the same data type, for
the purpose of treating all the copies as being interchangeable, so to
support cross-depot interaction.

A C<FedTypeMapSet> has these 2 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about this type mapping.

=item C<map> - C<FedTypeMap>

This lists the fully-qualified names of 0..N data types that are all
considered to be copies of the same 1 type, and should be treated
interchangeably by the DBMS.

=back

A C<FedTypeMapSet> has a primary key on the C<map> attribute.  Its
default value is empty.

=head2 sys.std.Core.Type.Cat.FedTypeMap

A C<FedTypeMap> is a C<DHRelation>.  It lists the fully-qualified names of
0..N data types that are all considered to be copies and of the same 1
type, and should be treated interchangeably by the DBMS.  A C<FedTypeMap>
has 2 attributes, C<depot> (a C<Name>) and C<type> (a C<NameChain>); the
C<depot> is the declared name of the depot mount that the data type lives
in; the C<type> is the C<dep.>-qualified name of the data type living in
it.  Its default value has zero tuples.

=head1 TYPES FOR DEFINING DEPOTS AND SUBDEPOTS

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.Depot

A C<Depot> is a C<Database>.  It specifies the entire system
catalog of a single depot, that is, the widest scope within which all
entities must be fully defined in terms of just user-defined entities
within the same scope or of system-defined entities.  It also doubles to
specify the system catalog of a subdepot, which is an arbitrary subset of a
depot's entities that internally looks like a depot; a depot can have 0..N
subdepots, and any that exist are arranged in a hierarchy with the depot as
the root.  The system catalog variables named C<dep.cat>
and C<sdp.cat> are all of the C<Depot> type.

Directly within every namespace defined by a depot or subdepot,
the empty string entity declaration name is reserved for use by a material
that is a database type definition.  Iff said type exists, then it is the
declared data type of the self-local dbvar that this [|sub]depot
contains; if said type doesn't exist, then this [|sub]depot does
not have a self-local dbvar.

A C<Depot> has these 9 attributes:

=over

=item C<comment> - C<single_of.Comment>

This is an optional programmer comment about the [|sub]depot as a whole.

=item C<subdepots> - C<SubdepotSet>

These are all the subdepots that this system catalog contains (which might
be none).

=item C<functions|updaters|procedures> - C<[Func|Upd|Proc]Set>

These are all the definitions that this [|sub]depot contains of functions,
updaters, procedures.

=item C<[sca|nonsca|uni|restr]_types> - C<[Sca|Nonsca|Uni|Restr]TypeSet>

These are all the definitions that this [|sub]depot contains of scalar
types with possreps, complete nonscalar types, union types, and restriction
types.

=back

There is a distributed primary key over the C<name> attributes of all 8 of
a C<Depot>'s main C<DHRelation>-typed attributes.  Moreover, iff
any of those C<name> is the empty string, then the distributed primary key
also extends over all of the types and routines of that material,
I<except> the one with the empty string as its name.

The default value of C<Depot> defines an empty [|sub]depot
that does not have any self-local dbvar.

=head2 sys.std.Core.Type.Cat.SubdepotSet

A C<SubdepotSet> is a C<DHRelation> that specifies the set of subdepots
that a depot might optionally have for organizing its entities;
these subdepots are organized into a tree whose root is the depot.  A
C<SubdepotSet> only specifies that a subdepot exists, not which depot
entities it contains; see the C<Depot> which contains it for that.

A C<SubdepotSet> has these 3 attributes:

=over

=item C<parent> - C<DeclNameChain>

This is the fully-qualified name, in the C<dep.[cat|lib|data]> namespace,
of the subdepot's parent subdepot, which is often just the depot itself.

=item C<name> - C<Name>

This is the declared name of the subdepot within the namespace defined by
C<parent>; other Muldis D code would reference it with the combination of
C<parent> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about this specific subdepot as
associated with this subdepot name.

=back

A C<SubdepotSet> has a binary primary key on the C<parent> plus
C<name> attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.[Func|Upd|Proc]Set

An C<[Func|Upd|Proc]Set> is a C<DHRelation> that specifies a set of
functions|updaters|procedures that a [|sub]depot might directly contain;
each routine may be either public for the DBMS as a whole or private to the
subdepot.

An C<[Func|Upd|Proc]Set> has these 6 attributes:

=over

=item C<subdepot> - C<DeclNameChain>

This is the fully-qualified name, in the C<dep.[cat|lib|data]> namespace,
of the function|updater|procedure's parent [|sub]depot.

=item C<name> - C<Name>

This is the declared name of the function|updater|procedure within the
namespace defined by C<subdepot>; other Muldis D code would reference it
with the combination of C<subdepot> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about the function|updater|procedure
as a whole.

=item C<is_public> - C<Bool>

This is C<Bool:true> if the function|updater|procedure is part of the
subdepot's own public interface and may be invoked from outside the
subdepot; it is C<Bool:false> if it is just part of the subdepot's
internals.

=item C<head> - C<[Func|Upd|Proc]Head>

This defines the entire function|updater|procedure heading, that is its
public interface sans its name, which is all the details of how to use it
and no more detail than necessary about how it is implemented.

=item C<body> - C<[Func|Upd|Proc]Body>

This defines the entire function|updater|procedure body, that is its
implementation, besides what C<head> defines.

=back

An C<[Func|Upd|Proc]Set> has a binary primary key on the C<subdepot> plus
C<name> attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.[Sca|Nonsca|Uni|Restr]TypeSet

An C<[Sca|Nonsca|Uni|Restr]TypeSet> is a C<DHRelation> that specifies a set
of scalar|nonscalar|union|restriction types that a [|sub]depot might
directly contain; each type may be either public for the DBMS as a whole or
private to the subdepot.

An C<[Sca|Nonsca|Uni|Restr]TypeSet> has these 5 attributes:

=over

=item C<subdepot> - C<DeclNameChain>

This is the fully-qualified name, in the C<dep.[cat|lib|data]> namespace,
of the scalar|nonscalar|union|restriction type's parent [|sub]depot.

=item C<name> - C<Name>

This is the declared name of the scalar|nonscalar|union|restriction type
within the namespace defined by C<subdepot>; other Muldis D code would
reference it with the combination of C<subdepot> and C<name>.

=item C<comment> - C<Comment>

This is an optional programmer comment about the
scalar|nonscalar|union|restriction type as a whole.

=item C<is_public> - C<Bool>

This is C<Bool:true> if the scalar|nonscalar|union|restriction type is part
of the subdepot's own public interface and may be invoked from outside the
subdepot; it is C<Bool:false> if it is just part of the subdepot's
internals.

=item C<type> - C<[Scalar|Nonscalar|Union|Restr]Type>

This defines the entire scalar|nonscalar|union|restriction type sans
its name.

=back

An C<[Sca|Nonsca|Uni|Restr]TypeSet> has a binary primary key on the
C<subdepot> plus C<name> attributes.  Its default value is empty.

=head1 TYPES FOR DEFINING ROUTINES

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.FuncHead

A C<FuncHead> is a C<DHTuple>.  It specifies the entire heading or public
interface of a function or function, except for its name and
public/private status; the latter are provided by any type embedding this
one when applicable.

A C<FuncHead> has these 4 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the function heading.

=item C<result_type> - C<NameChain>

This is the declared result data type of the function as a whole.

=item C<params> - C<NameTypeMap>

This is the declared parameter list of the function, which has 0..N named
and typed parameters.

=item C<opt_params> - C<set_of.Name>

This indicates the subset of the function's parameters that are optional,
that is, do not need to be supplied explicit arguments when the function is
invoked; any function parameters not named here must be supplied explicit
arguments.  Any parameter marked as optional which is not given an explicit
argument will implicitly default to the default value of its declared type.
Each element of C<opt_params> must match a parameter name in C<params>.

=back

The default value of C<FuncHead> has zero parameters and a result type
of C<Bool>; by default, its parameters are all non-optional.

=head2 sys.std.Core.Type.Cat.FuncBody

An C<FuncBody> is a C<DHTuple>.  It specifies the entire body or
implementation of an function (or the main body of a function),
besides the details that a C<FuncHead> has, one of which each
C<FuncBody> typically must be paired with.

An C<FuncBody> has these 2 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the function body.

=item C<expr> - C<ExprNodeSet>

This defines the value expression tree that comprises the entire
function body.

=back

There is a distributed primary key over the C<name> attributes of all the
attributes of C<expr>; and if this C<FuncBody> is paired with a
C<FuncHead>, then the distributed key also extends over the head's
parameter names.

An C<FuncBody> specifies a simple value expression tree of named
expression nodes, each of which is a tuple of one of its C<expr.\w+_exprs>
attributes.  It must have at least 1 member node, except that it may have
zero member nodes iff the function it is composed into has exactly
1 parameter, in which case the value expression tree implicitly results in
the argument to said parameter.  Otherwise:  All member nodes must define a
simple expression node tree, such that every member except one (which is
the root node) has one of its peers as a parent node, and no direct cycles
between members are permitted (only indirect cycles based on
function invocations are allowed); the name of the root node must be the
empty string.  Note that the composed-into function's parameters
are also implicitly tree nodes, and are referenced by name into the
expression the same way as any other named expression node is.  Regardless
of whether the node count is zero or 1+, the tree must denote a value
expression whose result type is of the result type of the function
it is composed into, and which invokes all of the function's parameters.

The default value of C<FuncBody> directly corresponds to the
default value of C<FuncHead> and unconditionally results in the value
C<Bool:false>.

=head2 sys.std.Core.Type.Cat.ExprNodeSet

An C<ExprNodeSet> is a C<Database> that specifies a set of named value
expression nodes.  It is typically composed into a
[function|updater].  Each tuple of an C<ExprNodeSet> attribute is a
named expression node, which is the majority component of functional Muldis
D code.  All arbitrarily complex Muldis D expression trees, including
relational queries, are composed of just expression nodes, either directly,
or indirectly by way of function invocations, as each
function body is itself composed entirely of a single expression tree (of
at least 1 node).  Only functions and updaters may contain expression
nodes, so for any procedures that would conceptually include them, those
portions of the procedures need to be separated out and encapsulated by
named functions or updaters.  Note that, while the
general case has expression trees simply denoting a value, in some cases
they may instead define a pseudo-variable / virtual variable; that only
happens in updaters where the expression is used as an argument
for a subject-to-update parameter of an update operator call; in
that case the leaf nodes / only node of the expression must map to a
subject-to-update parameter of the containing update operator.

An C<ExprNodeSet> has these 12 attributes:

=over

=item C<sca_val_exprs> - C<ScaValExprNodeSet>

These are expression nodes that represent scalar values of types such that
the Muldis D dialect provides special literal syntax specific to the type.

=item C<sca_pr_sel_exprs> - C<ScaPRSelExprNodeSet>

These are expression nodes that represent generic scalar value
selections specified simply in terms of possrep attributes.

=item C<tup_sel_exprs> - C<TupSelExprNodeSet>

These are expression nodes that represent tuple value selections.

=item C<rel_sel_exprs> - C<RelSelExprNodeSet>

These are expression nodes that represent generic relation value
selections.

=item C<set_sel_exprs> - C<SetSelExprNodeSet>

These are expression nodes that represent set value selections.

=item C<ary_sel_exprs> - C<ArySelExprNodeSet>

These are expression nodes that represent array value selections.

=item C<bag_sel_exprs> - C<BagSelExprNodeSet>

These are expression nodes that represent bag value selections.

=item C<acc_exprs> - C<AccExprNodeSet>

These are expression nodes that represent accessors of attributes of other,
tuple-valued expression nodes, or aliases of other expression nodes.

=item C<func_invo_exprs> - C<FuncInvoExprNodeSet>

These are expression nodes that represent function invocations.

=item C<if_else_exprs> - C<IfElseExprNodeSet>

These are expression nodes that represent if-else control flow expressions.

=item C<given_when_def_exprs> - C<GivenWhenDefExprNodeSet>

These are expression nodes that represent given-when-default control flow
expressions.

=item C<material_ref_sel_exprs> - C<MaterialRefSelExprNodeSet>

These are expression nodes that define routine or type reference literals.

=back

There is a distributed primary key over the C<name> attributes of all of an
C<ExprNodeSet>'s attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.ScaValExprNodeSet

A C<ScaValExprNodeSet> is a C<DHRelation> that specifies a set of value
expression nodes where each node is a hard-coded scalar literal of one of a
certain collection of system-defined core scalar types that special value
literal syntax exists for (or subtype thereof).

A C<ScaValExprNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about the expression (leaf) node.

=item C<value> - C<DHScalar>

This is the actual scalar value that the expression node represents.
I<That is, any DHScalar value could be used here, but in practice that is
either dialect-defined (what literals are supported), and possibly
implementation defined/limited.>

=back

A C<ScaValExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.ScaPRSelExprNodeSet

A C<ScaPRSelExprNodeSet> is a C<DHRelation> that specifies a set of value
expression nodes where each node represents a scalar value
selection that is specified simply in terms of possrep attributes.

A C<ScaPRSelExprNodeSet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<type_name> - C<NameChain>

This is the name of the type that the scalar value belongs to.

=item C<possrep_name> - C<Name>

This is the name of the possrep, of the type named by C<type_name>, in
terms of whose attributes the scalar value is being selected.

=item C<possrep_attrs> - C<NameExprMap>

These represent the attributes (names and values) of the C<possrep_name>
possrep of the scalar value being selected.

=back

A C<ScaPRSelExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.TupSelExprNodeSet

A C<TupSelExprNodeSet> is a C<DHRelation> that specifies a set of value
expression nodes where each node represents a tuple value selection.

A C<TupSelExprNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<attrs> - C<NameExprMap>

These represent the attributes (names and values) of the tuple
value being selected.

=back

A C<TupSelExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.RelSelExprNodeSet

A C<RelSelExprNodeSet> is a C<DHRelation> that specifies a set of value
expression nodes where each node represents a relation value selection.

A C<RelSelExprNodeSet> has these 4 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<head> - C<set_of.Name>

These are the names of all of this relation value's attributes.

=item C<body> - C<set_of.NameExprMap>

These represent the tuples of the relation value being
selected.  When this value expression is evaluated, if any child expression
nodes are such that any duplicate tuples might be input to this
C<RelSelExprNodeSet> selector, the duplicates are silently eliminated and
do not constitute a failure condition.

=back

A C<RelSelExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.SetSelExprNodeSet

A C<SetSelExprNodeSet> is a C<DHRelation> that specifies a set of value
expression nodes where each node represents a set value selection.

A C<SetSelExprNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<elems> - C<set_of.Name>

These represent the elements of the set value being selected.
When this value expression is evaluated, if any child expression nodes are
such that any duplicate tuples might be input to this C<SetSelExprNodeSet>
selector, the duplicates are silently eliminated and do not constitute a
failure condition.

=back

A C<SetSelExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.ArySelExprNodeSet

An C<ArySelExprNodeSet> is a C<DHRelation> that specifies a set of value
expression nodes where each node represents a array value selection.

An C<ArySelExprNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<elems> - C<array_of.Name>

These represent the elements of the array value being selected.

=back

An C<ArySelExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.BagSelExprNodeSet

A C<BagSelExprNodeSet> is a C<DHRelation> that specifies a set of value
expression nodes where each node represents a bag value selection.

A C<BagSelExprNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<elems> - C<bag_of.Name>

These represent the elements of the bag value being selected.
When this value expression is evaluated, if any child expression nodes are
such that any tuple pairs with duplicate C<value> attribute values might be
input to this C<BagSelExprNodeSet> selector, the tuple pairs are silently
merged as per the semantics of bag union; the replacement tuple for such a
pair has a C<count> attribute that is the sum of that attribute of each of
the originals in said pair; any duplicate C<value> do not constitute a
failure condition.

Note that, because of how C<BagSelExprNodeSet> is defined, the C<count>
attribute value of each C<elems> tuple is a compile time constant, since an
integer is stored in the system catalog rather than the name of an
expression node like with C<value>; if you actually want the bag value
being selected at runtime to have runtime-determined C<count> values, then
you must use a C<RelSelExprNodeSet> rather than a C<BagSelExprNodeSet>.

=back

A C<BagSelExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.AccExprNodeSet

An C<AccExprNodeSet> is a C<DHRelation> that specifies a set of value
expression nodes where each node is an accessor or alias for an attribute
of another, tuple-valued expression node, or is simply an alias for another
expression node, defined in terms of a C<NameChain> in the C<lex> top-level
namespace.

A C<AccExprNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about the expression (leaf) node.

=item C<target> - C<NameChain>

This is the fully-qualified invocation name of the expression node, or
attribute thereof if it is tuple-valued, being accessed or aliased.

=back

A C<AccExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.FuncInvoExprNodeSet

A C<FuncInvoExprNodeSet> is a C<DHRelation> that specifies a set of value
expression nodes where each node represents the result of invoking a named
function with specific arguments.

A C<FuncInvoExprNodeSet> has these 4 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<function> - C<NameChain>

This is the name of the function being invoked.

=item C<args> - C<NameExprMap>

These are the arguments for the function invocation.  Each element
defines one argument value, with the element C<name> matching the invoked
function's parameter name, and the element C<expr> naming another
local expression node which defines the value.

=back

A C<FuncInvoExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.IfElseExprNodeSet

An C<IfElseExprNodeSet> is a C<DHRelation> that specifies a set of value
expression nodes where each node represents an N-way if-else control flow
expression.

The reason that the C<IfElseExprNodeSet> expression node kind exists,
rather than this functionality being provided by an ordinary function
invocation, is because the semantics of an if-else expression require its
sub-expressions to be evaluated in a specific sequence and that later
elements in the sequence are evaluated only conditionally based on the
results of earlier elements in the sequence, whereas with ordinary
functions the operands are all independent of each other, can be done in
any order, and can all be evaluated prior to the function.  The main
scenario that requires the special semantics is when an earlier conditional
part of the sequence is testing whether it is even logically possible to
evaluate a later part of the sequence; for example, the first condition may
test if a value is a member of a certain data type, and a later part of the
sequence may want to use some operator on the value that is only defined
for the certain data type (invoking it on something else would result in a
failure/exception); so only known-safe/appropriate expressions then get
evaluated.

An C<IfElseExprNodeSet> has these 4 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<if_then> - C<array_of.IfThenExprMap>

This is a sequence of 0..N conditional expressions, each of which has an
associated result expression.  Each conditional expression will evaluate in
order while the previous conditional resulted in C<Bool:false>; once a
conditional results in C<Bool:true>, its associated result expression will
evaluate and be the result of the larger if-else sequence, and no more
conditionals will be evaluated; no result expressions will be evaluated
except the one with the true conditional.

=item C<else> - C<Name>

Iff none of the conditionals in C<if_then> result in C<Bool:true> (or as a
trivial case, if C<if_then> is an empty sequence), then the result
expression represented by the local expression node (or parameter) named by
C<else> will be evaluated, and be the result of the larger if-else.

=back

An C<IfElseExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.IfThenExprMap

An C<IfThenExprMap> is a C<DHTuple>.  It defines an element of an if-else
sequential expression.  An C<IfThenExprMap> has 2 attributes, C<if> and
C<then>, each of which is a C<Name>; C<if> has the name of a local
expression node (or parameter), and C<then> has likewise.  The C<if> node
is the condition to evaluate; if that condition evaluates to C<Bool:true>,
then the C<then> node is evaluated and its result is the result of the
whole if-else expression; otherwise, C<then> is not evaluated.  Its default
value has the default value of the C<Name> type in both attributes.

=head2 sys.std.Core.Type.Cat.GivenWhenDefExprNodeSet

A C<GivenWhenDefExprNodeSet> is a C<DHRelation> that specifies a set of
value expression nodes where each node represents an N-way
given-when-default switch control flow expression that dispatches based
on matching a single value with several options.

A C<GivenWhenDefExprNodeSet> is essentially a more specialized version
of an C<IfElseExprNodeSet> where every condition expression is a simple
value equality test and one of the operands is the same for all the
conditions in the set; also, with a given-when-default it doesn't matter
what order the conditionals are tested to find a true resulting one.

A C<GivenWhenDefExprNodeSet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=item C<given> - C<Name>

This is the single operand value that is common to all the conditions; it
is the control value for the expression.

=item C<when_then> - C<WhenThenExprMap>

This is a set of distinct condition operand values, each of which has an
associated result expression.  If a condition operand matches the value of
C<given>, its associated result expression will evaluate and be the result
of the larger if-else sequence; no result expressions will be evaluated
except the one with the matching conditional operand.

=item C<default> - C<Name>

Iff none of the condition operand values in C<when_then> matches the value
of C<given> (or as a trivial case, if C<when_then> has no tuples), then the
result expression represented by the local expression node (or parameter)
named by C<default> will be evaluated, and be the result of the larger
given-when-default.

=back

A C<GivenWhenDefExprNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.WhenThenExprMap

A C<WhenThenExprMap> is a C<DHRelation>.  It defines a set of dispatch
options for a given-when-default expression.  A C<WhenThenExprMap> has 2
attributes, C<when> and C<then>, each of which is a C<Name>; C<when> has
the name of a local expression node (or parameter), and C<then> has
likewise.  The C<when> node is the not-common / distinct operand for each
condition.  If a C<when> value is matched, then the C<then> node is
evaluated and its result is the result of the whole g-w-d expression;
otherwise, C<then> is not evaluated.  Its default value has zero tuples.

=head2 sys.std.Core.Type.Cat.MaterialRefSelExprNodeSet

A C<MaterialRefSelExprNodeSet> is a C<DHRelation> that specifies a set of
expression nodes where each node represents a value of the special
C<sys.std.Core.Type.Cat.MaterialRef> type.  None of the represented values
have any pre-bound routine parameters where applicable, and those can be
added afterwards with the system-defined currying routines.

A C<MaterialRefSelExprNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the expression node.

=item C<comment> - C<Comment>

This is an optional programmer comment about the expression leaf node.

=item C<referencing> - C<NameChain>

This is the name, from the point of view of the routine embedding this
expression node, of the routine or type that the new special reference
value is supposed to facilitate portable invoking of.

=back

A C<MaterialRefSelExprNodeSet> has a unary (unique) key on the C<name>
attribute, plus another such key on the C<referencing> attribute.  Its
default value is empty.

=head2 sys.std.Core.Type.Cat.UpdHead

An C<UpdHead> is a C<DHTuple>.  It specifies the entire heading or public
interface of an updater or updater, except for its name and
public/private status; the latter are provided by any type embedding this
one when applicable.

An C<UpdHead> has these 4 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the updater heading.

=item C<upd_params> - C<NameTypeMap>

This is the declared subject-to-update parameter list of the updater, which
has 1..N named and typed such parameters.  It must have at least 1 element.

=item C<ro_params> - C<NameTypeMap>

This is the declared read-only parameter list of the updater, which has
0..N named and typed such parameters.

=item C<opt_params> - C<set_of.Name>

This indicates the subset of the updater's subject-to-update or read-only
parameters that are optional, that is, do not need to be supplied explicit
arguments when the function is invoked; any updater parameters not named
here must be supplied explicit arguments.  Any parameter marked as optional
which is not given an explicit argument will implicitly default to the
default value of its declared type; any subject-to-update parameter marked
as optional which is not given an explicit argument will implicitly bind to
a new anonymous variable (with the aforementioned default value) which is
discarded after the updater finishes executing.  Each element of
C<opt_params> must match a parameter name in either C<upd_params> or
C<ro_params>.

=back

There is a distributed primary key over the C<name> attributes of
C<upd_params> and C<ro_params>.

The default value of C<UpdHead> has 1 subject-to-update parameter whose
name is C<topic> and whose declared type is C<Bool>; it has zero read-only
parameters; by default, its parameters are all non-optional.

=head2 sys.std.Core.Type.Cat.UpdBody

An C<UpdBody> is a C<DHTuple>.  It specifies the entire body or
implementation of an updater (or the main body of a updater), besides
the details that an C<UpdHead> has, one of which each
C<UpdBody> typically must be paired with.

An C<UpdBody> has these 3 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the updater body.

=item C<exprs> - C<ExprNodeSet>

This defines the expression trees that are arguments to the update
operators that C<stmt> invokes.  These expression trees must reference all
of the read-only parameters that the update operator has.

=item C<stmt> - C<MultiUpdStmt>

This defines the entire body of the updater, which is composed of
a single multi-update statement.  This multi-update statement must
reference all of the parameters that the updater has.

=back

There is a distributed primary key over the C<name> attributes of all the
attributes of C<exprs>; and if this C<UpdBody> is paired with an
C<UpdHead>, then the distributed key also extends over the head's
parameter names.

The default value of C<UpdBody> directly corresponds to the
default value of C<UpdHead> and unconditionally updates its C<topic>
argument to the value C<Bool:false>.

=head2 sys.std.Core.Type.Cat.MultiUpdStmt

A C<MultiUpdStmt> is a C<DHRelation> that specifies a multi-update
statement (of 1..N variables), which is the narrowest scope implicitly
atomic component of procedural Muldis D code.  It is the most fundamental
component of procedural Muldis D code.  The variables being updated are
accessed via the host updater's subject-to-update parameters.  All
arbitrarily complex Muldis D value assignments, including relational
assignments, are composed of just C<MultiUpdStmt>, either directly, or
indirectly by way of updater invocations, as each updater
body is itself composed entirely of 1 multi-update statement (plus
supporting value expressions).  Only updaters may contain
C<MultiUpdStmt>, so for any procedures that would conceptually include
them, those portions of the procedures need to be separated out and
encapsulated by named updaters.  Each tuple of a multi-update
statement is a single update statement, which represents a single
invocation of an updater, and at least 1 tuple is required.

A C<MultiUpdStmt> has these 4 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the single update statement as
a whole.

=item C<updater> - C<NameChain>

This is the name of the updater being invoked.

=item C<upd_args> - C<NameExprMap>

These are the 1..N subject-to-update arguments to the updater
invocation, as-per C<ro_args>.  But since each expression tree in
C<upd_args> is binding to a subject-to-update parameter, the expression
tree actually is defining a pseudo-variable / virtual-variable over 1..N
containing routine subject-to-update parameters; in the most trivial (and
common) case, the parameter is referenced directly.

=item C<ro_args> - C<NameExprMap>

These are the 0..N read-only arguments to the updater invocation.
Each element defines one argument value, with the element C<name> matching
the invoked routine's parameter name, and the element C<expr> naming a
local expression node (or parameter) which defines the value.

=back

There is a distributed primary key over the C<name> attributes of
C<upd_args> and C<ro_args>.

The default value of C<MultiUpdStmt> directly corresponds to the
default value of C<UpdBody> and unconditionally updates its
containing updater's C<topic> argument to the value C<Bool:false>.

=head2 sys.std.Core.Type.Cat.ProcHead

A C<ProcHead> is a C<DHTuple>.  It specifies the entire heading or public
interface of a procedure or procedure, except for its name and
public/private status; the latter are provided by any type embedding this
one when applicable.

A C<ProcHead> has these 4 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the procedure heading.

=item C<upd_params> - C<NameTypeMap>

This is the declared subject-to-update parameter list of the procedure,
which has 0..N named and typed such parameters.

=item C<ro_params> - C<NameTypeMap>

This is the declared read-only parameter list of the procedure, which has
0..N named and typed such parameters.

=item C<opt_params> - C<set_of.Name>

This is as per the same-named attribute of C<UpdHead>.

=back

There is a distributed primary key over the C<name> attributes of
C<upd_params> and C<ro_params>.

The default value of C<ProcHead> has zero parameters; by default, its
parameters are all non-optional.

=head2 sys.std.Core.Type.Cat.ProcBody

An C<ProcBody> is a C<DHTuple>.  It specifies the entire body or
implementation of an procedure (or the main body of a procedure),
besides the details that a C<ProcHead> has, one of which each
C<ProcBody> typically must be paired with.

An C<ProcBody> has these 3 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the procedure body.

=item C<vars> - C<NameTypeMap>

This defines the 0..N (non-parameter) lexical variables of the
procedure; they initialize to the default values of their declared types.

=item C<stmt> - C<StmtNodeSet>

This defines the statement tree that comprises the entire procedure body.

=back

There is a distributed primary key over the C<name> attribute of C<vars>
and the C<name> attributes of all the attributes of C<stmt>; and if this
C<ProcBody> is paired with a C<ProcHead>, then the distributed
key also extends over the head's parameter names.

An C<ProcBody> specifies a simple statement tree of named statement
nodes, each of which is a tuple of one of its C<stmt.\w+_stmts> attributes.
If it has zero member nodes, then the procedure is a no-op.
Otherwise:  All member nodes must define a simple statement node tree, such
that every member except one (which is the root node) has one of its peers
as a parent node, and no direct cycles between members are permitted (only
indirect cycles based on procedure invocations are allowed); the
name of the root node must be the empty string.  Note that the
composed-into procedure's parameters are also implicitly tree
nodes, and are referenced by name into the statement tree the same way as
any other named statement node is.  The statement tree should reference all
of the parameters and lexical variables that the procedure has,
but this isn't a strict requirement.

The default value of C<ProcBody> directly corresponds to the default
value of C<ProcHead> and is a no-op, having an empty statement tree.

=head2 sys.std.Core.Type.Cat.StmtNodeSet

A C<StmtNodeSet> is a C<Database> that specifies a set of named
statement nodes.  It is typically composed into a procedure.  Each
tuple of a C<StmtNodeSet> attribute is a named statement node, from
which non-implicitly-atomic procedural Muldis D code is composed.

Note that, regarding Muldis D's feature of a statement node having an
explicit C<name> that can be referenced by "leave" and "iterate" control
flow statements to leave or re-iterate the corresponding block, both SQL
and Perl have native counterpart features in the form of block labels.

A C<StmtNodeSet> has these 7 attributes:

=over

=item C<leave_stmts> - C<LeaveStmtNodeSet>

These are statement nodes that represent abnormal block exit statements.

=item C<compound_stmts> - C<CompoundStmtNodeSet>

These are statement nodes that each represent a compound statement having a
sequence of 0..N procedure statements.

=item C<imp_invo_stmts> - C<ImpInvoStmtNodeSet>

These are statement nodes that represent imperative routine invocations.

=item C<if_else_stmts> - C<IfElseStmtNodeSet>

These are statement nodes that represent if-else control flow statements.

=item C<given_when_def_stmts> - C<GivenWhenDefStmtNodeSet>

These are statement nodes that represent given-when-default control flow
statements.

=item C<iterate_stmts> - C<IterateStmtNodeSet>

These are statement nodes that represent abnormal block restart statements.

=item C<loop_stmts> - C<LoopStmtNodeSet>

These are statement nodes that represent generic looping block statements.

=back

There is a distributed primary key over the C<name> attributes of all of a
C<StmtNodeSet>'s attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.LeaveStmtNodeSet

A C<LeaveStmtNodeSet> is a C<DHRelation> that specifies a set of
statement leaf nodes where each node represents an instruction to
abnormally exit the block defined by a parent statement node (a normal exit
is to simply execute to the end of the block).  If the parent node in
question is the root statement node for the containing procedure,
then the latter will be exited; this is how a "return" statement is
represented, but "return" is still easy to recognize because the root node
always has the empty string as its name.  If the parent node in question is
an iterating or looping statement, then any remaining iterations it might
have had are skipped, especially useful if it was an infinite loop.

A C<LeaveStmtNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about the statement leaf node.

=item C<leave> - C<Name>

This is the name of the parent statement node we wish to abnormally exit;
note that this reference does not count as making the other node a child of
the current one, so this reference does not contribute to a cycle.

=back

A C<LeaveStmtNodeSet> has a unary primary key on the C<name> attribute,
plus a unary (unique) key on the C<leave> attribute.  Its default value is
empty.

=head2 sys.std.Core.Type.Cat.CompoundStmtNodeSet

A C<CompoundStmtNodeSet> is a C<DHRelation> that specifies a set of
statement nodes where each node is a compound statement composed of a
sequence of 0..N other statements.

A C<CompoundStmtNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the statement node or
the statement node (sub-)tree it is the root of.

=item C<stmts> - C<array_of.Name>

This is a sequence of names of 0..N other local statement nodes; the
current compound statement consists of having those other statements
execute in this given sequence.

=back

A C<CompoundStmtNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.ImpInvoStmtNodeSet

An C<ImpInvoStmtNodeSet> is a C<DHRelation> that specifies a set of
statement nodes where each node is an invocation of some other imperative
routine (eg, procedure, update operator, system service)
with specific arguments.  The invoked routine can be either user-defined or
system-defined.

An C<ImpInvoStmtNodeSet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the statement node or
the statement node (sub-)tree it is the root of.

=item C<imperative> - C<NameChain>

This is the name of the imperative routine being invoked.

=item C<upd_args> - C<IISArgVarMap>

These are the 0..N subject-to-update arguments to the routine invocation,
as-per C<ro_args>.

=item C<ro_args> - C<IISArgVarMap>

These are the 0..N read-only arguments to the routine invocation.  Each
element defines one argument value, with the element C<name> matching the
invoked routine's parameter name, and the element C<expr> naming a local or
global variable or statement-containing routine parameter which defines the
value.

=back

An C<ImpInvoStmtNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.  There is a distributed primary
key over the C<name> attributes of C<upd_args> and C<ro_args>.

=head2 sys.std.Core.Type.Cat.IISArgVarMap

An C<IISArgVarMap> is a C<DHRelation>.  It defines a set of argument names,
with a declared local or global variable (or parameter or pseudo-variable)
name for each.  It is used to define argument lists for routine invocations
by procedures.  An C<IISArgVarMap> has 2 attributes, C<arg> (a C<Name>) and
C<var> (a C<NameChain>); the C<arg> is the name of the routine argument,
and comprises a unary key; the C<var> is the invocation name of the
variable (or parameter or pseudo-variable) which defines the value for the
argument.  Its default value has zero tuples.

=head2 sys.std.Core.Type.Cat.IfElseStmtNodeSet

An C<IfElseStmtNodeSet> is a C<DHRelation> that specifies a set of
statement nodes where each node represents an N-way if-else control flow
statement.  An C<IfElseStmtNodeSet> is essentially the imperative
version of the functional C<IfElseExprNodeSet>, except that for design
simplicity, all of the conditionals need to be pre-evaluated and their
boolean results stored in variables (but this could be a lazy though still
necessarily deterministic operation, so work isn't actually done if the
results aren't needed); if any conditionals could only be conditionally
evaluated, then the necessary logic means this if-else statement must be
broken up into multiple nested if-else.

An C<IfElseStmtNodeSet> has these 4 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the statement node or
the statement node (sub-)tree it is the root of.

=item C<if_then> - C<array_of.IfThenVarStmtMap>

This is a sequence of 0..N conditional result variable names, each of which
has an associated statement.  Each conditional result will be tested in
order while the previous conditional result is C<Bool:false>; once a
conditional result is C<Bool:true>, its associated statement will be
invoked; no statements will be invoked except the one with the true
conditional result.

=item C<else> - C<maybe_of.Name>

Iff none of the conditional results in C<if_then> is C<Bool:true> (or as a
trivial case, if C<if_then> is an empty sequence), then the statement
represented by the local statement node named by C<else> will be invoked
iff C<else> is a C<Single>; if under the first circumstance C<else> is
C<nothing>, then the whole if-else will have been a no-op.

=back

An C<IfElseStmtNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.IfThenVarStmtMap

An C<IfThenVarStmtMap> is a C<DHTuple>.  It defines an element of an
if-else sequential statement.  An C<IfThenVarStmtMap> has 2 attributes,
C<if> (a C<NameChain>) and C<then> (a C<Name>); C<if> has the name of a
local or global variable (or parameter), and C<then> has the name of a
statement node.  The C<if> node is the conditional result variable name; if
that conditional result is C<Bool:true>, then the C<then> statement node is
invoked; otherwise, C<then> is not invoked.  Its default value has the
default value where each attribute is the default of its declared type.

=head2 sys.std.Core.Type.Cat.GivenWhenDefStmtNodeSet

A C<GivenWhenDefStmtNodeSet> is a C<DHRelation> that specifies a set of
statement nodes where each node represents an N-way given-when-default
switch control flow statement that dispatches based on matching a single
value with several options.  A C<GivenWhenDefStmtNodeSet> is essentially
the imperative version of the functional C<GivenWhenDefExprNodeSet>.

A C<GivenWhenDefStmtNodeSet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the statement node or
the statement node (sub-)tree it is the root of.

=item C<given> - C<NameChain>

This is name of the local parameter or variable that supplies the single
operand value that is common to all the conditions; it is the control value
for the statement.

=item C<when_then> - C<WhenThenVarStmtMap>

This is a set of distinct condition operand values, each of which has an
associated statement.  If a condition operand matches the value of
C<given>, its associated statement will be invoked; no statements will be
invoked except the one with the matching conditional operand.

=item C<default> - C<maybe_of.Name>

Iff none of the condition operand values in C<when_then> matches the value
of C<given> (or as a trivial case, if C<when_then> has no tuples), then the
statement represented by the local statement node named by C<default> will
be invoked iff C<default> is a C<Single>; if under the first circumstance
C<default> is C<nothing>, then the whole given-when-default will have
been a no-op.

=back

A C<GivenWhenDefStmtNodeSet> has a unary primary key on the C<name>
attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.WhenThenVarStmtMap

A C<WhenThenVarStmtMap> is a C<DHRelation>.  It defines a set of dispatch
options for a given-when-default statement.  A C<WhenThenVarStmtMap> has 2
attributes, C<when> (a C<NameChain>) and C<then> (a C<Name>); C<when> has
the name of a local or global variable (or parameter), and C<then> has the
name of a statement node.  The C<when> node is the not-common / distinct
operand for each condition.  If a C<when> value is matched, then the
C<then> statement node is invoked; otherwise, C<then> is not invoked.  Its
default value has zero tuples.

=head2 sys.std.Core.Type.Cat.IterateStmtNodeSet

An C<IterateStmtNodeSet> is a C<DHRelation> that specifies a set of
statement leaf nodes where each node represents an instruction to
abnormally end the current iteration of a looping block defined by a parent
statement node, and then start at the beginning of the next iteration of
that loop if there are any left ("normal" is to simply execute to the end
of the block before starting the next iteration).  The same semantics apply
for the beginning of the next loop as if the current block iteration had
executed to the end before repeating.

An C<IterateStmtNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about the statement leaf node.

=item C<iterate> - C<Name>

This is the name of the parent statement node we wish to abnormally exit
and restart; note that this reference does not count as making the other
node a child of the current one, so this reference does not contribute to a
cycle.

=back

An C<IterateStmtNodeSet> has a unary primary key on the C<name>
attribute, plus a unary (unique) key on the C<iterate> attribute.  Its
default value is empty.

=head2 sys.std.Core.Type.Cat.LoopStmtNodeSet

A C<LoopStmtNodeSet> is a C<DHRelation> that specifies a set of statement
nodes where each node represents a generic looping statement block which
iterates until a child "leave" statement executes.

A C<LoopStmtNodeSet> has these 3 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the statement node.

=item C<comment> - C<Comment>

This is an optional programmer comment about either the statement node or
the statement node (sub-)tree it is the root of.

=item C<do> - C<Name>

This is the name of the local statement node that will get executed for
each iteration of the loop; typically it has a sub-tree of statement nodes.

=back

A C<LoopStmtNodeSet> has a unary primary key on the C<name> attribute.
Its default value is empty.

=head1 TYPES FOR DEFINING DATA TYPES

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.ScalarType

An C<ScalarType> is a C<DHTuple>.  It defines either a new
scalar root type with at least 1 possrep, or it defines a subtype
of some other scalar type which also adds at least one possrep to
the other type.  Either way, every possrep defines a candidate
representation that can handle every value of the [|sub]type it is defined
with, and the Muldis D implementation may choose for itself which of these,
or some other alternative, is the actual/physical representation.  Whether
a declared type is scalar or dh-scalar depends only on the declared
types of the attributes its possreps compose, whether any are
non-deeply-homogeneous
or none are.  You can not declare a scalar root type at all except
by using a C<ScalarType>, and you can not define a scalar type
with an incompletely defined attribute list at all.

An C<ScalarType> has these 7 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the scalar
[|sub]type as a whole.

=item C<base_type> - C<maybe_of.NameChain>

Iff the type being defined is a scalar root type, then
C<base_type> is not applicable and is C<nothing>.  Iff the type being
defined is a subtype of some other scalar type, then C<base_type>
is a C<Single> whose sole element is the name of that other type.  Note
that any type named by C<base_type> must itself be a scalar root
type or a subtype of one.

=item C<subtype_constraint> - C<maybe_of.NameChain>

Iff the type being defined is a scalar root type, or it is a
non-proper subtype of some other type, then C<subtype_constraint> is not
applicable and is C<nothing>.  Iff the type being defined is a proper
subtype of some other scalar type, then C<subtype_constraint> is a
C<Single> whose sole element matches the declared name of an
C<type_constraint> function that determines what base type values are part
of the subtype.  The function that this names must have a
single C<topic> parameter whose declared type is that named by
C<base_type>, and whose argument is the value to test; the function's
result type must be C<Bool>.  This constraint function may only
reference possreps of the base type, and may not reference possreps of the
type being defined.  Note that, strictly speaking, C<subtype_constraint>
may actually be less restrictive than the total constraint of the subtype
as a whole, because the total constraint is defined by I<and>-ing the
constraints of the base types and the C<subtype_constraint> and the
constraints of all the possreps of the subtype; therefore, mainly the
C<subtype_constraint> needs to be just restricting enough so that the
inter-possrep mapping functions can handle the base type values that it
accepts, so it is possible to apply the new possreps' constraints.  Now if
C<subtype_constraint> were otherwise so simple as to unconditinally result
in C<Bool:true>, then simply making it C<nothing> has the same effect.

=item C<possreps> - C<PossrepSet>

These are the 1..N possrep definitions that comprise this type such that
each one fully defines a set of attributes plus restrictions on their
collective values whereby it defines a representation of all values of this
type.  Note that if multiple scalar types are related to each
other such that more than one declares possreps for at least one common
value, then the C<name> attribute of the C<possreps> attributes of all of
those types' definitions have a distributed primary key over them.  Note
that, to keep things simple and deterministic under the possibility of
diamond subtype/supertype relationships (such that the generic
system-defined scalar possrep attribute accessors can work), Muldis D
requires all of the possreps of all scalar types having a common scalar
root type to have mutually distinct names, regardless of whether any
subtypes have values in common; this can be enforced at
type-definition-in-catalog time since all types that can interact are in
the same depot.

=item C<possrep_maps> - C<PossrepMapSet>

When this type has more than one possrep applicable to all of its values,
these are the definitions of mapping functions for deriving the
representation of a value in one possrep directly from the representation
in another possrep, and also directly in the reverse.  Every one of this
type's possreps must be mapped bidirectionally to every other one of its
possreps, either directly or indirectly.  So for C<P> total possreps, the
total number of bidirectional maps C<M> is in C<(P-1)  M  ((P-1)*P/2)>.
When a subtype is adding possreps to an other base type, all of the mapping
functions are defined with the subtype.

=item C<default> - C<maybe_of.NameChain>

Iff it is a C<Single>, then C<default>
matches the declared name of an C<named_value> function that
results in the default scalar value of the [|sub]type; it has
zero parameters and its result type is the same as the scalar type
whose declaration it is part of.  Iff C<default> is C<nothing> and
C<base_type> is C<nothing>, then semantics are as if it were a defined name
that resulted in a value of the type being defined where all of the possrep
attr values were the default values of their declared types; but if the
type being defined has multiple possreps and going the by-attr-defaults
route with all of the possreps doesn't produce the same value of the type
being defined, then a C<default> of C<nothing> is invalid and it must be a
C<Single>.  Iff C<default> is C<nothing> and C<base_type> is a C<Single>,
then the subtype will use the same default value as its base type; but if
the subtype's value set excludes said value, then a C<default> of
C<nothing> is invalid and C<default> must be a C<Single>.

=item C<order> - C<maybe_of.NameChain>

A scalar root type definition may optionally have a type-default
total ordering function associated with it (a type being defined as a
subtype may not); iff the type being defined qualifies and desires such an
associated function, then C<order> is a C<Single> whose sole element
matches the declared name of an C<order_determination> function.  The
function that this names must have exactly 4 parameters; the
first two parameters, named C<topic> and C<other>, each have declared types
that are the same as the scalar root type whose declaration the
function is part of, and this function is said root type's type-default
ordering function; the third parameter, named C<misc_args>, is
C<Tuple>-typed; the fourth parameter, named C<is_reverse_order>, is
C<Bool>-typed; the function's result type must be C<Order>.  Iff
the type being defined is a subtype of some other type or does not desire
the function, then C<order> is C<nothing>.

=back

The default value of C<ScalarType> defines a scalar root type with
a single possrep whose name is the empty string and that has no attributes;
it is a singleton type, whose default value is its only value.

=head2 sys.std.Core.Type.Cat.PossrepSet

A C<PossrepSet> is a C<DHRelation> that specifies a set of possreps that
a scalar [|sub]type might consist primarily of.

A C<PossrepSet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the possrep.

=item C<comment> - C<Comment>

This is an optional programmer comment about the possrep as a whole.

=item C<attrs> - C<NameTypeMap>

This defines the 0..N attributes of the possrep.

=item C<constraint> - C<maybe_of.NameChain>

Iff it is a C<Single>, then C<constraint>
matches the declared name of an C<type_constraint> function that
determines what combinations of possrep attribute values denote values of
the [|sub]type, besides the restrictions imposed by the declared types of
the attributes individually.  The function that this names
must have a single C<topic> parameter whose declared type is a tuple whose
attributes match those declared by C<attrs> and whose argument denotes the
value to test; the function's result type must be C<Bool>.  If the
function unconditionally results in C<Bool:true>, then all possible
combinations of attribute-allowable values are collectively allowed.  Note
that, strictly speaking, any constraint defined as part of a possrep (where
there are multiple possreps) may actually be less restrictive than the
total constraint of [|sub]type as a whole, because the total constraint is
defined by I<and>-ing the constraints of all the possreps of the
[|sub]type (and, in the case of defining a subtype, with the
C<subtype_constraint> of the subtype and all base type constraints);
therefore, mainly any given possrep's constraints need to be just
restricting enough so that the inter-possrep mapping functions can handle
the arguments that it accepts, so it is possible to apply the other
possreps' constraints.  Iff C<constraint> is C<nothing>, then semantics are
as if it were a defined name that unconditionally resulted in C<Bool:true>.

=item C<is_base> - C<Bool>

This is an optimization hint for Muldis D implementations that are not
intelligent enough to decide on a best physical representation for the
[|sub]type.  At most one of the type's possreps is singled out by having a
C<Bool:true> value here, so an implementation doesn't have to think and can
just use that as the basis for the physical representation.  To keep things
simple, only a possrep of a root type may be marked C<Bool:true>, so it can
apply consistently to all subtypes as well.  More intelligent
implementations are free to ignore C<is_base>, or just use it as a
tie-breaker if applicable.

=back

A C<PossrepSet> has a unary primary key on the C<name> attribute.  Its
default value is empty.  The default value of a tuple of C<PossrepSet>
has a C<name> that is the empty string, its C<attrs> is empty, and its
C<constraint> is C<nothing>.

=head2 sys.std.Core.Type.Cat.PossrepMapSet

A C<PossrepMapSet> is a C<DHRelation> such that each tuple in it
specifies a pair of mapping functions to bidirectionally derive a value of
a type between 2 of its possreps.

A C<PossrepMapSet> has these 5 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about this bidirectional mapping.

=item C<p1> - C<Name>

This is the declared name of one possrep.

=item C<p2> - C<Name>

This is the declared name of a second possrep.  The value of C<p2> must be
distinct from that of C<p1>, and moreover, the 2 values must be mutually
ordered so that the value of C<p1> is before the value of C<p2>; the latter
constraint defines a C<PossrepMapSet>'s canonical form.

=item C<p2_from_p1> - C<NameChain>

This matches the declared name of an C<possrep_map> function that
derives the representation of the possrep named by C<p2> from that of the
possrep named by C<p1>.  The function that this names must
have a single C<topic> parameter whose declared type is a tuple whose
attributes match those of C<p1>; the function's result type must be a
tuple whose attributes match those of C<p2>.  Note that every distinct
argument (domain) value of this function must have a distinct result
(range) value.

=item C<p1_from_p2> - C<NameChain>

This matches the declared name of an inverse C<possrep_map> function
to that of C<p2_from_p1>.  I<Note that it would often be feasible for a
Muldis D implementation to automatically infer a reverse function, but for
now we still require it to be explicitly stated; the explicitly stated
inverse function could be generated though.  This design is subject to
change.>

=back

A C<PossrepMapSet> has a binary primary key on the C<p1> plus C<p2>
attributes.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.NonscalarType

An C<NonscalarType> is a C<DHTuple>.  It defines either a new
nonscalar heading (set of attributes) with associated constraints
for a tuple and relation type having that heading, or it defines a
subtype of some other nonscalar type.  That is, it defines 2 new
data types, a tuple type and a relation type with matching headings.
Note that you also declare a database type using C<NonscalarType>, by
declaring a tuple type whose attributes are all relation or database typed.
Note that you can not use an C<NonscalarType> to declare or subtype an
incomplete type, as it (or its supertype) must specify a complete set of
attributes.

An C<NonscalarType> has these 13 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the nonscalar
[|sub]type as a whole.

=item C<base_type> - C<maybe_of.NameChain>

Iff the type being defined is a nonscalar root type, then C<base_type> is
not applicable and is C<nothing>.  Iff the type being defined is a
subtype of some other nonscalar type, then C<base_type> is a C<Single>
whose sole element is the name of that other type.

=item C<is_tuple_first> - C<Bool>

Iff this is C<Bool:true> then the type being defined is primarily
considered a tuple type; that is, when either the type name is referenced
normally (not using the C<type> namespace), or the type definition is
embedded (and nameless), then it is simply considered to be a tuple type;
iff this is C<Bool:false> then the type being defined is primarily
considered to be a relation type.  When a type is primarily considered a
tuple or relation type, the only way to reference it as the other kind
of type is by using the C<type.[|dh_][tuple|relation]_from.\w+>
referencing syntax.

=item C<attrs> - C<NameTypeMap>

Iff the type being defined is a nonscalar root type, then C<attrs> defines
the 0..N attributes of the type.  Iff the type being defined is a subtype
of some other type, then the parent type's attribute list is used by
default, but C<attrs> of the current type may be used to apply additional
constraints by overriding the declared types of a subset of the parent's
attributes with types that are subtypes of the originals; an override is
done using matching C<name> attribute values of C<attrs>.  It is indeed
valid for a nonscalar type to have zero attributes (which is then just a
dh-nonscalar type by definition); in this case, a tuple type consists of
exactly one value, and a relation type consists of exactly two values.

=item C<virtual_attr_maps> - C<VirtualAttrMapSet>

This defines the proper subset of this type's attributes that are virtual,
and how they are defined in terms of the rest of this type's attributes.
Note that the special functional dependencies between attributes defined
herein mean that some kinds of tuple constraints would be redundant.

=item C<tuple_constraints> - C<set_of.NameChain>

This matches the declared names of 0..N C<type_constraint> functions
that (when I<and>-ed together) determine what combinations of tuple
attribute values denote values of the [|sub]type, besides the restrictions
imposed by the declared types of the attributes individually; they are
generalized type constraints that together validate a tuple as a whole.
The function that each of these names must have a single
C<topic> parameter whose declared type is a tuple whose attributes match
those declared by C<attrs> and whose argument denotes the value to test;
the function's result type must be C<Bool>.  If the functions
unconditionally result in C<Bool:true>, then all possible combinations of
attribute-allowable values are collectively allowed.  Each function is
invoked either once to test a tuple value, or multiple times to
individually test every tuple in a relation value.

=item C<relation_constraints> - C<set_of.NameChain>

This is like C<tuple_constraint> but that each function's parameter is
relation-typed rather than tuple-typed; each is a generalized type
constraint that validates a relation as a whole.

=item C<keys> - C<KeySet>

These are the 0..N explicit (unique) keys that are applicable to relation
values of the type being defined; they apply either as candidate keys or as
unique key constraints, depending on context.  If there are no explicit
keys, then there is an implicit (unique) key over all attributes of the
relation type being defined, meaning that every possible tuple that may
individually be an element of a relation value of the type being defined,
may be in it at once.  If any explicit keys are defined, then every one
must be over a distinct proper subset of the type's attributes, and
moreover no key's attributes may be a proper subset of any other key's
attributes; if 2 such candidates appear, just use the one that has the
subset.  It is valid for a key to consist of zero attributes; in this case,
that key is the only key of the type, and values of the type may each
consist of no more than one tuple.  At most one key in C<keys> may be
privileged as the I<primary key>.  Note that C<keys> is logically an
abstraction syntax (the canonical simplest form) for a particular kind of
C<relation_constraint> of the type being defined, one that compares the
cardinality of a projection of a relation on its key attributes with the
cardinality of the original relation; the attribute values comprise a key
if the cardinalities are equal.

=item C<distrib_keys> - C<DistribKeySet>

These are the 0..N explicit simple distributed (unique) keys that are
applicable to tuple/database values of the type being defined, that range
over specified relation-typed attributes of it.  At most one key in
C<distrib_keys> may be privileged as the I<primary key>.  Note that
C<distrib_keys> is logically an abstraction syntax (the canonical simplest
form) for a particular kind of C<tuple_constraint> of the type being
defined, one that compares the cardinality of the union of the projection
of distributed key attributes of all key-participating relation-valued
attributes, with the sum of cardinalities of the source relation-valued
attributes; the attribute values comprise a distributed key if the
cardinalities are equal.

=item C<subset_constraints> - C<SubsetConstrSet>

These are the 0..N explicit simple (non-distributed) subset constraints
(foreign keys) that are applicable to tuple/database values of the type
being defined, that range over and relate tuples of specified
relation-typed attributes of it; they are a kind of referential constraint.
Each tuple of a child attribute must have a corresponding tuple in a
specific single parent attribute, where they correspond on the attributes
of the parent attribute that comprise a (unique) key of the latter.  Note
that C<subset_constraints> is logically an abstraction syntax (the
canonical simplest form) for a particular kind of C<tuple_constraint> of
the type being defined, one that tests if the relational difference, where
a projection of the parent relation is subtracted from a corresponding
projection of the child relation (with attribute renaming if necessary), is
an empty relation; if the difference is an empty relation, then the subset
constraint is satisfied; otherwise, any difference tuples are from child
tuples that violate the subset constraint.

=item C<distrib_subset_constraints> - C<DistribSubsetConstrSet>

These are the 0..N explicit simple distributed subset constraints (foreign
keys) that are applicable to tuple/database values of the type being
defined, that range over and relate tuples of specified relation-typed
attributes of it; they are a kind of referential constraint.  Each tuple of
a child attribute must have a corresponding tuple in one member of a
specific set of parent-alternative attributes (that have a distributed key
ranging over them), where they correspond on the attributes of the
parent-alternative attribute that comprise a distributed key on the latter.
Note that C<distrib_subset_constraints> is logically an abstraction syntax
(the canonical simplest form) for a particular kind of C<tuple_constraint>
of the type being defined; it is as per C<subset_constraints> except that
the parent relation is the result of unioning appropriately renamed
projections of the member relations of the distributed key.

=item C<default_tuple> - C<maybe_of.NameChain>

Iff it is a C<Single>, then C<default_tuple>
matches the declared name of an C<named_value> function that
results in the default tuple value of the [|sub]type; it has zero
parameters and its result type is the same as the tuple type whose
declaration it is part of.  Iff C<default_tuple> is C<nothing> and
C<base_type> is C<nothing>, then semantics are as if C<default_tuple> were
a defined name that resulted in a value of the type being defined where all
of the attr values were the default values of their declared types.  Iff
C<default_tuple> is C<nothing> and C<base_type> is a C<Single>, then the
subtype will use the same default tuple value as its base type; but if the
subtype's value set excludes said value, then a C<default_tuple> of
C<nothing> is invalid and C<default_tuple> must be a C<Single>.

=item C<default_relation> - C<maybe_of.NameChain>

Iff it is a C<Single>, then C<default_relation>
matches the declared name of an C<named_value> function that
results in the default relation value of the [|sub]type; it has
zero parameters and its result type is the same as the relation
type whose declaration it is part of.  Iff C<default_relation> is
C<nothing> and C<base_type> is C<nothing>, then semantics are as if
C<default_relation> were a defined name that resulted in a value of the
type being defined that had zero tuples.  Iff C<default_relation> is
C<nothing> and C<base_type> is a C<Single>, then the subtype will use the
same default relation value as its base type; but if the subtype's value
set excludes said value, then a C<default_relation> of C<nothing> is
invalid and C<default_relation> must be a C<Single>.

=back

There is a distributed primary key over the elements of
C<[tuple|relation]_constraints> and the C<name> attributes of
C<[|distrib_][key|subset_constraint]s>.

The default value of C<NonscalarType> defines a relation type that has
zero attributes and whose default value is the one with zero tuples.

=head2 sys.std.Core.Type.Cat.VirtualAttrMapSet

A C<VirtualAttrMapSet> is a C<DHRelation> that defines special functional
dependencies between attributes of a nonscalar data type, such
that, on a per-tuple basis, some attributes can be generated purely from
other attributes, and hence the former attributes may be virtual.  Each
tuple of a C<VirtualAttrMapSet> specifies 2 disjoint subsets of the
nonscalar's attributes, which are I<determinant> and I<dependent>
attributes respectively, where the values of the second set are generated
from the first using a C<virtual_attr_map> function.  Whether I<dependent>
attributes are computed when needed or pre-computed and stored (a trade-off
of storage space for speed) is implementation dependent, though users may
give hints to govern that performance decision.

The main reason for virtual attributes to exist is to provide a fundamental
feature of a relational database where multiple perceptions of the same
data can exist at once; each user can perceive the same data being
organized according to their own preferences, and even if the actual means
of storing the data changes over time, the users continue to be able to
perceive it in the same ways as before the change.

The most important use case of virtual attributes is when the data type
having them is a database type, all of whose attributes are relations (or
databases); and so these attributes define database relvars, with
non-virtual and virtual attributes being base and virtual relvars,
respectively (which correspond to the SQL concepts of base tables and
views, respectively).  The idea in general is that users can work with any
relvar without knowing whether it is base or virtual, and so if
implementations change later such that real relvars become virtual or
vice-versa, users could continue as if nothing changed.

A less common use case of virtual attributes is in (typically non-database)
nonscalar types when users want to treat non-identical values as being
distinct in some situations and non-distinct in others.  For example they
want to do case-insensitive matching of character data, or alternately they
want a case-insensitive (unique) key constraint on such, but either way
they want the case of the data preserved.  In this situation, a base
attribute can exist with the original case-preserved data, and a dependent
virtual attribute can exist with the first's values folded to uppercase
(eliminating any case differences); so then the key constraint can be
placed on the virtual attribute to get the desired semantics, and the
matching can be done against the same.

All permissable operations on virtual [|pseudo-]variables are such that the
semantics of updating them is the same as for updating base
[|pseudo-]variables, with respect to I<The Assignment Principle>: Following
assignment of a value C<v> to a variable C<V>, the comparison C<v = V>
evaluates to TRUE.  Just as an update to determinant variables will have
the cascade effect of updating their dependent variables such that the
functional dependency between them continues to hold, the reverse also must
happen.  Any update to dependent variables must have the side effect of
updating their determinant variables.  Specifically, the implementing code
of an update to dependents must be rewritten behind the scenes to become
instead an update to their determinants, as if the latter was what the
users had actually written, such that following the then-first update of
the determinants, the cascading update to the dependents by the functional
dependency must result in the same dependents' values that they would have
had if the dependents were just base variables being updated by the
original code.  If such a code rewrite can not be done, such as due to
information lost in the functional dependency, then the operation
attempting to update the dependent attributes must fail.  Sometimes the
code rewrite can be done automatically by the DBMS, and sometimes it can
succeed if the map definer gives explicit details on how to accomplish it.

Because Muldis D requires a strong degree of determinism in the whole
system, sometimes users have to provide explicit details on how to
accomplish a reverse mapping, even if it is possible to automatically
generate such, because there may be multiple ways to do a reverse map that
satisfy I<The Assignment Principle>, so the explicitness would be to pick
exactly one of those, so that how determinants are updated is predictable
in an implementation-portable manner.  For example, if a virtual relvar
C<V> is defined as the simple relational union of 2 other relvars C<R1> and
C<R2>, then a tuple insertion into C<V> could be rewritten at least 3
ways, which are an insertion into just C<R1>, or into just C<R2>, or into
both C<R1> and C<R2>; so for predictability's sake, the map should specify
which option to do (which can vary on a case-by-case basis).

I<This all being said, for the moment the C<VirtualAttrMapSet> type does
not give a way to manually specify a reverse function, so for now all the
virtuals are either read-only or updatable due to an automatically
generated reverse function, which might vary by implementation.  Fixing
this matter is TODO.  Note that the reverse functions might have to be
defined as per-tuple operations, separately for
insert/substitute/delete.>

A C<VirtualAttrMapSet> has these 5 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about this virtual attribute map.

=item C<determinant_attrs> - C<NameDNCMap>

These are the names of the determinant attributes.  Each name is given in 2
forms, called C<name> and C<dnc>; C<dnc> is the actual name of the
attribute as existing in the host type, and it may actually be a component
attribute of a host type attribute to any recursive depth (a single C<dnc>
element means it is the actual host type element); C<name> is an alias by
which the attribute will be known in the C<virtual_attr_map> function; this
mapping exists so to make the determinant attributes look like direct
sibling attributes whereas in reality they can be further-away relatives,
just common components somewhere under the host type.

=item C<dependent_attrs> - C<NameDNCMap>

These are the names of the dependent attributes; the structure of
C<dependent_attrs> is as per C<determinant_attrs>; none of these may be the
same as the names of the determinant attributes, since a virtual attribute
can't be defined in terms of itself.

=item C<virtual_attr_map> - C<NameChain>

This matches the declared name of an C<virtual_attr_map> function
that derives a tuple of dependent attribute values from a tuple of
determinant attribute values.  The function that this names must
have a single C<topic> parameter whose declared type is a tuple whose
attributes match those of C<determinant_attrs>; the function's
result type must be a tuple whose attributes match those of
C<dependent_attrs>.  Note that the range of this function is typically
smaller than its domain, though it might not be.

=item C<is_updateable> - C<Bool>

This is C<Bool:true> if all of the dependent attributes should be treated
as updateable, because they have enough information to map any kinds of
updates (all of tuple insert/substitute/delete) back to their determinant
attributes, and the system should try to support updates against them.
This is C<Bool:false> if all of the dependent attributes should not be
considered updateable, either because it is known they don't have enough
information, or because we expect users will never try to update them, so
don't go to the trouble of supporting updates.

=back

A C<VirtualAttrMapSet> has a binary primary key on the C<determinant_attrs>
plus C<dependent_attrs> attributes; it also has a distributed primary key
over the C<dependent_attrs> attribute of all tuples.  Its default value is
empty.

=head2 sys.std.Core.Type.Cat.KeySet

A C<KeySet> is a C<DHRelation> that specifies a set of candidate keys or
unique key constraints for a relation type; each tuple specifies one
candidate key.

A C<KeySet> has these 4 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the key.

=item C<comment> - C<Comment>

This is an optional programmer comment about the key as a whole.

=item C<attrs> - C<set_of.Name>

This defines the 0..N host relation attributes comprising the key.  If
this set is empty, then we have a nullary key which restricts the host
relation to have a maximum of 1 tuple.

=item C<is_primary> - C<Bool>

This is C<Bool:true> if this key has been designated the I<primary key> of
the relation (a relation may have at most one, or none, of those); it
is C<Bool:false> otherwise.  A primary key is privileged over candidate
keys in general, in that all of the attributes comprising the primary key
are likely to be treated as immutable in practice for the relation's
tuples, and hence are the best candidates for identifying tuples within
a relation over an extended term (if multiple keys conceptually have all
those qualities, then you could choose either as the primary, or perhaps
such a situation may indicate a flaw in your database design).  The common
concept of a tuple having an identity that is distinct from the sum total
of all its attribute values, such that one can say that a tuple is being
"updated" (rather than its host relation being the only thing that is
updated to hold a different set of tuples) is dependent in Muldis D on
the host relation having a primary key; if a tuple in a relation is
replaced by a distinct tuple whose values in the primary key attributes
are identical, it is only in this situation that we can consider that we
still have the same tuple, which was just updated, and that we have not
lost the old tuple and gained a new one.  The relation attributes
comprising a primary key are the best mapping values for automatic new
subset constraints and join conditions if the host relation type has to be
auto-split into several associated ones, for example because the physical
representation of this relation doesn't support RVAs; in fact, some
implementations may require that any relation having an RVA must also
have an explicit primary key, so it is easier for them to choose the key to
automatically relate a split relation on.

=back

A C<KeySet> has a unary primary key on the C<name> attribute, and a unary
(unique) key on its C<attrs> attribute.  Its default value is empty.

=head2 sys.std.Core.Type.Cat.DistribKeySet

A C<DistribKeySet> is a C<DHRelation> that specifies a set of candidate
distributed (unique) keys over relation-valued attributes of a
tuple/database; each tuple specifies one distributed (unique) key.

A C<DistribKeySet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the distributed (unique) key.

=item C<comment> - C<Comment>

This is an optional programmer comment about the distributed (unique) key
as a whole.

=item C<attrs> - C<set_of.Name>

This declares the 0..N attributes comprising the distributed (unique) key.
If this set is empty, then we have a nullary key which restricts all of the
relations participating in the distributed key to have a maximum of 1
tuple between them.  Note that the distributed key attribute names don't
have to match the names of any participating relation attributes.

=item C<relations> - C<DKMemRelAttrMap>

This names the 0..N relation-valued attributes of the host
tuple/database type that are participating in the distributed key, and
says which of each of their attributes maps to the attributes of the
distributed key itself.  If this set is empty, then the distributed key has
no effect.  The unary projection of every tuple of the C<key_attr>
attribute of C<relations> must be identical to C<attrs>.

=item C<is_primary> - C<Bool>

This has the same meaning as C<is_primary> of C<KeySet> but for being
distributed as if the relations distributed over were one relation.

=back

A C<DistribKeySet> has a unary primary key on the C<name> attribute, and a
unary (unique) key on its C<relations> attribute.  Its default value is
empty.

=head2 sys.std.Core.Type.Cat.DKMemRelAttrMap

A C<DKMemRelAttrMap> is a C<DHRelation> that names the 0..N relation-valued
attributes of a host tuple/database type that are participating in a
distributed key, and says which of each of their attributes maps to the
attributes of the distributed key itself.

A C<DKMemRelAttrMap> has these 3 attributes:

=over

=item C<rel_name> - C<DeclNameChain>

This is the name of the relation-valued attribute that is participating
in the distributed key.  But the attribute named by C<rel_name> is only a
direct attribute of the host type if C<rel_name> has 1 chain element; if it
has more, then the host type attribute is a tuple/database and any
further elements serve to make C<rel_name> actually address a component of
said.

=item C<comment> - C<Comment>

This is an optional programmer comment about the participation.

=item C<attr_map> - C<DKRelAttrKeyAttrMap>

This maps 0..N attributes of the relation with the same number of
attributes of the distributed key.  Every tuple of C<attr_map> must have an
identical value for the unary projection on its C<key_attr> attribute; in
other words, they must all map with the same distributed key attributes.

=back

A C<DKMemRelAttrMap> has a unary primary key on the C<rel_name> attribute.
Its default value is empty.

=head2 sys.std.Core.Type.Cat.DKRelAttrKeyAttrMap

A C<DKRelAttrKeyAttrMap> is a C<DHRelation>.  It maps 0..N attributes of a
relation-valued attribute of a host tuple/database type participating
in a distributed key, to the same number of attributes of the distributed
key itself.  A C<DKRelAttrKeyAttrMap> has 2 attributes, C<rel_attr> and
C<key_attr>, each of those being a C<Name>, and each of those being a unary
key.  Its default value has zero tuples.

=head2 sys.std.Core.Type.Cat.SubsetConstrSet

A C<SubsetConstrSet> is a C<DHRelation> that specifies a set of
(non-distributed) subset constraints (foreign keys) over relation-valued
attributes of a tuple/database; each tuple specifies one subset constraint,
which is a kind of referential constraint, that relates tuples of such
attributes.  Each tuple of a child attribute must have a corresponding
tuple in a specific single parent attribute, where they correspond on the
attributes of the parent attribute that comprise a (unique) key of the
latter.  Note that it is valid to define a subset constraint involving zero
attributes, in which case the constraint is that the parent relation must
have at least one tuple when the child relation has at least one tuple.

A C<SubsetConstrSet> has these 6 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the subset constraint.

=item C<comment> - C<Comment>

This is an optional programmer comment about the subset constraint as a
whole.

=item C<parent> - C<DeclNameChain>

This is the name of the relation-valued attribute that is the parent in the
(non-distributed) subset constraint relationship.  But the attribute named
by C<parent> is only a direct attribute of the host type if C<parent> has 1
chain element; if it has more, then the host type attribute is a
tuple/database and any further elements serve to make C<parent> actually
address a component of said.

=item C<parent_key> - C<Name>

This is the name of the explicitly declared candidate key or unique key
constraint of C<parent> which defines the attributes of C<parent> that are
being matched on in the subset constraint.

=item C<child> - C<DeclNameChain>

This is the name of the relation-valued attribute that is the child in the
(non-distributed) subset constraint relationship; its structure is as per
C<parent>.  Note that C<child> and C<parent> are allowed to be one and the
same.

=item C<attr_map> - C<SCChildAttrParentAttrMap>

This maps 0..N attributes of the child relation with the same number of
attributes of the parent relation; the mapped attribute names may or may
not be the same.

=back

A C<SubsetConstrSet> has a unary primary key on the C<name> attribute.  Its
default value is empty.

=head2 sys.std.Core.Type.Cat.DistribSubsetConstrSet

A C<DistribSubsetConstrSet> is a C<DHRelation> that specifies a set of
distributed subset constraints (foreign keys) over relation-valued
attributes of a tuple/database; each tuple specifies one subset constraint,
which is a kind of referential constraint, that relates tuples of such
attributes.  Each tuple of a child attribute must have a corresponding
tuple in one member of a specific set of parent-alternative attributes
(that have a distributed key ranging over them), where they correspond on
the attributes of the parent-alternative attribute that comprise a
distributed key on the latter.  Note that it is valid to define a subset
constraint involving zero attributes, in which case the constraint is that
at least one of the parent relations must have at least one tuple when the
child relation has at least one tuple.

A C<DistribSubsetConstrSet> has these 5 attributes:

=over

=item C<name> - C<Name>

This is the declared name of the subset constraint.

=item C<comment> - C<Comment>

This is an optional programmer comment about the subset constraint as a
whole.

=item C<parent_distrib_key> - C<DeclNameChain>

This is the name of the explicitly declared distributed (unique) key that
is the parent in the distributed subset constraint relationship; it defines
by proxy the attributes that are being matched on in the subset constraint.
But the distributed key named by C<parent_distrib_key> may not be directly
declared by the host type of this subset constraint; it might be declared
by the type of an attribute of the host type, if said attribute is a
tuple/database; so the only or last C<parent_distrib_key> chain element is
a key name, and any preceeding names are attribute names.

=item C<child> - C<DeclNameChain>

This is the name of the relation-valued attribute that is the child in the
distributed subset constraint relationship.  But the attribute named by
C<child> is only a direct attribute of the host type if C<child> has 1
chain element; if it has more, then the host type attribute is a
tuple/database and any further elements serve to make C<child> actually
address a component of said.

=item C<attr_map> - C<SCChildAttrParentAttrMap>

This maps 0..N attributes of the child relation with the same number of
attributes of the parent distributed key; the mapped attribute names may or
may not be the same.

=back

A C<DistribSubsetConstrSet> has a unary primary key on the C<name>
attribute. Its default value is empty.

=head2 sys.std.Core.Type.Cat.SCChildAttrParentAttrMap

A C<SCChildAttrParentAttrMap> is a C<DHRelation>.  It maps 0..N attributes
of a child relation-valued attribute of a host tuple/database type
participating in a non-distributed or distributed subset constraint
(foreign key), to the same number of attributes of a parent such attribute
or a distributed key of the host.  A C<SCChildAttrParentAttrMap> has 2
attributes, C<child_attr> and C<parent_attr>, each of those being a
C<Name>, and each of those being a unary key.  Its default value has zero
tuples.

=head2 sys.std.Core.Type.Cat.UnionType

An C<UnionType> is a C<DHTuple>.  It defines a new data type whose
values are all drawn from one or more specified other types (which can be
any not-C<Empty> types at all), and that generally speaking it is an
arbitrary subset of C<Universal> (and it has its own default value).  The
value set of the new data type is determined by taking a set of source
types' values and subtracting from it a set of filter types' values (and
then optionally applying 0..N type constraint functions to the values
remaining).  The likely most common such type definition scenario is
defining a simple explicit union type of 2+ scalar source types.  Less
likely for usage, you can also define simple explicit intersection or
difference or exclusion types.  A union type does not define any changes or
supplements to the interfaces available for working with its values,
instead simply using those of its declared parent types.  A data type
defined in this way is typically not considered to exist when the system
wants to determine the MST (most specific type) of one of its values.  Note
that if you want to define a possrep-adding scalar subtype whose base is
a union/intersection/etc of other types (eg, to define a "Square" when you
have "Rectangle", "Rhombus"), you have to first define a C<UnionType>,
and then use that as the base type of a C<ScalarType>.

An C<UnionType> has these 7 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the union type as a whole.

=item C<sources> - C<set_of.NameChain>

These are the names of the 1..N other not-C<Empty> types that all the
values of the new data type are drawn from; the complete set of source
values is determined by either unioning (the default) or intersecting the
values of these types.

=item C<is_source_intersection> - C<Bool>

Iff this is C<Bool:true> then the set of source data types will be
intersected to determine the complete set of source values; iff this is
C<Bool:false> then the set of source data types will be unioned to
determine the complete set of source values.

=item C<filters> - C<set_of.NameChain>

These are the names of the 0..N other types (which are generally subtypes
of those of C<sources>) that determine values which the new data type will
I<not> contain; the complete set of filter values is determined by either
unioning (the default) or intersecting the values of these types.

=item C<is_filter_intersection> - C<Bool>

Iff this is C<Bool:true> then the set of filter data types will be
intersected to determine the complete set of filter values, and if
C<filters> has no elements then the filter set is just C<Universal>; iff
this is C<Bool:false> then the set of filter data types will be unioned to
determine the complete set of filter values, and if C<filters> has no
elements then the filter set is just C<Empty>.

=item C<constraints> - C<set_of.NameChain>

This matches the declared names of 0..N C<type_constraint> functions
that (when I<and>-ed together) determine what filter-type-passing
source-type values are part of the union type.  The function
that each of these names must have a single C<topic> parameter whose
declared type is C<Universal>, unless there is exactly 1 C<sources> element
whereupon the declared type is the same as the source type, and whose
argument is the value to test; the function's result type must be
C<Bool>.  If the functions unconditionally result in C<Bool:true>, then all
filter-type-passing values are allowed.

=item C<default> - C<NameChain>

This matches the declared name of an C<named_value> function that
results in the default value of the union type; it has zero parameters and
its result type is the same as the union type whose declaration it is part
of.

=back

The default value of C<UnionType> defines an alias for C<Universal>,
with the same default value; it has just the source type C<Universal> and
zero filter types, both type lists are unioned, and C<constraints> is empty
(unconditionally C<Bool:true>).  Note that there is no valid combination of
C<UnionType> attribute values that would result in an alias for the
C<Empty> type, due to a default value for the type being mandatory.

=head2 sys.std.Core.Type.Cat.RestrType

An C<RestrType> is a C<DHTuple>.  It provides a relatively terse
method to define a simple restriction-defined subtype of a single other
type (which can be any not-C<Empty> type at all), which is a common kind of
type to have.  The new type is either a proper or non-proper subset of the
other type, whose values are determined from applying 0..N type constraint
functions to the parent type; either way, the new type does declare its own
default value.  An alternate common scenario is to define a non-proper
subtype of its parent type that serves just to supply a different default
value for the context in which the new type is used.  A restriction type
does not define any changes or supplements to the interfaces available for
working with its values, instead simply using those of its declared parent
type.  A data type defined in this way is typically not considered to exist
when the system wants to determine the MST (most specific type) of one of
its values.  You can only declare a nonscalar type with an incompletely
defined attribute list using a C<RestrType> (or a C<UnionType>).

An C<RestrType> has these 4 attributes:

=over

=item C<comment> - C<Comment>

This is an optional programmer comment about the restriction type as
a whole.

=item C<base_type> - C<NameChain>

This is the name of the not-C<Empty> other type that all the values of the
new data type are drawn from; the new type is being declared as a subtype
of that named by C<base_type>.

=item C<constraints> - C<set_of.NameChain>

This matches the declared names of 0..N C<type_constraint> functions
that (when I<and>-ed together) determine what base type values are part of
the restriction type.  The function that each of these names
must have a single C<topic> parameter whose declared type is that named
by C<base_type>, and whose argument is the value to test; the function's
result type must be C<Bool>.  If the functions unconditionally result
in C<Bool:true>, then the new type is a non-proper subtype of the base
type.

=item C<default> - C<maybe_of.NameChain>

Iff it is a C<Single>, then C<default>
matches the declared name of an C<named_value> function that
results in the default value of the restriction type; it has zero
parameters and its result type is the same as the restriction type whose
declaration it is part of.  Iff C<default> is C<nothing>, then the
restriction type will use the same default value as its base type; but if
the restriction type's value set excludes said value, then a C<default> of
C<nothing> is invalid and C<default> must be a C<Single>.

=back

The default value of C<RestrType> defines an alias for C<Universal>,
with the same default value; it has the base type C<Universal> and
C<constraints> is empty (unconditionally C<Bool:true>).  Note that there is
no valid combination of C<RestrType> attribute values that would
result in an alias for the C<Empty> type, due to a default value for the
type being mandatory.

=head1 SIMPLE GENERIC NONSCALAR TYPES

These are all enumeration data types.

=head2 sys.std.Core.Type.Cat.NameTypeMap

A C<NameTypeMap> is a C<DHRelation>.  It defines a basic component list,
meaning a set of names, with a declared data type name for each.  It forms
the foundation for most componentized type definitions, including all
tuple and relation types (for which it is named I<heading>), and it is
used also for the components list of a scalar possrep.  It is also used
to define parameter lists for routines.  A C<NameTypeMap> has 2 attributes,
C<name> (a C<Name>) and C<type> (a C<NameChain>); the C<name> is the
declared name of the attribute or parameter, and comprises a unary key; the
C<type> is the declared data type of the attribute or parameter.  Its
default value has zero tuples.

=head2 sys.std.Core.Type.Cat.NameExprMap

A C<NameExprMap> is a C<DHRelation>.  It defines a basic component-values
list, meaning a set of names, with a declared local expression node (or
parameter) name for each.  It is used to define collection literals; one
C<NameExprMap> defines a whole C<Tuple> value.  It is also used to define
argument lists for routine invocations by functions or updaters.  A
C<NameExprMap> has 2 attributes, C<name> and C<expr>, each of those being a
C<Name>; the C<name> is the name of the tuple/etc attribute or routine
argument, and comprises a unary key; the C<expr> is the declared local name
(in the C<lex> namespace) of the expression node (or parameter or variable)
which defines the value for the attribute or argument.  Its default value
has zero tuples.

=head2 sys.std.Core.Type.Cat.NameDNCMap

A C<NameDNCMap> is a C<DHRelation>.  It defines an association of a short
name with a declaration name chain, to be used for aliasing the latter with
the former in a particular context.  A C<NameDNCMap> has 2 attributes,
C<name> (a C<Name>) and C<dnc> (a C<DeclNameChain>); each of those is a
unary key.  Its default value has zero tuples.

=head2 sys.std.Core.Type.Cat.AttrRenameMap

An C<AttrRenameMap> is a C<DHRelation>.  It is used as a specification for
how to rename attributes of some collection.  An C<AttrRenameMap> has 2
attributes, C<after> and C<before>, each of those being a C<Name>, and each
of those being a unary key.  Its default value has zero tuples.

=head2 sys.std.Core.Type.Cat.OrderByName

An C<OrderByName> is a C<DHTuple>.  It defines an element of an order-by
sequential expression, which is a specification for how to order tuples of
a relation in terms of a list of their attributes to order on.  An
C<OrderByName> has 2 attributes, C<name> (a C<Name>) and
C<is_reverse_order> (a C<Bool>).  Its default value has the default value
of the C<Name> and C<Bool> types for their respective attributes.  I<Maybe
TODO:  Make C<name> a C<NameChain> instead to drill into TVAs or SVAs.>

=head1 TYPES FOR SPECIAL ENTITY REFERENCES

TODO: HEAVILY UPDATE THIS SECTION.

Muldis D needs to support the concept of a closure or higher-order
function, mainly for functions but also to a smaller extent for imperative
routines.  For example, the generic relational restriction operator is
designed to conceptually take a function as an argument and then invoke
that function on each tuple of a relation it is filtering, and the
function has the criteria for whether the tuple passes the filter.

Conceptually, all that is needed is to pass the fully-qualified name of the
routine as such an argument, which in the system catalog is represented as
a C<NameChain>.  But using an actual C<NameChain> frequently
doesn't work to support closures because the typical closure is defined as
a I<X routine> and those are expressly private to the context of the
Y entity that the X is embedded in.  There is no valid
C<NameChain> value for referencing it from outside that context
(likewise for routines declared private to a subdepot), and outside that
context is typically where the routines that take closures as arguments
would live.  For example, if public function C<dep.lib.mymain> had an
function C<sdp.lib.mytest> and C<dep.lib.mymain> invoked the public
function
C<dep.lib.myfilter> with an argument value of C<sdp.lib.mytest>, then if
C<dep.lib.myfilter> tried to invoke the function it was passed, it would
actually be trying to invoke an function of C<dep.lib.myfilter> named
C<sdp.lib.mytest>, which won't work.  Conceptually, a solution to this
problem
is to actually pass a routine name in a more fully-qualified form,
conceptually like C<dep.lib.mymain.mytest>, which then C<dep.lib.myfilter>
could correctly invoke.  However, if that was made to work literally with a
C<NameChain>, then this could cause problems where anything could
invoke C<mytest> directly without being given permission from C<mymain>.

As an at-least-initial solution to this problem, here are a few black box
data types (similar to scalar types but with no possreps) which will
provide fully-qualified identifiers for routines, useful as alternatives to
C<NameChain> values, so any routine may be correctly invoked from any
other routine, without losing privacy.  Values of these types work their
magic by embedding knowledge about the lexical-et-al context in which they
were selected, so that when routines are to be invoked by way of those
values, the invocation of the capture effectively takes place within the
same context where the special type values were selected, as users would
conceptually expect.  One of these special values is selected in terms of a
C<NameChain>, and the identity of the selected special value is based on
the combination of the C<NameChain> and the context of selection; two
selections in the same context with the same C<NameChain> are guaranteed to
be identical, and two selections with either the context or the
C<NameChain> differing are guaranteed to be non-identical.  Now, whether or
not 2 distinct selections are considered to have the same context (so their
identity varies only on their C<NameChain>) depends on what namespace the
referenced entity is relative to the referencing entity; for a reference to
C<x>, the context is the Y entity containing that X; for a
reference to C<sys> or C<fed>, the context is global; for C<dep> or C<sdp>
the context is that same depot/subdepot.  I<These spec
details may be adjusted.>  Currently, selecting these special values can't
be done with an ordinary routine, but only with a special catalog type for
an expression or statement node, due to the unusualness of this.  It is
also not possible to map one of these special values to another type.
There are no defined sorting orders for values of these types.  There are
default values for these types (of course), and those defaults are to
system-defined routines, for which incidentally the C<NameChain>
solution would always have worked.  These types are all infinite.

There are also similar special types here for referencing data types, but
not for as many of the reasons.  Maybe another advantage of all of the
above is that this can help compile-time type checking.

Extending the previously discussed notions, the special types here for
referencing functions also support currying which is another feature of
generic closures.  When defining a value of a special type, you can also
supply argument values from the context of definition, effectively turning
the corresponding parameters into constants, and so the actual closure has
appropriately fewer effective parameters.  Similarly, one can take an
already existing value of a special type and curry that to derive another
one with arguments from the context of the derivation.  Two function
closures are considered identical if they both reference the same routine
as per the prior-mentioned criteria and they both have the same parameters
curried with identical values, regardless of whether the individual
currying operations resulting in the two closures were identical; for
example, if one closure was produced by a single curry of two parameters
and the other was produced by a chain of two curries where each did one of
those parameters, then the closures are identical assuming same original
routine and parameter values.

I<For now, only functions may be curried, and imperative routines can't be;
the latter might be supported in the future but then it has to be worked
out how to best support currying of updateable parameters, especially how
to define imperative versions of C<sys.std.Core.Control.curried_func>.>

=head2 sys.std.Core.Type.Cat.MaterialRef

This is a reference data type.  A C<MaterialRef> is functionally like a
smart C<NameChain> that holds a routine or type name but it remembers the
context of its creation, and it may also hold other context-specific
information such as pre-bound function parameters.  Its default value
is a reference to the C<sys.std.Core.Type.Universal> data type.

=head2 sys.std.Core.Type.Cat.FuncRef

This is an enumeration data type.  C<FuncRef> is a proper subtype of
C<MaterialRef> where every member value's conceptual C<NameChain> is a
function name plus optional pre-bound read-only parameters.  It is used to
implement a higher-order function or a functional closure.  Its default
value is a reference to the C<sys.std.Core.Universal.is_identical>
function.

=head2 sys.std.Core.Type.Cat.OrdDetFuncRef

This is an enumeration data type.  C<OrdDetFuncRef> is a proper subtype of
C<FuncRef> that is a reference to an C<order_determination> function.  Its
default value is a reference to the C<sys.std.Core.Scalar.order> function.
This type is conceptually intended for use as the declared type of a
routine parameter that would take the name of an C<order_determination>
function, but that parameter is optional and should default to the
system-defined scalar ordering function when no argument is given to it.

=head2 sys.std.Core.Type.Cat.ValFiltFuncRef

This is an enumeration data type.  C<ValFiltFuncRef> is a proper subtype of
C<FuncRef> that is a reference to a C<value_filter> function.  Its default
value is a reference to the C<sys.std.Core.Cat.pass_topic> function.

=head2 sys.std.Core.Type.Cat.ValMapFuncRef

This is an enumeration data type.  C<ValMapFuncRef> is a proper subtype of
C<FuncRef> that is a reference to a C<value_map> function.  Its default
value is a reference to the C<sys.std.Core.Cat.map_to_topic> function.

=head2 sys.std.Core.Type.Cat.ValRedFuncRef

This is an enumeration data type.  C<ValRedFuncRef> is a proper subtype of
C<FuncRef> that is a reference to a C<value_reduction> function.  Its
default value is a reference to the C<sys.std.Core.Cat.reduce_to_v1>
function.

=head2 sys.std.Core.Type.Cat.ImpRef

This is an enumeration data type.  C<ImpRef> is a proper subtype of
C<MaterialRef> where every member value's conceptual C<NameChain> is an
imperative routine name.  It is used to implement an imperative closure.
Its default value is a reference to the C<sys.std.Core.Cat.noop> procedure.

=head2 sys.std.Core.Type.Cat.UpdRef

This is an enumeration data type.  C<UpdRef> is a proper subtype of
C<ImpRef> that is a reference to an updater.  Its default value is a
reference to the C<sys.std.Core.Universal.assign> updater.

=head2 sys.std.Core.Type.Cat.TypeRef

This is an enumeration data type.  C<TypeRef> is a proper subtype of
C<MaterialRef> where every member value's conceptual C<NameChain> is a data
type name.  It is used in places where the name of a data type to 'use'
would be taken as a routine argument.  Its default value is a reference to
the C<sys.std.Core.Type.Universal> data type, the same as C<MaterialRef>.

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::SeeAlso> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<perl@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright  2002-2009, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
