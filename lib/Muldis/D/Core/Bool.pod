=pod

=encoding utf8

=head1 NAME

Muldis::D::Ext::Bool -
Muldis D extension adding more boolean logic operators

=head1 VERSION

This document is Muldis::D::Ext::Bool version 0.100.0.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

=head1 DESCRIPTION

Muldis D has a mandatory core set of system-defined (eternally available)
entities, which is referred to as the I<Muldis D core> or the I<core>; they
are the minimal entities that all Muldis D implementations need to provide;
they are mutually self-describing and are used to bootstrap the language;
any entities outside the core, called I<Muldis D extensions>, are
non-mandatory and are defined in terms of the core or each other, but the
reverse isn't true.

This current C<Bool> document describes the system-defined I<Muldis D Bool
Extension>, which consists of extra operators for boolean logic, adding to
the minimum few defined in the language core.

This current document does not describe the polymorphic operators that all
types, or some types including core types, have defined over them; said
operators are defined once for all types in L<Muldis::D::Core>.

I<This documentation is pending.>

=head1 FUNCTIONS FOR BOOLEAN LOGIC

These functions implement commonly used boolean logic operations.

=head2 sys.std.Core.Bool.not

C<< function sys.std.Core.Bool.not (Bool <-- $topic : Bool) >>

This function results in the logical I<not> of its argument.  This function
results in C<Bool:true> iff its argument is C<Bool:false>, and
C<Bool:false> otherwise.  Note that this operation is also known as
I<negation> or C<¬> or C<!>.

There also exists conceptually the logical monadic operation called
I<proposition> which results simply in its argument; this is the complement
operation of I<negation>.  Now in practice any value expression that is an
invocation of I<proposition> can simply be replaced with its argument, so
there is no reason for I<proposition> to exist as an actual function.

=head2 sys.std.Core.Bool.and

C<< function sys.std.Core.Bool.and (Bool <-- $topic? : set_of.Bool) >>

This function is a reduction operator that recursively takes each pair of
its N input element values and does a logical I<and> (which is commutative,
associative, and idempotent) on them until just one is left, which is the
function's result.  For each pair of input values, the I<and> of that pair
is C<Bool:true> iff both input values are C<Bool:true>, and C<Bool:false>
otherwise.  If C<topic> has zero values, then C<and> results in
C<Bool:true>, which is the identity value for logical I<and>.  Note that
this operation is also known as I<all> or I<every> or I<conjunction> or
C<∧>.

=head2 sys.std.Core.Bool.all

C<< function sys.std.Core.Bool.all (Bool <-- $topic? : set_of.Bool) >>

This function is an alias for C<sys.std.Core.Bool.and>.  This function
results in C<Bool:true> iff all of its input element values are
C<Bool:true> (or it has no input values), and C<Bool:false> otherwise (when
it has at least one input value that is C<Bool:false>).

=head2 sys.std.Bool.nand

C<< function sys.std.Bool.nand (Bool <-- $topic : Bool, $other : Bool) >>

This symmetric function results in C<Bool:false> iff its 2
arguments are both C<Bool:true>, and C<Bool:true> otherwise.  Note that
this operation is also known as I<not and> or I<not both> or I<alternative
denial> or C<⊼> or C<↑>.

=head2 sys.std.Core.Bool.or

C<< function sys.std.Core.Bool.or (Bool <-- $topic? : set_of.Bool) >>

This function is a reduction operator that recursively takes each pair of
its N input element values and does a logical inclusive-or (which is
commutative, associative, and idempotent) on them until just one is left,
which is the function's result.  For each pair of input values, the I<or>
of that pair is C<Bool:false> iff both input values are C<Bool:false>, and
C<Bool:true> otherwise.  If C<topic> has zero values, then C<or> results in
C<Bool:false>, which is the identity value for logical inclusive-or.  Note
that this operation is also known as I<any> or I<some> or I<disjunction> or
C<∨>.

=head2 sys.std.Core.Bool.any

C<< function sys.std.Core.Bool.any (Bool <-- $topic? : set_of.Bool) >>

This function is an alias for C<sys.std.Core.Bool.or>.  This function
results in C<Bool:true> iff any of its input element values are
C<Bool:true>, and C<Bool:false> otherwise (when all of its input values are
C<Bool:false> or if it has no input values).

=head2 sys.std.Bool.nor

C<< function sys.std.Bool.nor (Bool <-- $topic : Bool, $other : Bool) >>

This symmetric function results in C<Bool:true> iff its 2
arguments are both C<Bool:false>, and C<Bool:false> otherwise.  Note that
this operation is also known as I<not or> or I<neither ... nor> or I<joint
denial> or C<⊽> or C<↓>.

=head2 sys.std.Bool.xnor

C<< function sys.std.Bool.xnor (Bool <-- $topic? : bag_of.Bool) >>

This function is a reduction operator that recursively takes each pair of
its N input element values and does a logical xnor (which is both
commutative and associative) on them until just one is left, which is the
function's result.  For each pair of input values, the I<xnor> of that pair
is C<Bool:true> iff both input values are exactly the same value, and
C<Bool:false> otherwise.  If C<topic> has zero values, then C<xnor> results
in C<Bool:true>, which is the identity value for logical xnor.  Note that
this operation is also known as I<not xor> or I<iff> (I<if and only if>) or
I<material equivalence> or I<biconditional> or I<equivalent> (dyadic usage)
or I<even parity> or C<↔>.  Note that a dyadic (2 input value) invocation
of C<xnor> is exactly the same operation as a
C<sys.std.Core.Universal.is_identical> invocation whose arguments are both
C<Bool>-typed.

=head2 sys.std.Bool.iff

C<< function sys.std.Bool.iff (Bool <-- $topic? : bag_of.Bool) >>

This function is an alias for C<sys.std.Bool.xnor>.

=head2 sys.std.Bool.xor

C<< function sys.std.Bool.xor (Bool <-- $topic? : bag_of.Bool) >>

This function is a reduction operator that recursively takes each pair of
its N input element values and does a logical exclusive-or (which is both
commutative and associative) on them until just one is left, which is the
function's result.  For each pair of input values, the I<xor> of that pair
is C<Bool:false> iff both input values are exactly the same value, and
C<Bool:true> otherwise.  If C<topic> has zero values, then C<xor> results
in C<Bool:false>, which is the identity value for logical exclusive-or.
Note that this operation is also known as I<exclusive disjunction> or
I<not equivalent> (dyadic usage) or I<odd parity> or C<⊻> or C<↮>.  Note
that a dyadic (2 input value) invocation of C<xor> is exactly the same
operation as a C<sys.std.Core.Universal.is_not_identical> invocation whose
arguments are both C<Bool>-typed.

=head2 sys.std.Bool.imp

C<< function sys.std.Bool.imp (Bool <-- $topic : Bool, $other : Bool) >>

This function results in C<Bool:false> iff its C<topic> argument is
C<Bool:true> and its C<other> argument is C<Bool:false>, and C<Bool:true>
otherwise.  Note that this operation is also known as I<implies> or
I<material implication> or C<→>.

=head2 sys.std.Bool.implies

C<< function sys.std.Bool.implies (Bool <-- $topic : Bool, $other : Bool)
>>

This function is an alias for C<sys.std.Bool.imp>.

=head2 sys.std.Bool.nimp

C<< function sys.std.Bool.nimp (Bool <-- $topic : Bool, $other : Bool) >>

This function is exactly the same as C<sys.std.Bool.imp> except that it
results in the opposite boolean value when given the same arguments.  Note
that this operation is also known as I<not implies> or I<material
nonimplication> or C<↛>.

=head2 sys.std.Bool.if

C<< function sys.std.Bool.if (Bool <-- $topic : Bool, $other : Bool) >>

This function is an alias for C<sys.std.Bool.imp> except that it transposes
the C<topic> and C<other> arguments.  This function results in
C<Bool:false> iff its C<topic> argument is C<Bool:false> and its C<other>
argument is C<Bool:true>, and C<Bool:true> otherwise.  Note that this
operation is also known as I<converse implication> or I<reverse material
implication> or C<←>.

=head2 sys.std.Bool.nif

C<< function sys.std.Bool.nif (Bool <-- $topic : Bool, $other : Bool) >>

This function is exactly the same as C<sys.std.Bool.if> except that it
results in the opposite boolean value when given the same arguments.  Note
that this operation is also known as I<not if> or I<converse
nonimplication> or C<↚>.

=head2 sys.std.Bool.not_all

C<< function sys.std.Bool.not_all (Bool <-- $topic? : set_of.Bool) >>

This function is exactly the same as C<sys.std.Core.Bool.all> except that
it results in the opposite boolean value when given the same argument.
This function results in C<Bool:true> iff not all of its input element
values are C<Bool:true>, and C<Bool:false> otherwise (when all of its input
values are C<Bool:true> or if it has no input values).

=head2 sys.std.Bool.none

C<< function sys.std.Bool.none (Bool <-- $topic? : set_of.Bool) >>

This function is exactly the same as C<sys.std.Core.Bool.any> except that
it results in the opposite boolean value when given the same argument.
This function results in C<Bool:true> iff none of its input element values
are C<Bool:true> (or it has no input values), and C<Bool:false> otherwise
(when it has at least one input value that is C<Bool:true>).  Note that
this operation is also known as I<not any>.

=head2 sys.std.Bool.not_any

C<< function sys.std.Bool.not_any (Bool <-- $topic? : set_of.Bool) >>

This function is an alias for C<sys.std.Bool.none>.

=head2 sys.std.Bool.one

C<< function sys.std.Bool.one (Bool <-- $topic? : bag_of.Bool) >>

This function results in C<Bool:true> iff exactly one of its input element
values is C<Bool:true>, and C<Bool:false> otherwise.  Note that in some
contexts, this operation would alternately be known as I<xor>, but in
Muldis D it is not.

=head2 sys.std.Bool.not_one

C<< function sys.std.Bool.not_one (Bool <-- $topic? : bag_of.Bool) >>

This function is exactly the same as C<sys.std.Bool.one> except that
it results in the opposite boolean value when given the same argument.

=head2 sys.std.Bool.exactly

C<< function sys.std.Bool.exactly (Bool <-- $topic? : bag_of.Bool,
$count : NNInt) >>

This function results in C<Bool:true> iff the count of its input element
values that are C<Bool:true> matches the C<count> argument, and
C<Bool:false> otherwise.

=head2 sys.std.Bool.not_exactly

C<< function sys.std.Bool.not_exactly (Bool <-- $topic? : bag_of.Bool,
$count : NNInt) >>

This function is exactly the same as C<sys.std.Bool.exactly> except that
it results in the opposite boolean value when given the same argument.

=head2 sys.std.Bool.true

C<< function sys.std.Bool.true (NNInt <-- $topic? : bag_of.Bool) >>

This function results in the count of its input element values that are
C<Bool:true>.

=head2 sys.std.Bool.false

C<< function sys.std.Bool.false (NNInt <-- $topic? : bag_of.Bool) >>

This function results in the count of its input element values that are
C<Bool:false>.

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::SeeAlso> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2009, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
