=pod

=encoding utf8

=head1 NAME

Muldis::D::Dialect::HDMD_Perl6_Tiny -
How to format Perl 6 Hosted Data Muldis D

=head1 VERSION

This document is Muldis::D::Dialect::HDMD_Perl6_Tiny version 0.66.0.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

=head1 DESCRIPTION

This document outlines the grammar of the I<Hosted Data Muldis D> dialect
named C<HDMD_Perl6_Tiny>.  The fully-qualified name of this Muldis D
dialect, in combination with the base language spec it is bundled with, is
C<[ 'Muldis_D', 'http://muldis.com', 'N.N.N', 'HDMD_Perl6_Tiny' ]> (when
the bundled base language version is substituted for the C<N.N.N>).

The C<HDMD_Perl6_Tiny> dialect is defined to be hosted in Perl 6, and is
composed of just|mainly core Perl 6 types.  This dialect is optimized for
Perl 6 specifically, and doesn't try to match the version for Perl 5; you
*will* have to reformat any Perl Hosted Data Muldis D when migrating
between Perl 5 and Perl 6, same as with your ordinary Perl code.

This dialect is designed to exactly match the structure of a possible
concrete syntax tree, comprised of native Perl 6 scalar and collection
typed values, resulting from parsing code written in the Muldis D dialect
L<PTMD_Tiny|Muldis::D::Dialect::PTMD_Tiny> using Perl 6.  This dialect
exists as a convenience to Perl 6 programmers that want to generate or
introspect Muldis D code by saving them the difficulty and overhead of
escaping and stitching plain text code; it is expected that a Muldis D
implementation written in Perl 6 will natively accept input in both the
C<PTMD_Tiny> and C<HDMD_Perl6_Tiny> dialects.  Furthermore, the
C<HDMD_Perl6_Tiny> dialect provides additional Muldis D syntax options to
Perl 6 programmers besides what C<PTMD_Tiny> would canonically parse into,
such as the direct use of some Perl 6-only features.  Note that most of the
details that the 2 dialects have in common are described just in the
C<PTMD_Tiny> file, for both dialects; this current file will mainly focus
on the differences; you should read the L<Muldis::D::Dialect::PTMD_Tiny>
file before the current one, so to provide a context for better
understanding it.

=head1 GENERAL STRUCTURE

A C<HDMD_Perl6_Tiny> Muldis D code file is actually a Perl 6 code file that
defines particular multi-dimensional Perl data structures which resemble
possible concrete syntax trees (CSTs) from parsing C<PTMD_Tiny> Muldis D
code.  Each component of a CST is called a I<node> or node element, and
roughly corresponds to a capture by the C<PTMD_Tiny> parser.  A node is
typically represened as a Perl Seq|Array, but could alternately be a Perl
scalar or something else, and so C<HDMD_Perl6_Tiny> Muldis D code is
typically a tree of Perl structures, called I<node trees>, with Perl
Seq|Array as the central nodes and Perl scalars as the leaf nodes.  Often
C<HDMD_Perl6_Tiny> code is embedded or constructed in one or more files of
a larger Perl 5 program that does more than define this code, such as
various non-database-related tasks.  A node tree is just composed using
basic Perl data types, and there are no Muldis D node-specific Perl classes
or objects required for doing this.

Note that Perl undefined values are not allowed anywhere in a node in the
general case; you must use only defined values instead.  This documentation
also assumes that only defined values are used, and that supplying a Perl
undef will result in an error.  The few exceptions to this rule are
explicitly stated.

The grammar in this file is informal and consists just of written
descriptions of how each kind of I<node> must be composed and how to
interpret such Perl data structures as Muldis D code.  Every named grammar
node is a Perl Seq|Array unless otherwise stated, and every grammar element
is a Seq|Array element; the first node element is the Seq|Array element at
index zero, and so on.

The root grammar node for the entire dialect is C<bootloader>.

=head1 BOOTLOADER

A C<bootloader> node has 1..N ordered elements where the first element is a
C<language_name> node and then either: 1. there is exactly one (second)
element that is a C<value> node or a C<depot> node; 2. there are 1..N
ordered elements where each is a C<boot_stmt> node; 3. there are no other
elements, making the bootloader a no-op.

See the pod sections in this file named L</LANGUAGE NAME>, L</VALUE
LITERALS AND SELECTORS>, L</DEPOT DECLARATION>, and L</BOOTLOADER
STATEMENT> for more details about the aforementioned tokens/nodes.

When Muldis D is being compiled and invoked piecemeal, such as because the
Muldis D implementing virtual machine (VM) is attached to an interactive
user terminal, or the VM is embedded in a host language where code in the
host language invokes Muldis D code at various times, the conceptual
C<bootloader> is usually split up, and so not every Muldis D code fragment
would then have its own C<language_name>.  Usually a C<language_name> would
be supplied to the Muldis D VM just once as a VM configuration step, which
provides a context for further interaction with the VM that just involves
Muldis D code that isn't itself qualified with a C<language_name>.

=head1 LANGUAGE NAME

As per the VERSIONING pod section of L<Muldis::D>, code written in Muldis D
must start by declaring the fully-qualified Muldis D language name it is
written in.  The C<HDMD_Perl6_Tiny> dialect formats this name as a
C<language_name> node having 4-5 ordered elements:

=over

=item C<ln_base_name>

This is the Muldis D language base name; it is simply the Perl C<Str> value
C<Muldis_D>.

=item C<ln_base_authority>

This is the base authority; it is a Perl C<Str> formatted as per a
specific-context C<Name> value literal; it is typically the Perl C<Str>
value C<http://muldis.com>.

=item C<ln_base_version_number>

This is the base version number; it is a Perl C<Str> formatted as per
C<ln_base_authority>; it is typically a Perl C<Str> value like C<1.2.3>.

=item C<ln_dialect>

This is the dialect name; it is simply the Perl C<Str> value
C<HDMD_Perl6_Tiny>.

=item C<ln_extensions>

Optional; this is a set of chosen pragma/parser-config options as per a
C<Tuple> SCVL; see the L</MULDIS D TINY DIALECT PRAGMAS> pod section for
more details.

=back

Examples:

    [ 'Muldis_D', 'http://muldis.com', '1.2.3', 'HDMD_Perl6_Tiny' ]

    [ 'Muldis_D', 'http://muldis.com', '1.2.3', 'HDMD_Perl6_Tiny', {
        auto_add_attrs          => Bool::True,
        auto_unabbrev_std_names => Bool::True,
        auto_chains_from_names  => Bool::True,
    } ]

=head1 VALUE LITERALS AND SELECTORS

A C<value> node is a Muldis D value literal, which is a common special case
of a Muldis D value selector.

There are 24 main varieties of C<value> node, each of which is a named node
kind of its own:  C<Bool>, C<Order>, C<RatRoundMeth>, C<Int>, C<Rat>,
C<Blob>, C<Text>, C<Name>, C<NameChain>, C<DeclNameChain>, C<Comment>,
C<Instant>, C<Duration>, C<UTCInstant>, C<FloatInstant>, C<UTCDuration>,
C<String>, C<QScalar>, C<QTuple>, C<QRelation>, C<QSet>, C<QMaybe>,
C<QArray>, C<QBag>.

Fundamentally, the various Muldis D scalar and collection types are
represented by their equivalent Perl native scalar and collection types.
But since Muldis D is more strongly typed, or at least differently typed,
than Perl, each C<value> node is represented by a Perl Seq|Array, whose
elements include both the payload Perl literal plus explicit meta-data for
how to interpret that Perl literal for mapping to Muldis D.

=head2 Value Literal Common Elements

Every C<value> node is either a GCVL (generic context value literal) or a
SCVL (specific context value literal).

Every GCVL has 1-3 ordered elements:

=over

=item C<value_kind>

This is a Perl C<Str> value of the format C<< <[A..Z]> <[ a..z A..Z ]>+ >>;
it identifies the data type of the value literal in broad terms and is the
only external meta-data of C<payload> generally necessary to interpret the
latter; what grammars are valid for C<payload> depend just on
C<value_kind>.

Between the various kinds of C<value> node, these 48 values are allowed for
C<value_kind>:  C<Bool>, C<Order>, C<RatRoundMeth>, C<[|NN|P]Int>,
C<[|NN|P]Rat>, C<[|Octet]Blob>, C<Text>, C<Name>, C<NameChain>,
C<DeclNameChain>, C<Comment>, C<Instant>, C<Duration>,
C<UTC[Instant|DateTime|Date|Time]>, C<Float[Instant|DateTime|Date|Time]>,
C<UTCDuration>, C<[|B|O|UCP]String>, C<[Q|]Scalar>, C<[Q|]Tuple|Database>,
C<[Q|]Relation>, C<[Q|]Set>, C<[Q|][Maybe|Single]>, C<[Q|]Array>,
C<[Q|]Bag>.

For just some data types, the C<value_kind> may be omitted; see below.

=item C<type_name>

Only when the C<value> node has 3 elements:  This is a Muldis D data type
name, for example C<sys.std.Core.Type.Int>; it identifies a specific
subtype of the generic type denoted by C<value_kind>, and serves as an
assertion that the Muldis D value denoted by C<payload> is a member of the
named subtype.  Its format is a C<NameChain_payload> node.  Iff
C<value_kind> is C<[Q|]Scalar> then C<type_name> is mandatory; otherwise,
C<type_name> is optional for all C<value>, except that C<type_name> must be
omitted when C<value_kind> is one of the 2 [C<Bool>, C<Order>]; this isn't
because those 2 types can't be subtyped, but because in practice doing so
isn't useful.

=item C<payload>

This is mandatory for all C<value>.  Format varies with C<value_kind>.

=back

A Perl Pair may alternately be used to represent a GCVL iff that node has
exactly 2 elements (C<value_kind> and C<payload>); in that case, the
C<value_kind> is stored in that Pair's key, and the C<payload> is stored in
the Pair's value.

For some data types, a GCVL may alternately be just its payload for the
sake of brevity.  If any Perl value of one of the following types is
encountered where a GCVL node is expected, then it is interpreted as a full
C<value> node as follows:

    Muldis D <- Perl 6
    --------------------
    Bool     <- Bool
    Order    <- Order
    Int      <- Int
    Rat      <- Rat|Num
    Blob     <- Blob
    Text     <- Str
    Instant  <- Instant
    Duration <- Duration

The above details are subject to revision regarding when a Perl object
might claim to do multiple type interfaces.

For GCVL and SCVL examples, see the subsequent documentation sections.

=head1 OPAQUE VALUE LITERALS

=head2 Boolean Literals

A C<Bool> node represents a logical boolean value.  It is interpreted as a
Muldis D C<sys.std.Core.Type.Bool> value as follows:  The payload must be a
Perl C<Bool>, and so C<Bool::False> and C<Bool::True> are mapped directly.

Examples:

    :Bool(Bool::True)

    Bool::False

=head2 Order-Determination Literals

A C<Order> node represents an order-determination.  It is interpreted as a
Muldis D C<sys.std.Core.Type.Cat.Order> value as follows:  The payload must
be a Perl C<Order>, and so C<Order::Increase> and C<Order::Same> and
C<Order::Decrease> are mapped directly.

Examples:

    :Order(Order::Same)

    Order::Decrease

=head2 Rational Rounding Method Literals

A C<RatRoundMeth> node represents a rational rounding method.  It is
interpreted as a Muldis D C<sys.std.Core.Type.Cat.RatRoundMeth> value by
directly mapping the payload.  The payload must be a Perl C<Str> having one
of the 7 values C<half_down>, C<half_up>, C<half_even>, C<to_floor>,
C<to_ceiling>, C<to_zero>, C<to_inf>.

Examples:

    :RatRoundMeth<half_up>

    :RatRoundMeth<to_zero>

=head2 General Purpose Integer Numeric Literals

An C<Int> node represents an integer numeric value.  It is interpreted as a
Muldis D C<sys.std.Core.Type.Int> value as follows:  The payload must be a
Perl C<Int>, which is mapped directly.

Examples:

    :Int(:2<11001001>) # binary

    :8<0> # octal

    :8<644> # octal

    -34 # decimal

    42 # decimal

    :16<DEADBEEF> # hexadecimal

    :36<-HELLOWORLD> # base-36

    :4<301> # base-4

    :12<A09B> # base-12

=head2 General Purpose Rational Numeric Literals

A C<Rat> node represents a rational numeric value.  It is interpreted as a
Muldis D C<sys.std.Core.Type.Rat> value as follows:  The payload must
be a Perl C<Rat|Num|Int>, which is mapped directly.

Examples:

    :Rat(:2<-1.1>)

    -1.5 # same val as prev

    3.14159

    :11<0.0>

    :16<DEADBEEF.FACE>

    :36<0.000AZE>

    :Rat(:7<500001> div :7<1000>)

    :12<A09B> div :12<A>

    :Rat(:2<1011101101> * :2<10> ** :2<-11011>)

    45207196 * 10 ** 37

    1 div 43

    314159 * 10 ** -5

=head2 General Purpose Binary String Literals

A C<Blob> node represents a general purpose bit string.  It is interpreted
as a Muldis D C<sys.std.Core.Type.Blob> value as follows:  The payload must
be a Perl C<Blob>, which is mapped directly.

Examples I<TODO: What is the actual syntax for the P6 Blob type?>:

    :Blob( Blob.new(  2 => '00101110100010' ) ) # binary

     Blob.new(  4 => '' )

     Blob.new( 16 => 'A705E' ) # hexadecimal

     Blob.new(  8 => '523504376' )

=head2 General Purpose Character String Literals

A C<Text> node represents a general purpose character string.  It is
interpreted as a Muldis D C<sys.std.Core.Type.Text> value by directly
mapping the payload.  The payload must be a Perl C<Str>.

Examples:

    :Text<Ceres>

    'サンプル'

    ''

    'Perl'

    "\c[LATIN SMALL LETTER OU]\x[263A]\c[65]"

=head2 DBMS Entity Name Literals

A C<Name> node represents a canonical short name for any kind of DBMS
entity when declaring it; it is a character string type, that is disjoint
from C<Text>.  It is interpreted as a Muldis D
C<sys.std.Core.Type.Cat.Name> value by directly mapping the payload.  The
payload must be a Perl C<Str>.

A C<NameChain> node represents a canonical long name for invoking a DBMS
entity in some contexts; it is conceptually a sequence of entity short
names.  Its payload is a Perl C<Seq|Array> value or C<Str> value.  This
node is interpreted as a Muldis D C<sys.std.Core.Type.Cat.NameChain> value
as follows:

=over

=item *

If the payload is an C<Seq|Array>, then it must have at least 2 elements,
and every element must be a valid payload for a C<Name>  node (that
is, any Perl character string).  Each element of the payload, in order,
defines an element of the C<array> possrep's attribute of a C<NameChain>.

=item *

If the payload is a C<Str>, then it must be formatted as a catenation
(using period (C<.>) separators) of at least 2 parts, where each part can
not have any literal period (C<.>) characters (if you want literal periods
then you can only use the C<Seq|Array> payload format to express it).  The
C<Str> format of payload is interpreted by splitting it on the separators
into the C<Seq|Array> format, then processed as per the latter.

=back

A C<DeclNameChain> node represents a canonical long name for declaring a
DBMS entity in N-depth contexts; the format and interpretation of a
C<DeclNameChain_payload> (but as a C<sys.std.Core.Type.Cat.DeclNameChain>
value) is the same as a C<NameChain_payload> but that the chain may have as
few as zero parts rather than as few as 2; however, a zero part chain can
only be expressed with the C<Seq|Array> payload format; an empty string
C<Str> format will be interpreted as having a single element that is the
empty string.

Examples:

    :Name<login_pass>

    :Name('First Name')

    :NameChain['fed','data','the_db','gene','sorted_person_name']

    :NameChain('fed.data.the_db.stats.samples by order')

    :DeclNameChain['gene','sorted_person_name']

    :DeclNameChain('stats.samples by order')

    :DeclNameChain[]

=head2 Code Comment Literals

A C<Comment> node represents the text of a Muldis D code comment; it is a
character string type, that is disjoint from both C<Text> and C<Name>.  It
is interpreted as a Muldis D C<sys.std.Core.Type.Cat.Comment> value by
directly mapping the payload.  The payload must be a Perl C<Str>.

Examples:

    :Comment('This does something.')

    :Comment('So does this.')

=head2 TAI Temporal Literals

An C<Instant> node represents a single point in time which is specified in
terms of of atomic seconds.  This node is interpreted as a Muldis D
C<sys.std.Core.Type.Instant> value as follows:  The payload must be a Perl
C<Instant>, which is mapped directly.

A C<Duration> node represents a single amount of time (the difference
between two instants) which is specified in terms of of atomic seconds.
This node is interpreted as a Muldis D C<sys.std.Core.Type.Duration> value
as follows:  The payload must be a Perl C<Duration>, which is mapped
directly.

Examples I<TODO: What is t actual syntax for P6 [Instant|Duration] types?>:

    :Instant( Instant.new(1235556432.0) )

    Instant.new(854309115.0)

    :Duration( Duration.new(3600.0) )

    Duration.new(-50.0)

    Duration.new(3.14159)

    Duration.new(:2<1011101101> * :2<10> ** :2<-11011>)

    Duration.new(1 div 43)

=head2 UTC and Float Temporal Literals

A C<UTCInstant> node represents an "instant"/"datetime" value that is
affiliated with the UTC time-zone.  This node is interpreted as a Muldis D
C<sys.std.Temporal.Type.UTCInstant> value whose C<instant> possrep
attribute values are defined as follows:

The payload must be a Perl C<Seq|Array> with 6 elements, where each element
may be either undefined or defined; or if fewer than 6 elements are
provided, the C<Seq|Array> will be implicitly extended to 6, filling with
undefs.  The 6 payload elements correspond in order, from the lowest to the
highest indexed, to the 6 attributes: C<year>, C<month> C<day>, C<hour>,
C<minute>, C<second>.  For each payload element that Perl considers
undefined or defined, the corresponding attribute has the C<nothing> or a
C<Single> value, respectively.  For each of the first 5 elements, when it
is defined, it must qualify as a valid payload for an C<Int> node; for
the 6th element, when it is defined, it must qualify as a valid payload for
a C<Rat> node.

A defined C<year> may be any integer, each of [C<month>, C<day>] must be a
positive integer, each of [C<hour>, C<minute>] must be a non-negative
integer, and C<second> must be a non-negative rational number.  If all 6
attributes are defined, then the new C<UTCInstant> value is also a
C<UTCDateTime>; if just the first 3 or last 3 are defined, then the value
is not a C<UTCDateTime> but rather a C<UTCDate> or C<UTCTime>,
respectively; if any other combination of attributes are defined, then the
value is just a C<UTCInstant> and not of any of the other 3 subtypes.

A C<FloatInstant> node represents an "instant"/"datetime" value that is
"floating" / not affiliated with any time-zone.  This node is interpreted
as a Muldis D C<sys.std.Temporal.Type.FloatInstant> value in an identical
fashion to how a C<UTCInstant> node is interpreted, whose format it
completely shares.  Likewise regarding C<Float[DateTime|Date|Time]>.

A C<UTCDuration> node represents a duration value, an amount of time, which
is not fixed to any instant in time.  This node is interpreted as a Muldis
D C<sys.std.Temporal.Type.UTCDuration> value whose C<duration> possrep
attribute values are defined as follows:

The payload must be a Perl C<Seq|Array> with 6 elements, where each element
may be either undefined or defined; or if fewer than 6 elements are
provided, the C<Seq|Array> will be implicitly extended to 6, filling with
undefs.  The 6 payload elements correspond in order, from the lowest to the
highest indexed, to the 6 attributes: C<years>, C<months> C<days>,
C<hours>, C<minutes>, C<seconds>.  For each payload element that Perl
considers undefined or defined, the corresponding attribute has the
C<nothing> or a C<Single> value, respectively.  For each of the first 5
elements, when it is defined, it must qualify as a valid payload for an
C<Int>  node; for the 6th element, when it is defined, it must qualify
as a valid payload for a C<Rat>  node.

A defined [C<years>, C<months>, C<days>, C<hours>, C<minutes>] may be any
integer, and C<seconds> may be any rational number.  I<Currently,
C<UTCDuration> has no system-defined subtypes, but that may change later.>

Examples:

    :UTCInstant[1964,10,16,16,12,47.5] # a UTCDateTime

    :UTCInstant[2002,12,6] # a UTCDate

    :UTCInstant[undef,undef,undef,14,2,29.0] # a UTCTime

    :FloatInstant[2003,4,5,2] # min,sec unknown or N/A

    :FloatInstant[1407] # just know its sometime in 1407

    :UTCDuration[3,5,1,6,15,45.000012]

=head2 Low Level Integer String Literals

A C<String> node represents an integer string value.  It is interpreted as
a Muldis D C<sys.std.Core.Type.Cat.String> value as follows:  The payload
must be a Perl C<Seq|Array>, whose elements are all Perl C<Int>, which is
mapped directly; each payload element is mapped directly as per the payload
of an C<Int> node.

Examples:

    :String[0x50,0x65,0x72,0x6C] # Unicode codepoints = 'Perl'

    :String[80,101,114,109] # same thing

=head1 COLLECTION VALUE SELECTORS

Note that, with each of the main value selector nodes documented in this
main POD section, any occurrences
of child C<expr> nodes should be read as being C<value> nodes instead in
contexts where instances of the main nodes are being composed beneath
C<value> nodes.  That is, any C<expr> node options beyond what C<value>
options exist are only valid within a C<depot> node or C<boot_stmt> node.

=head2 Scalar Selectors

A C<QScalar> node represents a literal or selector invocation for a
quasi-scalar subtype value.  It is interpreted as a Muldis D
C<sys.std.Core.Type.QScalar> subtype value whose declared type is specified
by the node's (mandatory for C<QScalar>) C<type_name> element and whose
attributes are defined by the payload.  The payload must be a Perl C<Pair>,
whose key and value, respectively, are designated I<possrep name> and
I<possrep attrs>.  The possrep name and possrep attrs must be as per the
payload of a C<Name> and C<QTuple> node, respectively.  The I<possrep
attrs> is interpreted specifically as attributes of the declared type's
possrep which is specified by the I<possrep name>.  Each key+value pair of
the I<possrep attrs> defines a named possrep attribute of the new scalar;
the pair's key and value are, respectively, a Perl C<Str> that specifies
the possrep attribute name, and a C<expr> node that specifies the possrep
attribute value.

Examples:

    [ 'Scalar', 'sys.std.Core.Type.Rat', float => {
        mantissa => 45207196,
        radix    => 10,
        exponent => 37,
    } ]

    [ 'Scalar', 'sys.std.Temporal.Type.UTCDateTime', datetime => {
        year   => 2003,
        month  => 10,
        day    => 26,
        hour   => 1,
        minute => 30,
        second => 0.0,
    } ]

    [ 'Scalar', 'fed.lib.the_db.WeekDay', name => {
        '' => 'monday',
    } ]

    [ 'Scalar', 'fed.lib.the_db.WeekDay', number => {
        '' => 5,
    } ]

=head2 Tuple and Database Selectors

A C<QTuple> node represents a literal or selector invocation for a
quasi-tuple value.  It is interpreted as a Muldis D
C<sys.std.Core.Type.QTuple> value whose attributes are defined by the
payload.  The payload must be a Perl C<Mapping|Hash>.  Each key+value pair
of the payload defines a named attribute of the new tuple; the pair's key
and value are, respectively, a Perl C<Str> that specifies the attribute
name, and a C<expr> node that specifies the attribute value.

Examples:

    :Tuple{}

    [ 'Tuple', 'type.tuple_from.var.fed.data.the_db.account.users', {
        login_name => 'hartmark',
        login_pass => 'letmein',
        is_special => Bool::True,
    } ]

    :Tuple{
        name => 'Michelle',
        age  => 17,
    }

=head2 Relation Selectors

A C<QRelation> node represents a literal or selector invocation for a
quasi-relation value.  It is interpreted as a Muldis D
C<sys.std.Core.Type.QRelation> value whose attributes and tuples are
defined by the payload, which is interpreted as follows:

=over

=item *

Iff the payload is a Perl C<Set|KeySet> with zero elements, then it
defines the only relation value having zero attributes and zero tuples.

=item *

Iff the payload is a Perl C<Set|KeySet> with at least one element, and
every element is a Perl C<Str> (as per a valid payload for a C<Name> node),
then it defines the attribute names of a relation having zero tuples.

=item *

Iff the payload is a Perl C<Set|KeySet> with at least one element, and
every element is a Perl C<Mapping|Hash> (as per a valid payload for a
C<QTuple> node), then each element of the payload defines a tuple of
the new relation; every tuple-defining element of the payload must be of
the same degree and have the same attribute names as its sibling elements;
these are the degree and attribute names of the relation as a whole, which
is its heading for the current purposes.

=item *

Iff the payload is a Perl C<Pair>, then:  The new relation value's
attribute names are defined by the payload's key, which is a Perl
C<Seq|Array> of C<Str> (each as per a C<Name> node payload), and the
relation body's tuples' attribute values are defined by the payload's
value, which is a Perl C<Set|KeySet> of C<Seq|Array> of tuple attribute
value defining  nodes.  This format is meant to be the most compact of
the generic relation payload formats, as the attribute names only appear
once for the relation rather than repeating for each tuple.  As a
trade-off, the attribute values per tuple from the payload value must
appear in the same order as their corresponding attribute names appear in
the payload key, as the names and values in the relation literal are
matched up by ordinal position here.

=back

Examples I<TODO: What is the actual syntax for the P6 Set type?>:

    :Relation( Set.new() )  # zero attrs + zero tuples

    :Relation( Set.new(<x y z>) )  # 3 attrs + zero tuples

    :Relation( Set.new( {} ) )  # zero attrs + 1 tuple

    :Relation( Set.new(
        {
            login_name => 'hartmark',
            login_pass => 'letmein',
            is_special => Bool::True,
        },
    ) )  # 3 attrs + 1 tuple

    [ 'Relation', 'fed.lib.the_db.gene.Person', <name age> => Set.new(
        [ 'Michelle', 17 ],
    ) ]  # 2 attrs + 1 tuple

=head2 Set Selectors

A C<QSet> node represents a literal or selector invocation for a quasi-set
value.  It is interpreted as a Muldis D C<sys.std.Core.Type.QSet> value
whose elements are defined by the payload.  The payload must be a Perl
C<Set|KeySet>.  Each element of the payload defines a unary quasi-tuple of
the new quasi-set; each element is a C<expr> node that defines the C<value>
attribute of the quasi-tuple.

Examples I<TODO: What is the actual syntax for the P6 Set type?>:

    [ 'Set', 'fed.lib.the_db.account.Country_Names', Set.new(
        'Canada',
        'Spain',
        'Jordan',
        'Thailand',
    ) ]

    :Set( Set.new(
        3,
        16,
        85,
    ) )

=head2 Maybe Selectors

A C<QMaybe> node represents a literal or selector invocation for a
quasi-maybe value.  It is interpreted as a Muldis D
C<sys.std.Core.Type.QMaybe> value.  If the node payload is missing or
undefined, then the node is interpreted as the special value
C<Maybe:nothing>, aka C<nothing>, which is the only C<QMaybe> value with
zero elements.  If the node payload is defined then the node is interpreted
as a C<QSingle> whose element is defined by the payload.  The payload is a
C<expr> node that defines the C<value> attribute of the single quasi-tuple
of the new quasi-'single'.

Examples:

    :Maybe( 'I know this one!' )

    :Maybe()  # or how does Perl 6 make a Pair with undef/default value?

=head2 Array Selectors

A C<QArray> node represents a literal or selector invocation for a
quasi-array value.  It is interpreted as a Muldis D
C<sys.std.Core.Type.QArray> value whose elements are defined by the
payload.  The payload must be a Perl C<Seq|Array>.  Each element of the
payload defines a binary quasi-tuple of the new sequence; the element value
is a C<expr> node that defines the C<value> attribute of the quasi-tuple,
and the element index is used as the C<index> attribute of the quasi-tuple.

Examples:

    :Array[
        'Alphonse',
        'Edward',
        'Winry',
    ]

    [ 'Array', 'fed.lib.the_db.stats.Samples_By_Order', [
        57,
        45,
        63,
        61,
    ] ]

=head2 Bag Selectors

A C<QBag> node represents a literal or selector invocation for a quasi-bag
value.  It is interpreted as a Muldis D C<sys.std.Core.Type.QBag> value
whose elements are defined by the payload.  The payload must be a Perl
C<Bag|KeyBag|Set|KeySet> value; the payload element keys are C<expr> nodes
corresponding to the C<value> attribute of the new quasi-bag's
quasi-tuples, and the payload element values are positive integers (or
C<Bool::True>, which counts as the number 1) corresponding to the C<count>
attribute; the payload element mapping is as you should expect.

Examples I<TODO: What is the actual syntax for the P6 Bag type?>:

    [ 'Bag', 'fed.lib.the_db.inventory.Fruit', Bag.new(
        'Apple'  => 500,
        'Orange' => 300,
        'Banana' => 400,
    ) ]

    :Bag( Bag.new( [
        'Foo',
        'Quux',
        'Foo',
        'Bar',
        'Baz',
        'Baz',
    ] ) )

=head1 DEPOT DECLARATION

B<TODO: ALL OF THIS HERE MAIN POD SECTION!>

=head1 BOOTLOADER STATEMENT

B<TODO/REDO: ALL OF THIS HERE MAIN POD SECTION!>

This node specifies one statement of a Muldis D C<bootloader> routine
which invokes an imperative routine, such statements being what the entire
body of a C<bootloader> is composed of.  A bootloader imperative routine
call is formatted as a node having the following 4 elements:

=over

=item *

Node kind: the Perl C<Str> value C<boot_stmt>.

=item *

Imperative routine name: a Perl C<Seq|Array|Str> as per the payload of a
C<NameChain> node.

=item *

Imperative routine subject-to-update args: a Perl C<Mapping|Hash> as per
the payload of a C<QTuple> node except that every C<Mapping|Hash> value is
just a Perl C<Seq|Array|Str> as per the payload of a C<NameChain> node
(each value is the name of a global variable).

=item *

Imperative routine read-only args: a Perl C<Mapping|Hash> as per the
payload of a C<QTuple> node.

=back

Examples

    [ 'boot_stmt', 'sys.std.Core.Cat.create_depot_procedure', {}, { ... } ]

=head1 MULDIS D TINY DIALECT PRAGMAS

B<TODO/REDO: ALL OF THIS HERE MAIN POD SECTION!>

All of the following pragmas apply to both the C<PTMD_Tiny> and
C<HDMD_Perl[6|5]_Tiny> dialects, and have the same semantics with both.

=head2 auto_add_attrs

All Muldis D values are defined in
terms of a collection of attribute values, and there is no such thing as an
attribute being undefined; normally when one selects a value of a
particular attribute-based type, they must supply values for I<all> of its
attributes; this is true with values comprising the system catalog as with
any other values.  Code written in the Muldis D C<PTMD_Tiny> or
C<HDMD_Perl[6|5]_Tiny> dialect is comprised almost entirely of value
literals, and by default all of the attribute values of said values must be
explicitly given in the literals as sub-literals, even in the common case
where some attributes just have the default values for their type.

While this fact allows for parsers to be very simple and for sub-literals
to be compilable into values without knowing the context they're compiled
into, it means that programmers would have to write maybe about twice as
much code as they otherwise would if they could simply not write out the
default-valued attributes.

If the 5th I<Extensions> portion of the fully-qualified Muldis D language
name contains a name+value pair of C<auto_add_attrs> + C<Bool:true>, then
this activates the optional C<auto_add_attrs> pragma, which provides one
kind of automatic code completion.  When C<auto_add_attrs> is active,
programmers may omit any literal attributes that they want, and those
attributes will be automatically defined by the parser to have the default
values for their type.  Or more specifically, the wider literal whose
attributes are missing will be extended to become the default value of the
type of the wider literal but that those attributes of its that I<were>
explicitly given will override the default's values for those attributes.
The actual behaviour is essentially what the
C<sys.std.QTuple.subst_in_default> function does.

But the C<auto_add_attrs> pragma is not simply an automatically invoked
pre-processing Muldis D function, because it also serves the common case
where one is defining relation literals that have different attributes
specified per tuple; such a thing by itself isn't even valid as a generic
relation, so it certainly can't be given to a Muldis D function; so the
pragma has at least that advantage unique to itself.

Note that the lexer is exactly the same regardless of whether the
C<auto_add_attrs> pragma is turned on or off, because the matters of
missing attributes were never tested or enforced at the lexical level in
the first place; rather the pragma only affects the parsing stage that
follows the lexing.  In other words, the actual syntax or grammar is
identical regardless of the setting of this pragma.

Now one consequence of using the C<auto_add_attrs> pragma is that in
general the parser must be more complicated, and read type definitions from
the DBMS information schema so that it knows what attributes each literal
is supposed to have, and their declared types, and also sub-literals can no
longer in general be fully converted to values in isolation; now the
parent-most literal must be evaluated first, because its declared type
generally determines the declared types of its attributes, and then their
attributes recursively.  For nonscalar types, the initial declared type
being looked at is the declared type of the bootloader-invoked routine's
parameter that the literal is being given to as an argument.

Now if the declared type of said parameter is just a generic type, such as
C<Relation> or C<Array>, then often no information can be gleaned from this
context for what attributes should exist, and so you will need to make the
arg literal include treat-as-type metadata that explicitly provides the
specific type information needed; otherwise, C<auto_add_attrs> won't help
you and you must then fully define relation values with the same attributes
per tuple.  But fortunately for brevity, a lot of the places where
C<auto_add_attrs> would help you the most is when the bootloader is
invoking system-defined data-defining procedures, and their parameters are
all of attribute-specifying types, and it is in such data definition that
you may be most likely to face a large number of default-valued attributes,
such as C<comment>.

Note that the reason the C<auto_add_attrs> behaviour is turned off by
default is twofold.  First, the parser can be a lot simpler / more tiny
with it off.  Second, requiring users to explicitly define even
default-valued attributes can make the code more self-documenting and can
help users avoid some kinds of bugs due to action from unseen values, or
due to some default values "silently" changing between language versions.
So then essentially, turning on C<auto_add_attrs> means the programmer is
telling the parser "I know what I'm doing" by I<explicitly> asking for
potentially less-safe behaviour.  Of course, even with C<auto_add_attrs>
turned on, you can still explicitly define attribute values that are their
type's default values, so it is possible to compromise such as you like.

Also note that it should be trivial for a Muldis D implementation to let
users input code written with C<auto_add_attrs> turned on, and then output
the version of that code for their perusal with it turned off, so they can
see what extra values were filled in without having to manually write said.

=head2 auto_unabbrev_std_names

Normally when one is specifying a C<NameChain> literal that is a
reference to a standard system-defined type or routine, they must write out
the name in full, starting with C<sys.std> and so on through the unique
part of the entity name.  While this allows for clearly self-documenting
code, as well as for relatively simple parsers, it can also be added tedium
to programmers that would prefer to write out the names in a less verbose
manner, especially since to a point, a slightly more complicated parser
could still unambiguously resolve a much shorter substring of the name.

If the 5th I<Extensions> portion of the fully-qualified Muldis D language
name contains a name+value pair of C<auto_unabbrev_std_names> +
C<Bool:true>, then this activates the optional C<auto_unabbrev_std_names>
pragma, which provides one kind of automatic code completion.  When
C<auto_unabbrev_std_names> is active, programmers may omit any number of
consecutive leading chain elements from such a C<NameChain> literal, so
long as the remaining unqualified chain is distinct among all standard
system-defined (C<sys.std>-prefix) DBMS entities (but that as an exception,
a non-distinct abbreviation is allowed iff exactly 1 of the candidate
entities is in the language core, C<sys.std.Core>-prefix, in which case
that 1 is unambiguously the entity that is resolved to).  This feature has
no effect on the namespace prefixes like C<tuple_from> or C<array_of>; one
still writes those as normal prepended to the otherwise shortened chains.

So for example, one can just write C<Int> rather than
C<sys.std.Core.Type.Int>, C<is_identical> rather than
C<sys.std.Core.Universal.is_identical>, C<QTuple.attr> rather than
C<sys.std.Core.QTuple.attr>, C<min> rather than C<sys.std.Ordered.min>,
C<array_of.Rat> rather than C<array_of.sys.std.Core.Type.Rat>, and so
on.

The C<auto_unabbrev_std_names> pragma intentionally does not empower auto
un-abbreviations of any namespaces other than C<sys.std>, to keep things
simple for users to predict and for systems to implement; it does not
affect C<sys.[imp|cat]>, nor any other top-level namespace.  When one is
referencing either any system-defined implementation-specific
(non-standard) types or routines, or any user-defined types or routines, or
any dbvars or constraints or whatever, their names can not be written
abbreviated due to the C<auto_unabbrev_std_names> pragma.

Note that the lexer is exactly the same regardless of whether the
C<auto_unabbrev_std_names> pragma is turned on or off, as per the
C<auto_add_attrs> pragma.  Many other comments about the other pragma also
apply to this one.

=head2 auto_chains_from_names

Iff both the C<auto_add_attrs> and C<auto_unabbrev_std_names> pragmas are
active, then the optional C<auto_chains_from_names> dependent pragma may be
activated in the same manner (as an I<Extensions> name+value pair with
C<Bool:true>.  When C<auto_chains_from_names> is active, programmers may
write an otherwise abbreviated-to-one-chain-element C<NameChain>
literal as a plain C<Name> literal; this can chop the literal down to a
third or fourth of its otherwise-length such as in the case of a reference
to the C<Int> type.  When the parent literal of such a faux-C<Name>
literal is examined for missing attributes, or examined that existing
attributes are of the correct type, any attributes whose declared type says
they are supposed to be C<NameChain> but that have an explicitly
defined C<Name> child literal will have that literal mapped to and
replaced with a single element C<NameChain> literal, which can be
subsequently un-abbreviated into a standard system-defined type or routine
name.  The C<auto_chains_from_names> pragma will not work when the declared
type being applied to a faux-C<Name> is not a C<NameChain> subtype,
and such literals will then be taken as actual C<Name>; where such
declared type information is missing, you will need to write out the
abbreviated chain as an actual C<NameChain> literal.  Note that the
C<auto_chains_from_names> pragma has no effect on C<NameChain> literal
bodies that don't comprise the payload portion of their parent literal,
such as with the imperative routine name composed into a C<boot_stmt>
literal; literal bodies in those positions will always be interpreted
according to C<NameChain> literal body syntax.

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::SeeAlso> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<perl@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2009, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
