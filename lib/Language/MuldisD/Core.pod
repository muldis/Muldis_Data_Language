=pod

=encoding utf8

=head1 NAME

Language::MuldisD::Core -
Muldis D core data types and operators

=head1 VERSION

This document is Language::MuldisD::Core version 0.8.0.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Language::MuldisD>; you should read that root document
before you read this one, which provides subservient details.

=head1 DESCRIPTION

Muldis D has a mandatory core set of system-defined (eternally available)
entities, which is referred to as the I<Muldis D core> or the I<core>; they
are the minimal entities that all Muldis D implementations need to provide;
they are mutually self-describing and are used to bootstrap the language;
any entities outside the core, called I<Muldis D extensions>, are
non-mandatory and are defined in terms of the core or each other, but the
reverse isn't true.

This current C<Core> document features the boolean, order, integer,
rational, bit string, and character string types and operators, plus the
tuple and relation type constructors (and quasi- variants) and operators,
plus the type system minimal and maximal types, plus the special types used
to define the system catalog, and the polymorphic operators that all types,
or some types including core types, have defined over them.

Extensions are in these other documents:
L<Language::MuldisD::Ext::Temporal>, L<Language::MuldisD::Ext::Spatial>.

=head1 TYPE SUMMARY

Following are all the data types and data type factories described in this
document, arranged in a type graph according to their proper sub|supertype
relationships:

    sys.Core.Universal.Universal

        sys.Core.Universal.Empty

        sys.Core.Scalar.Scalar
            sys.Core.Ordered.Ordered

                # The following are all regular ordered scalar types.

                sys.Core.Bool.Bool
                sys.Core.Order.Order
                sys.Core.Int.Int
                    sys.Core.Int.UInt
                        sys.Core.Int.PInt
                sys.Core.Rat.Rat
                    sys.Core.Rat.URat
                        sys.Core.Rat.PRat
                    sys.Core.Rat.BRat
                    sys.Core.Rat.DRat
                sys.Core.Blob.Blob
                    sys.Core.Blob.NEBlob
                sys.Core.Text.Text
                    sys.Core.Text.NEText

        # The following are all nonscalar type factories.

        sys.Core.Tuple.Tuple
            sys.Core.Tuple.Database

        sys.Core.Relation.Relation
            sys.Core.Relation.Set
                sys.Core.Relation.Maybe
            sys.Core.Relation.Seq
            sys.Core.Relation.Bag

        # The following are all quasi-nonscalar type factories.

        sys.Core.QuasiTuple.QuasiTuple

        sys.Core.QuasiRelation.QuasiRelation
            sys.Core.QuasiRelation.QuasiSet
                sys.Core.QuasiRelation.QuasiMaybe
            sys.Core.QuasiRelation.QuasiSeq
            sys.Core.QuasiRelation.QuasiBag

Note that C<sys.Core.Universal.Empty> is a proper subtype of all of the
other types in this graph, but every other type has only one immediate
supertype shown, and hence the graph of them is a simple hierarchy.

These system-defined subtypes are specific to defining the system catalog,
more or less:

    sys.Core.Universal.Universal

        sys.Core.Universal.Empty

        sys.Core.Scalar.Scalar

            # The following is actually a union over many scalar types.

            sys.Core.Cat.ScalarLiteral

            sys.Core.Ordered.Ordered

                # The following are all regular ordered scalar types.

                sys.Core.Cat.ShortName
                sys.Core.Cat.LongName

            # The following are all regular non-ordered scalar types.

            sys.Core.Cat.E_EK

        sys.Core.Tuple.Tuple

            # The following are all regular tuple types.

            sys.Core.Cat.Expr

        sys.Core.Relation.Relation

            # The following are all regular relation types.

            sys.Core.Cat.ShortNameMap
            sys.Core.Cat.BiDiShortNameMap

            sys.Core.Relation.Set

                # The following are all regular set types.

                sys.Core.Cat.SetOfShortName
                sys.Core.Cat.SetOfShortNameMap

These system-defined subtypes have also been defined for convenience, as
they are anticipated to be frequently used; in fact, most of them are used
as the declared parameter types of various core operators:

    sys.Core.Universal.Universal

        sys.Core.Universal.Empty

        sys.Core.Scalar.Scalar
            sys.Core.Ordered.Ordered
                sys.Core.Int.Int
                    sys.Core.Int.UInt
                        sys.Core.Int.PInt

                            # The following are all finite integer types.

                            sys.Core.Spec.PInt1_4
                            sys.Core.Spec.PInt2_36

        sys.Core.Relation.Relation
            sys.Core.Relation.Set

                # The following are all regular set types.

                sys.Core.Spec.SetOfBool
                sys.Core.Spec.SetOfInt
                sys.Core.Spec.SetOfRat
                sys.Core.Spec.SetOfBlob
                sys.Core.Spec.SetOfText

                # The following are all nonscalar type factories.

                sys.Core.Spec.SetOfRelation

                sys.Core.Relation.Maybe

                    # The following are all regular maybe types.

                    sys.Core.Spec.MaybeOfBool
                    sys.Core.Spec.MaybeOfInt
                    sys.Core.Spec.MaybeOfRat
                    sys.Core.Spec.MaybeOfBlob
                    sys.Core.Spec.MaybeOfText

            sys.Core.Relation.Seq

                # The following are all regular sequence types.

                sys.Core.Spec.SeqOfBool
                sys.Core.Spec.SeqOfInt
                sys.Core.Spec.SeqOfRat
                sys.Core.Spec.SeqOfBlob
                sys.Core.Spec.SeqOfText

            sys.Core.Relation.Bag

                # The following are all regular bag types.

                sys.Core.Spec.BagOfBool
                sys.Core.Spec.BagOfInt
                sys.Core.Spec.BagOfRat
                sys.Core.Spec.BagOfBlob
                sys.Core.Spec.BagOfText

                # The following are all nonscalar type factories.

                sys.Core.Spec.BagOfRelation

        sys.Core.QuasiRelation.QuasiRelation
            sys.Core.QuasiRelation.QuasiSet

                # The following are all quasi-nonscalar type factories.

                sys.Core.Spec.QuasiSetOfRelation

Note that, in later operator documentation, if you see something like
C<Foo{Bar}> as a declared type, it corresponds to
C<sys.Core.Spec.FooOfBar>.

=head1 SYSTEM-DEFINED CORE MAXIMAL AND MINIMAL DATA TYPES

These core data types are special and are the only Muldis D types that are
neither scalar nor nonscalar nor quasi-nonscalar types.  They are all
system-defined and it is impossible for users to define more types of this
nature.

=over

=item C<sys.Core.Universal.Universal>

The C<Universal> type is the maximal type of the entire Muldis D type
system, and contains every value that can possibly exist.  Every other type
is implicitly a proper subtype of C<Universal>, and C<Universal> is
implicitly a union type over all other types.  Its default value is
C<Bool:false>.  The cardinality of this type is infinity.

=item C<sys.Core.Universal.Empty>

The C<Empty> type is the minimal type of the entire Muldis D type system,
and is the only type that contains exactly zero values.  Every other type
is implicitly a proper supertype of C<Empty> and C<Empty> is implicitly an
intersection type over all other types.  It has no default value.  The
cardinality of this type is zero.

=back

=head1 SYSTEM-DEFINED CORE PSEUDO-TYPES

These are pseudo-types (that is, they aren't types at all) which represent
generic contexts that could accept a multiplicity of types, but are not the
same as contexts named after some actual types.  For example, they are used
as the declared parameter types of some dyadic polymorphic operators to
refer to, per instance, 2 given types that need to be compatible, but the
compatibility isn't simply defined by a "are any 2 subtypes of" such as is
true with most operators.  They are all system-defined and it is impossible
for users to define more types of this nature.

=over

=item C<sys.Core.Some.Universal>

Contexts defined by the C<Some.Universal> pseudo-type accept values of
potentially any type of C<Universal>.

=item C<sys.Core.Some.Ordered>

Contexts defined by the C<Some.Ordered> pseudo-type accept values of
potentially any type of C<Ordered>.

=back

=head1 SYSTEM-DEFINED CORE SCALAR DATA TYPES

These core scalar data types are the most fundamental Muldis D types.  Each
one has zero possreps, and hence has no named components that can be
referenced.  Concrete Muldis D provides a specific syntax per type to
select a value of one of these types, which does not look like a routine
invocation, but rather like a scalar literal in a typical programming
language; details of that syntax are not given here, but in
L<Language::MuldisD::Grammar>.  Abstract Muldis D as hosted in another
language will essentially use literals of corresponding host language
types, whatever they use for eg booleans and integers and character
strings, but tagged with extra meta-data if the host language is more
weakly typed or lacks one-to-one type correspondence; see
L<Language::MuldisD::PerlHosted> for a Perl-based example.

=over

=item C<sys.Core.Scalar.Scalar>

The C<Scalar> type is the maximal type of all Muldis D scalar types, and
contains every scalar value that can possibly exist.  Every other scalar
type is implicitly a proper subtype of C<Scalar>, and C<Scalar> is
implicitly a union type over all other scalar types.  Its default value is
C<Bool:false>.  The cardinality of this type is infinity.

=item C<sys.Core.Ordered.Ordered>

The C<Ordered> type is a proper subtype of C<Scalar> that is a proper
supertype of all scalar types that are considered ordered.  Any scalar
types which consider themselves ordered, which happens to include every
system-defined core scalar root type, will explicitly declare themselves as
subtypes of C<Ordered> in their type definitions; the definition of
C<Ordered> does not specify what other types it is a union over.  Its
default value is C<Bool:false>.  The cardinality of this type is infinity.

=item C<sys.Core.Bool.Bool>

A C<Bool> is an enumeration consisting of the 2 values C<Bool:false> and
C<Bool:true>.  It represents a truth value, and is the result type of any
C<is_equal> or C<is_not_equal> routine; it is the only essential scalar
data type of a B<D> language.  Its default and minimum value is
C<Bool:false>; its maximum value is C<Bool:true>.  The cardinality of this
type is 2.

=item C<sys.Core.Order.Order>

An C<Order> is an enumeration consisting of the 3 values C<Order:increase>,
C<Order:same>, C<Order:decrease>.  It is the result type of any C<compare>
routine that is used on 2 values of a C<sys.Core.Ordered.Ordered> subtype.
Its default value is C<Order:same>; its minimum and maximum values are,
respectively, C<Order:increase> and C<Order:decrease>.  The cardinality of
this type is 3.

=item C<sys.Core.Int.Int>

An C<Int> is a single exact integral number of any magnitude.  Its default
value is zero; its minimum and maximum values are conceptually infinities
and practically impossible.  The cardinality of this type is infinity; to
define a most-generalized finite C<Int> subtype, you must specify the 2
integer end-points of the inclusive range that all its values are in.

=item C<sys.Core.Int.UInt>

A C<UInt> (unsigned / non-negative integer) is a proper subtype of C<Int>
where all member values are greater than or equal to zero.  Its minimum
value is zero.

=item C<sys.Core.Int.PInt>

A C<PInt> (positive integer) is a proper subtype of C<UInt> where all
member values are greater than zero.  Its default and minimum value is 1.

=item C<sys.Core.Rat.Rat>

A C<Rat> is a single exact rational number of any magnitude.  It is
conceptually a I<numerator> (C<Int>) divided by a I<denominator> (C<PInt>).
Its default value is zero; its minimum and maximum values are conceptually
infinities and practically impossible.  The cardinality of this type is
infinity; to define a most-generalized finite C<Rat> subtype, you must
specify the greatest magnitude value denominator, plus the the 2 integer
end-points of the inclusive range of the value numerator.  Common subtypes
specify that all denominators are positive powers of a particular I<radix>
(C<PInt>), where the radix is usually either 2 or 10; types such as these
will easily map exactly to common human or physical numeric
representations, so they tend to perform better.

=item C<sys.Core.Rat.URat>

A C<URat> (unsigned / non-negative rational) is a proper subtype of C<Rat>
where all member values are greater than or equal to zero.  Its minimum
value is zero.

=item C<sys.Core.Rat.PRat>

A C<PRat> (positive integer) is a proper subtype of C<URat> where all
member values are greater than zero.  Its default value is 1.

=item C<sys.Core.Rat.BRat>

A C<BRat> (binary rational) is a proper subtype of C<Rat> where the radix
is 2; it is the best option to exactly represent rational numbers that are
conceptually binary or octal or hexadecimal.

=item C<sys.Core.Rat.DRat>

A C<DRat> (decimal rational) is a proper subtype of C<Rat> where the radix
is 10; it is the best option to exactly represent rational numbers that are
conceptually the decimal numbers that humans typically work with.

=item C<sys.Core.Blob.Blob>

A C<Blob> is an undifferentiated string of bits.  Its default and minimum
value is the empty string; its maximum value is an infinite-length string
and practically impossible.  The cardinality of this type is infinity; to
define a most-generalized finite C<Blob> subtype, you must specify a
maximum length in bits that the subtype's strings are.

=item C<sys.Core.Blob.NEBlob>

A C<NEBlob> (non-empty blob) is a proper subtype of C<Blob> where its
length in bits must be at least 1; it can be any C<Blob> except for the
empty string.  Its default and minimum value is a single zero bit.

=item C<sys.Core.Text.Text>

A C<Text> is a string of characters.  Its default and minimum value is the
empty string; its maximum value is an infinite-length string and
practically impossible.  Note that there is only one system-defined
character repertoire for C<Text> types, which is the newest Unicode
repertoire (5.0.0).  The cardinality of this type is infinity; to define a
most-generalized finite C<Text> subtype, you must specify a maximum length
in characters (that is, eg, in NFC graphemes) that the subtype's strings
are.

=item C<sys.Core.Text.NEText>

A C<NEText> (non-empty text) is a proper subtype of C<Text> where its
length in characters must be more than zero; it can be any C<Text> except
for the empty string.  Its default value is a single "space" character; its
minimum value has one character, but which character that is depends on the
default or current collation.

=back

=head1 SYSTEM-DEFINED CORE NONSCALAR PARAMETERIZED DATA TYPES

These are only called nonscalar data types in a loose sense, because by
themselves they are incomplete type definitions.  Actual nonscalar data
type definitions are derived from these by supplying the balance of the
type definitions, such as what their attributes are and/or what their
attribute types are.  Associated with these incomplete type definitions are
a set of system-defined routines that can be applied to values of any
actual nonscalar types derived from them; such are called I<generic
nonscalar operators>.  In the Muldis D type system, these incomplete
nonscalar types are defined as union types over all actual types derived
from them, and are proper supertypes of said.

Some actual nonscalar data types are system-defined, for use in defining
the Muldis D system catalog / meta-model (see further below in the current
document), and some others are system-defined for convenience since they
are the types of many core operators (see further below in the current
document), but all other actual nonscalar data types are user-defined.
Users can also define their own incomplete nonscalar data types that are
tuple or relation types.

=over

=item C<sys.Core.Tuple.Tuple>

The C<Tuple> type is the maximal type of all Muldis D tuple (nonscalar)
types, and contains every tuple value that could possibly exist.  A
C<Tuple> is an unordered heterogeneous collection of 0..N named attributes
(the count of attributes being its I<degree>), where all attribute names
are mutually distinct, and each attribute may be of distinct types; the
mapping of a tuple's attribute names and their declared data types is
called the tuple's I<heading>.  Its default value is the sole value of the
sole tuple data type that has zero attributes.  The cardinality of this
type is equal to the product of the number of permutations drawable from
the values of each of its attributes' declared data types; for a C<Tuple>
subtype to be finite, all of its attribute types must be.

=item C<sys.Core.Tuple.Database>

A C<Database> is a proper subtype of C<Tuple> where all of its attributes
are each of relation types or of database types (the leaves of this
recursion are all relation types); it is otherwise the same.

=item C<sys.Core.Relation.Relation>

The C<Relation> type is the maximal type of all Muldis D relation
(nonscalar) types, and contains every relation value that could possibly
exist.  A C<Relation> is analogous to a set of 0..N tuples where all tuples
have the same heading (the degrees match and all attribute names and
corresponding declared data types match), but that a C<Relation> data type
still has its own corresponding heading (attribute names and declared data
types) even when it consists of zero tuples.  Its default value is the
zero-tuple value of the sole relation data type that has zero attributes.
Matters of its cardinality are generally the same as for C<Tuple>.  A
relation data type can also have (unique) keys each defined over a subset
of its attributes, which constrain its set of values relative to there
being no explicit keys, but having the keys won't turn an infinite relation
type into a finite one.

=item C<sys.Core.Relation.Set>

A C<Set> is a proper subtype of C<Relation> that has 1 attribute, and its
name is C<value>; it can be of any declared type.  A C<Set> subtype is
normally used by any system-defined N-ary operators where the order of
their argument elements or result is not significant, and that duplicate
values are not significant.  Its default value has zero tuples.

=item C<sys.Core.Relation.Maybe>

A C<Maybe> is a proper subtype of C<Set> that may have at most one element;
that is, it is a unary C<Relation> with a nullary key.  Operators that work
specifically with C<Maybe> subtypes can provide a syntactic shorthand for
working with sparse data; so Muldis D has something which is conceptually
close to SQL's nullable types without actually having 3-valued logic; it
would probably be convenient for code that round-trips SQL by way of Muldis
D to use the C<Maybe> type.  Its default value has zero tuples.

=item C<sys.Core.Relation.Seq>

An C<Seq> is a proper subtype of C<Relation> that has 2 attributes, and
their names are C<index> and C<value>, where C<index> is a unary key and
its declared type is an C<UInt> subtype (C<value> can be non-unique and of
any declared type).  A Seq is considered dense, and all C<index> values in
one are numbered consecutively from 0 to 1 less than the count of tuples,
like array indices in typical programming languages.  A C<Seq> subtype is
normally used by any system-defined N-ary operators where the order of
their argument elements or result is significant (and duplicate values are
significant); specifically, C<index> defines an explicit ordering for
C<values>.  Its default value has zero tuples.

=item C<sys.Core.Relation.Bag>

A C<Bag> is a proper subtype of C<Relation> that has 2 attributes, and
their names are C<value> and C<count>, where C<value> is a unary key (that
can have any declared type) and C<count> is a C<PInt> subtype.  A C<Bag>
subtype is normally used by any system-defined N-ary operators where the
order of their argument elements or result is not significant, but that
duplicate values are significant; specifically, C<count> defines an
explicit count of occurrences for C<values>.  Its default value has zero
tuples.

=back

=head1 SYSTEM-DEFINED CORE QUASI-NONSCALAR PARAMETERIZED DATA TYPES

These quasi-nonscalar incomplete data type definitions correspond to their
similarly-named (differing only by the C<Quasi>) nonscalar data types, and
their use is intended to be limited to the few situations where the
corresponding nonscalar data types can't be used.  It should be noted in
particular that there is no "QuasiDatabase" type, since all normal data or
catalog databases should be composed of normal relations only; but all of
the other nonscalar incomplete types have counterparts here.

=over

=item C<sys.Core.QuasiTuple.QuasiTuple>

A C<QuasiTuple> is like a C<Tuple> but that the declared types of its
attributes can be anything at all.  Its cardinality is infinite.

=item C<sys.Core.QuasiRelation.QuasiRelation>

A C<QuasiRelation> is like a C<Relation> but that the declared types of its
attributes can be anything at all.  Its cardinality is infinite.

=item C<sys.Core.QuasiRelation.QuasiSet>

A C<QuasiSet> is a proper subtype of C<QuasiRelation> in the corresponding
manner to C<Set> being a proper subtype of C<Relation>.  Its cardinality is
infinite.

=item C<sys.Core.QuasiRelation.QuasiMaybe>

A C<QuasiMaybe> is a proper subtype of C<QuasiRelation> in the
corresponding manner to C<Maybe> being a proper subtype of C<Relation>.
Its cardinality is infinite.

=item C<sys.Core.QuasiRelation.QuasiSeq>

A C<QuasiSeq> is a proper subtype of C<QuasiRelation> in the corresponding
manner to C<Seq> being a proper subtype of C<Relation>.  Its cardinality is
infinite.

=item C<sys.Core.QuasiRelation.QuasiBag>

A C<QuasiBag> is a proper subtype of C<QuasiRelation> in the corresponding
manner to C<Bag> being a proper subtype of C<Relation>.  Its cardinality is
infinite.

=back

=head1 SYSTEM-DEFINED CORE CATALOG SCALAR DATA TYPES

These core scalar data types are more special-purpose in nature and are
intended for use in defining or working with the system catalog, which is
mainly composed of nonscalar types built using these.

=head2 C<sys.Core.Cat.ScalarLiteral>

A C<Cat.ScalarLiteral> is a union type over all the system-defined scalar
types that are allowed to be used directly as hard-coded literal values in
Muldis D expressions; 'directly' meaning not by way of explicitly invoking
a selector function.  Generally speaking, this union type includes all of
the core scalar types that aren't themselves defined as union types.  The
full list that C<ScalarLiteral> unions is: C<Bool>, C<Order>, C<Int>,
C<Rat>, C<Blob>, C<Text>, C<Cat.ShortName>, C<Cat.LongName>, C<Cat.E_EK>,
...

=head2 C<sys.Core.Cat.ShortName>

A C<Cat.ShortName> is a canonical name for some DBMS entities (others use
C<Cat.LongName>), such as the declared names of attributes of scalar
possreps or collection types, and for the declared names of routine
parameters, and for the invocation names of the same.  It is the same as
C<Text> in all ways but that it is specifically intended for use in naming
DBMS entities rather than being normal data.

=head2 C<sys.Core.Cat.LongName>

A C<Cat.LongName> is a canonical name for some DBMS entities (others use
C<Cat.ShortName>), such as the invocation names of types, routines, and
variables, and it is typically used for the declared names of the same.  A
C<Cat.LongName> consists of a sequence (1..N) of C<Cat.ShortName>, the
elements being ordered from greatest to least significance.  Its default
value is a single element that is the default value of C<Cat.ShortName>,
the empty string.

=head2 C<sys.Core.Cat.E_EK>

A C<Cat.E_EK> (expression kind) is an enumeration consisting of the 8
values C<Cat.E_EK:default> (default value of expression's type),
C<Cat.E_EK:(scalar|tuple|relation|quasi_tuple|quasi_relation)> (hard-coded
literal scalar|tuple|relation|quasi-tuple|quasi-relation value),
C<Cat.E_EK:param> (value of expression-containing function parameter),
C<Cat.E_EK:func> (result of function invocation, or inlining of function
body).  Its default value is C<Cat.E_EK:scalar>.

=head1 SYSTEM-DEFINED CORE CATALOG TUPLE DATA TYPES

These tuple data types, essentially all of the system-defined tuple types
are special-purpose in nature and are intended for use in defining or
working with the system catalog.  They are all completely defined types.

I<To keep things simpler for now, most constraint definitions for these
types are missing, or just defined informally.>

=head2 C<sys.Core.Cat.Expr>

A C<Cat.Expr> is a C<Tuple>.  It specifies a named expression node, which
is the majority component of functional Muldis D code.  All arbitrarily
complex Muldis D expression trees, including relational queries, are
composed of just C<Cat.Expr>, either directly, or indirectly by way of
function invocations, as each function body is itself composed entirely of
a single expression tree.  Only functions may contain C<Cat.Expr>, so for
any procedures that would conceptually include them, those portions of the
procedures need to be separated out and encapsulated by named functions.

A C<Cat.Expr> has these 8 attributes:

=over

=item C<name> - C<Cat.ShortName>

This is the declared name of the expression node; other Muldis D code that
is composing this expression node into their own definitions would
reference it with this name.

=item C<type> - C<Cat.LongName>

This is the declared result data type of the expression node.  If the
expression node represents a literal value, this is often necessary for
properly interpreting the details of that literal, particularly for
literals that are not scalar.  Otherwise, although the result type of an
expression can sometimes be inferred from context, such as from the result
type of a function it is an invocation of, this redundancy helps make
static analysis of Muldis D code easier, so it is easier to validate and
optimize in isolation from the other routines it interacts with.  Moreover,
this type declaration provides a terse way to use the C<treat> function
frequently in code, so that the programmer and compiler knows that some
generic routines are actually supposed to be returning a subtype of their
normal result types.

=item C<kind> - C<Cat.E_EK>

This is the declared kind of expression that this node is; it says how to
interpret the rest of the attributes and/or which of them have significant
values.

=item C<scal_lit> - C<Cat.ScalarLiteral>

Iff C<kind> is C<Cat.E_EK:scalar>, then the expression represents a
hard-coded scalar literal of one of a certain collection of system-defined
core scalar types (or subtype thereof), and this is that literal value.

=item C<coll_lit> - C<Cat.SetOfShortNameMap>

Iff C<kind> is C<Cat.E_EK:(|quasi_)(tuple|relation)>, then the expression
represents a collection literal, and these are the values of its
components.  Each element defines one tuple, and each sub-element of that
element defines one attribute value for one tuple, with the sub-element
C<key> matching the attribute name, and the sub-element C<value> naming
another local C<Cat.Expr> which defines the value.  The value of
C<coll_lit> defines exactly one tuple when C<kind> specifies a tuple or
quasi-tuple, and it defines 0..N tuples when C<kind> specifies a relation
or quasi-relation.

=item C<param> - C<Cat.ShortName>

Iff C<kind> is C<Cat.E_EK:param>, then the expression represents the value
of the containing function's parameter which this names.

=item C<func> - C<Cat.LongName>

Iff C<kind> is C<Cat.E_EK:func>, then the expression represents the result
of invoking a named function with specific arguments, and this the name of
that function.

=item C<func_args> - C<Cat.ShortNameMap>

Iff C<func> is used, then these are the arguments for the function
invocation.  Each element defines one argument value, with the element
C<key> matching the parameter name, and the element C<value> naming another
local C<Expr> which defines the value.

=back

Note that whenever a C<Cat.Expr> attribute isn't significant, given the
expression type, and should be ignored, its value is the default for its
type.

The default value of C<Cat.Expr> represents the literal scalar value
C<Bool:false>.

=head1 SYSTEM-DEFINED CORE CATALOG RELATION DATA TYPES

These relation data types, essentially all of the system-defined relation
types are special-purpose in nature and are intended for use in defining or
working with the system catalog.  They are all completely defined types.

I<To keep things simpler for now, most constraint definitions for these
types are missing, or just defined informally.>

=head2 C<sys.Core.Cat.ShortNameMap>

A C<Cat.ShortNameMap> specifies a map of short entity names to other short
entity names.  It is a binary C<Relation> whose 2 attributes are named
C<key> and C<value>, and both attributes have declared types of
C<Cat.ShortName>; the C<key> attribute is a unary key.  Its default value
has zero tuples.

=head2 C<sys.Core.Cat.BiDiShortNameMap>

A C<Cat.BiDiShortNameMap> is a proper subtype of C<Cat.ShortNameMap> where
its C<value> attribute is also a unary key.  It is used as a specification
for how to rename attributes of a relation.

=head2 C<sys.Core.Cat.SetOfShortName>

A C<Cat.SetOfShortName> is a C<(Set)> whose C<value> attribute has a
declared type of C<Cat.ShortName>.

=head2 C<sys.Core.Cat.SetOfShortNameMap>

A C<Cat.SetOfShortNameMap> is a C<(Set)> whose C<value> attribute has a
declared type of C<Cat.ShortNameMap>.

=head1 SYSTEM-DEFINED CORE SPECIALIZED SUBTYPES

These types are proper subtypes of other core types, and they are
system-defined for convenience, as they are anticipated to be frequently
used; in fact, most of them are used as the declared parameter types of
various core operators.

=over

=item C<sys.Core.Spec.PInt1_4>

A C<PInt1_4> is a proper subtype of C<PInt> where all member values are
between 1 and 4.  Its maximum value is 4.  The cardinality of this type is
4.

=item C<sys.Core.Spec.PInt2_36>

A C<PInt2_36> is a proper subtype of C<PInt> where all member values are
between 2 and 36.  (The significance of the number 36 is 10 digits plus 26
letters.)  Its default and minimum value is 2; its maximum value is 36.
The cardinality of this type is 35.

=item C<sys.Core.Spec.(Set|Maybe|Seq|Bag)Of(Bool|Int|Rat|Blob|Text)>

A C<(Set|Maybe|Seq|Bag)Of(Bool|Int|Rat|Blob|Text)> is a completely defined
proper subtype of C<(Set|Maybe|Seq|Bag)> whose C<value> attribute has a
declared type of a C<(Bool|Int|Rat|Blob|Text)> subtype.

=item C<sys.Core.Spec.(Set|Bag)OfRelation>

A C<(Set|Bag)OfRelation> is an incompletely defined proper subtype of
C<Set|Bag> whose C<value> attribute has a declared type of a C<Relation>
subtype.

=item C<sys.Core.Spec.QuasiSetOfRelation>

A C<QuasiSetOfRelation> is an incompletely defined proper subtype of
C<QuasiSet> whose C<value> attribute has a declared type of C<Relation>;
this is the parameter type of the N-ary relational C<join> operator.

=back

=head1 SYSTEM-DEFINED GENERIC UNIVERSAL FUNCTIONS

These functions are applicable to values of any data type at all.

=over

=item C<sys.Core.Universal.is_equal of Bool (Some.Universal $v1,
Some.Universal $v2)>

This function results in C<Bool:true> iff its 2 arguments are exactly the
same value, and C<Bool:false> otherwise.  This function's arguments must be
of compatible declared types; in this case, 2 declared types are compatible
iff at least one of the following is true: 1. they are both subtypes of a
common scalar root type; 2. they are both subtypes of a common
non-incomplete tuple or relation type, that is they essentially have the
same headings; 3. at least one type is a generic (eg-C<Universal>) or
incomplete (eg-C<Seq>) type, and it is a supertype of the other.  This
function is commutative.

=item C<sys.Core.Universal.is_not_equal of Bool (Some.Universal $v1,
Some.Universal $v2)>

This function is exactly the same as C<sys.Core.Universal.is_equal> except
that it results in the opposite boolean value when given the same
arguments.

=item C<sys.Core.Universal.is_value_of_type of Bool (Cat.LongName $type,
Universal $v)>

This function results in C<Bool:true> iff the value of its C<$v> argument
is a member of the data type whose name is given in the C<$type> argument,
and C<Bool:false> otherwise.  As trivial cases, this function always
results in C<Bool:true> if the named type is C<Universal>, and
C<Bool:false> if it is C<Empty>.  This function will fail if the named type
doesn't exist in the virtual machine.

=item C<sys.Core.Universal.treat of Some.Universal (Cat.LongName $as,
Some.Universal $v)>

This function results in the value of its C<$v> argument, but that the
declared type of the result is the not-C<Empty> data type whose name is
given in the C<$as> argument.  This function will fail if the named type
doesn't exist in the virtual machine, or if C<$v> isn't a member of the
named type.  The purpose of C<treat> is to permit taking values from a
context having a more generic declared type, and using them in a context
having a more specific declared type; such an action would otherwise be
blocked at compile time due to a type-mismatch error; C<treat> causes the
type-mismatch validation, and possible failure, to happen at runtime
instead, on the actual value rather than declared value.  For example, if
you are storing an C<Int> value in a C<Scalar>-typed variable, using
C<treat> will cause the compiler to let you use that variable as an
argument to C<Int.sum>, which it otherwise wouldn't.

=item C<sys.Core.Universal.default of Some.Universal (Cat.LongName $of)>

This function results in the default value of the not-C<Empty> data type
whose name is given in the C<$of> argument, and the declared type of the
result is that same type.  This function will fail if the named type
doesn't exist in the virtual machine, either at compile or runtime
depending whether the type is in the system or user namespace.  This
function is conceptually implicitly used to provide default values for
variables, so they always hold valid values of their declared type.

=back

=head1 SYSTEM-DEFINED GENERIC ORDERED FUNCTIONS

These functions are applicable to values of any data type which is a
subtype of C<Ordered>.  They provide a common syntax for sort-related
functionality, though technically every type having these functions is
re-implementing its own version.  If values of an ordered data type can
conceivably be sorted using multiple criteria (such as different text
collations), then these functions just represent the default criteria; any
additional criteria are represented by additional functions declared for
just the types they apply to.

=over

=item C<sys.Core.Ordered.compare of Order (Some.Ordered $v1, Some.Ordered
$v2)>

This function results in C<Order:same> iff its 2 arguments are exactly the
same value, and otherwise it results in C<Order:increase> if the value of
the C<$v2> argument is considered to be an increase (as defined by the
type) over the value of the C<$v1> argument, and otherwise it results in
C<Order:decrease> as the reverse of the last condition would be true.  This
function's arguments must be of compatible declared types; in this case, 2
declared types are compatible iff they are both subtypes of a common scalar
type that declares itself an C<Ordered> subtype.  Note that C<compare> is
considered the only fundamental ordered-specific operator, and all others
are defined over it.

=item C<sys.Core.Ordered.reverse_compare of Order (Some.Ordered $v1,
Some.Ordered $v2)>

This function is exactly the same as C<sys.Core.Ordered.compare> except
that it results in the reverse value when given the same arguments.  It is
a short-hand for applying C<sys.Core.Order.reverse> to the result of
C<sys.Core.Ordered.compare> with the same arguments.

=item C<sys.Core.Ordered.is_increase of Bool (Some.Ordered $v1,
Some.Ordered $v2)>

This function results in C<Bool:true> iff C<sys.Core.Ordered.compare> would
result in C<Order:increase> when given the same arguments, and
C<Bool:false> otherwise.

=item C<sys.Core.Ordered.is_decrease of Bool (Some.Ordered $v1,
Some.Ordered $v2)>

This function results in C<Bool:true> iff C<sys.Core.Ordered.compare> would
result in C<Order:decrease> when given the same arguments, and
C<Bool:false> otherwise.

=item C<sys.Core.Ordered.min of Some.Ordered (Set{Some.Ordered} $topic)>

This function is a reduction operator that recursively takes each pair of
its N input element values and picks the minimum of the 2 (a process which
is both commutative and associative) until just one is left, which is the
function's result.  If C<$topic> has zero values, then C<min> results in
the result type's concept of positive infinity, which is the identity value
for I<min>.  This function will fail on a C<$topic> of zero values if the
result type's concept of positive infinity is impossible or impractically
large to represent, such as with the infinite C<Text> type.

=item C<sys.Core.Ordered.max of Some.Ordered (Set{Some.Ordered} $topic)>

This function is exactly the same as C<sys.Core.Ordered.min> except that it
results in the maximum input element value rather than the minimum one, and
its identity value is the result type's concept of negative infinity.

=item C<sys.Core.Ordered.maybe_min of Maybe{Some.Ordered}
(Set{Some.Ordered} $topic)>

This function is exactly the same as C<sys.Core.Ordered.min> except that it
results in a C<Maybe> of what is otherwise the result type, and that result
has zero elements if the argument has zero elements.

=item C<sys.Core.Ordered.maybe_max of Maybe{Some.Ordered}
(Set{Some.Ordered} $topic)>

This function is to C<sys.Core.Ordered.max> as
C<sys.Core.Ordered.maybe_min> is to C<sys.Core.Ordered.min>.

=back

=head1 SYSTEM-DEFINED CORE SCALAR FUNCTIONS

These functions are applicable to just one or more specific system-defined
core scalar data type.

=head2 Functions for sys.Core.Bool.Bool

These functions select values of the C<Bool> enumeration.

=over

=item C<sys.Core.Bool.(false|true) of Bool ()>

This selector function results in the C<Bool:(false|true)> value.

=back

These functions implement commonly used boolean operations.

=over

=item C<sys.Core.Bool.not of Bool (Bool $topic)>

This function results in the logical I<not> of its argument.

=item C<sys.Core.Bool.and of Bool (Set{Bool} $topic)>

This function is a reduction operator that recursively takes each pair of
its N input element values and does a logical I<and> (which is both
commutative and associative) on them until just one is left, which is the
function's result.  If C<$topic> has zero values, then C<and> results in
C<Bool:true>, which is the identity value for logical I<and>.

=item C<sys.Core.Bool.or of Bool (Set{Bool} $topic)>

This function is a reduction operator that recursively takes each pair of
its N input element values and does a logical inclusive-or (which is both
commutative and associative) on them until just one is left, which is the
function's result.  If C<$topic> has zero values, then C<or> results in
C<Bool:false>, which is the identity value for logical inclusive-or.

=item C<sys.Core.Bool.xor of Bool (Bag{Bool} $topic)>

This function is a reduction operator that recursively takes each pair of
its N input element values and does a logical exclusive-or (which is both
commutative and associative) on them until just one is left, which is the
function's result.  If C<$topic> has zero values, then C<xor> results in
C<Bool:false>, which is the identity value for logical exclusive-or.

=back

=head2 Functions for sys.Core.Order.Order

These functions select values of the C<Order> enumeration.

=over

=item C<sys.Core.Order.(increase|same|decrease) of Order ()>

This selector function results in the C<Order:(increase|same|decrease)>
value.

=back

These functions implement commonly used order-enumeration operations.

=over

=item C<sys.Core.Order.reverse of Order (Order $topic)>

This function results in the reverse value of its argument; an
C<Order:increase> or C<Order:decrease> argument results in the other one of
the two; an C<Order:same> argument results in C<Order:same>.

=back

=head2 Functions for sys.Core.Int.Int

These functions implement commonly used integer numeric operations.

=over

=item C<sys.Core.Int.abs of UInt (Int $topic)>

This function results in the absolute value of its argument.

=item C<sys.Core.Int.sum of Int (Bag{Int} $addends)>

This function results in the sum of the N element values of its argument;
it is a reduction operator that recursively takes each pair of input values
and adds (which is both commutative and associative) them together until
just one is left, which is the result.  If C<$addends> has zero values,
then C<sum> results in the integer zero, which is the identity value for
addition.

=item C<sys.Core.Int.difference of Int (Int $minuend, Int $subtrahend)>

This function results in the difference when its C<$subtrahend> argument is
subtracted from its C<$minuend> argument.

=item C<sys.Core.Int.product of Int (Bag{Int} $factors)>

This function results in the product of the N element values of its
argument; it is a reduction operator that recursively takes each pair of
input values and multiplies (which is both commutative and associative)
them together until just one is left, which is the result.  If C<$factors>
has zero values, then C<product> results in the integer 1, which is the
identity value for multiplication.

=item C<sys.Core.Int.quotient of Int (Int $dividend, Int $divisor)>

This function results in the quotient when its C<$dividend> argument is
divided by its C<$divisor> argument using integer division.  This function
will fail if C<$divisor> is zero.

=item C<sys.Core.Int.remainder of UInt (Int $dividend, Int $divisor)>

This function results in the remainder when its C<$dividend> argument is
divided by its C<$divisor> argument using integer division.  This function
will fail if C<$divisor> is zero.

=item C<sys.Core.Int.maybe_quotient of Maybe{Int} (Int $dividend, Int
$divisor)>

This function is exactly the same as C<sys.Core.Int.quotient> except that
it results in a C<Maybe> of what is otherwise the result, and that result
has zero elements if C<$divisor> is zero.

=item C<sys.Core.Int.maybe_remainder of Maybe{UInt} (Int $dividend, Int
$divisor)>

This function is exactly the same as C<sys.Core.Int.remainder> except that
it results in a C<Maybe> of what is otherwise the result, and that result
has zero elements if C<$divisor> is zero.

=item C<sys.Core.Int.range of Int (Set{Int} $topic)>

This function results in the difference between the lowest and highest
element values of its argument.  If C<$topic> has zero values, then
C<range> results in the integer zero.

=item C<sys.Core.Int.median of Set{Int} (Bag{Int} $topic)>

This function results in the 1 or 2 median values of the N element values
of its argument; they are returned as a set.  It is equivalent to first
arranging the input values from least to greatest, and then taking the
single middle value, if the count of input values is odd, or taking the 2
middle values, if the count of input values is even (but if the 2 middle
values are the same value, the output has one element).  If C<$topic> has
zero values, then the result set is empty.

=item C<sys.Core.Int.mode of Set{Int} (Bag{Int} $topic)>

This function results in the mode of the N element values of its argument;
it is the set of values that appear the most often as input elements, and
all have the same count of occurrances.  As a trivial case, if all input
elements have the same count of occurrances, then they will all be in the
output.  If C<$topic> has zero values, then the result set is empty.

=item C<sys.Core.Int.power of Int (Int $radix, UInt $exponent)>

This function results in its C<$radix> argument taken to the power of its
(unsigned integer) C<$exponent> argument.  This function will fail if
C<$radix> and C<$exponent> are both zero.

=back

These functions convert between C<Int> values and canonically formatted
representations of integers as character strings.

=over

=item C<sys.Core.Int.Int_from_NEText of Int (NEText $text, PInt2_36
$radix)>

This selector function results in the C<Int> value that its C<$text>
argument maps to when the whole character string is evaluated as a
base-C<$radix> integer.  Extending the typical formats of [base-2, base-8,
base-10, base-16], this function supports base-2 through base-36; to get
the latter, the characters 0-9 and A-Z represent values in 0-35.  This
function will fail if C<$text> can't be mapped as specified.

=item C<sys.Core.Int.NEText_from_Int of NEText (Int $int, PInt2_36 $radix)>

This selector function results in the C<NEText> value where its C<$int>
argument is formatted as a base-C<$radix> integer.

=back

These functions convert between C<Int> values and canonically formatted
representations of integers as binary strings.  I<Conjecture: These may not
actually be useful, and perhaps only operators that take an argument
specifying a fixed-length field size, with big and little endian versions,
would be appropriate instead.  Or maybe both kinds are necessary.>

=over

=item C<sys.Core.Int.Int_from_Blob_S_VBE of Int (NEBlob $blob)>

This selector function results in the C<Int> value that its C<$blob>
argument maps to when the whole bit string is treated literally as a
variable-length binary (two's complement) signed integer of 1 or more bits
in length.  The first bit is taken as the sign bit, and any other bits
provide greater precision than the -1 thru 0 range.  The bit string is
assumed to be big-endian, since it may not be possible to use little-endian
in situations where the bit length isn't a multiple of 8.

=item C<sys.Core.Int.Blob_S_VBE_from_Int of NEBlob (Int $int)>

This selector function results in the C<Blob> value where its C<$int>
argument is formatted as a variable-length binary (two's complement) signed
integer of 1 or more bits in length; the smallest number of bits necessary
to store C<$int> is used.

=item C<sys.Core.Int.Int_from_Blob_U_VBE of UInt (NEBlob $blob)>

This function is the same as C<sys.Core.Int.Int_from_Blob_S_VBE> but that
it does unsigned integers.

=item C<sys.Core.Int.Blob_U_VBE_from_Int of UInt (NEBlob $blob)>

This function is the same as C<sys.Core.Int.Blob_S_VBE_from_Int> but that
it does unsigned integers.

=back

=head2 Functions for sys.Core.Rat.Rat

These functions are essentially selectors and attribute extractors for the
conceptual possrep of a rational in terms of an integral numerator plus
denominator.

=over

=item C<sys.Core.Rat.Rat_from_Int_pair of Rat (Int $numerator, PInt
$denominator)>

This selector function results in the C<Rat> value that its C<$numerator>
and C<$denominator> arguments map to when collectively interpreted in the
appropriate fashion, as if there were a possrep for the C<Rat> type that
was composed of such 2 attributes, but keeping in mind that multiple
distinct argument pairs can map to each same C<Rat> value, since the
arguments don't have to be a canonical pair.

=item C<sys.Core.Rat.numerator of Int (Rat $topic)>

This function results in the canonical numerator of its argument, which
assumes said rational is represented with the pair of smallest possible
integers.

=item C<sys.Core.Rat.denominator of PInt (Rat $topic)>

This function results in the canonical denominator of its argument, which
assumes said rational is represented with the pair of smallest possible
integers.

=back

These functions implement commonly used rational numeric operations.

=over

=item C<sys.Core.Rat.abs of URat (Rat $topic)>

This function results in the absolute value of its argument.

=item C<sys.Core.Rat.sum of Rat (Bag{Rat} $addends)>

This function results in the sum of the N element values of its argument;
it is a reduction operator that recursively takes each pair of input values
and adds (which is both commutative and associative) them together until
just one is left, which is the result.  If C<$addends> has zero values,
then C<sum> results in the rational zero, which is the identity value for
addition.

=item C<sys.Core.Rat.difference of Rat (Rat $minuend, Rat $subtrahend)>

This function results in the difference when its C<$subtrahend> argument is
subtracted from its C<$minuend> argument.

=item C<sys.Core.Rat.product of Rat (Bag{Rat} $factors)>

This function results in the product of the N element values of its
argument; it is a reduction operator that recursively takes each pair of
input values and multiplies (which is both commutative and associative)
them together until just one is left, which is the result.  If C<$factors>
has zero values, then C<product> results in the rational 1, which is the
identity value for multiplication.

=item C<sys.Core.Rat.quotient of Rat (Rat $dividend, Rat $divisor)>

This function results in the quotient when its C<$dividend> argument is
divided by its C<$divisor> argument using rational division.  This function
will fail if C<$divisor> is zero.

=item C<sys.Core.Rat.maybe_quotient of Maybe{Rat} (Rat $dividend, Rat
$divisor)>

This function is exactly the same as C<sys.Core.Rat.quotient> except that
it results in a C<Maybe> of what is otherwise the result, and that result
has zero elements if C<$divisor> is zero.

=item C<sys.Core.Rat.range of Rat (Set{Rat} $topic)>

This function results in the difference between the lowest and highest
element values of its argument.  If C<$topic> has zero values, then
C<range> results in the rational zero.

=item C<sys.Core.Rat.mean of Rat (Bag{Rat} $topic)>

This function results in the mean or arithmetic average of the N element
values of its argument.  It is equivalent to first taking the sum of the
input values, and dividing that sum by the count of the input values.  If
C<$topic> has zero values, then this function will fail.

=item C<sys.Core.Rat.maybe_mean of Maybe{Rat} (Bag{Rat} $topic)>

This function is exactly the same as C<sys.Core.Rat.mean> except that it
results in a C<Maybe> of what is otherwise the result, and that result has
zero elements if C<$topic> has zero values.

=item C<sys.Core.Rat.median of Set{Rat} (Bag{Rat} $topic)>

This function results in the 1 or 2 median values of the N element values
of its argument; they are returned as a set.  It is equivalent to first
arranging the input values from least to greatest, and then taking the
single middle value, if the count of input values is odd, or taking the 2
middle values, if the count of input values is even (but if the 2 middle
values are the same value, the output has one element).  If C<$topic> has
zero values, then the result set is empty.

=item C<sys.Core.Rat.mean_of_median of Rat (Bag{Rat} $topic)>

This function is a wrapper over C<sys.Core.Rat.median> that will return the
mean of its result elements; it will fail if there are zero elements.

=item C<sys.Core.Rat.mode of Set{Rat} (Bag{Rat} $topic)>

This function results in the mode of the N element values of its argument;
it is the set of values that appear the most often as input elements, and
all have the same count of occurrances.  As a trivial case, if all input
elements have the same count of occurrances, then they will all be in the
output.  If C<$topic> has zero values, then the result set is empty.

=item C<sys.Core.Rat.power of PRat (PRat $radix, Rat $exponent)>

This function results in its (positive rational) C<$radix> argument taken
to the power of its C<$exponent> argument.  Note that, while this function
might conceptually have multiple real number results for some negative
C<$exponent>, it will always only return the one that is positive.

=item C<sys.Core.Rat.log of Rat (PRat $topic, PRat $radix, PInt
$rebase_radix, PInt $rebase_max_denom, Cat.RoundMeth $rebase_round)>

This function results in the logarithm of its C<$topic> argument to the
base given in its (positive rational) C<$radix> argument.  Since the result
would be an irrational number in the general case, the additional 3
C<$rebase_\w+> parameters specify how to coerce the conceptual result into
a rational number that is the actual result; see also the similarly named
parameters of the C<sys.Core.Rat.rebase> function.

=item C<sys.Core.Rat.natural_power of PRat (Rat $exponent, PInt
$rebase_radix, PInt $rebase_max_denom, Cat.RoundMeth $rebase_round)>

This function results in the special mathematical constant I<e> (which is
the base of the natural logarithm) taken to the power of its C<$exponent>
argument.  The 3 C<$rebase_\w+> parameters are as per C<log>.

=item C<sys.Core.Rat.natural_log of Rat (PRat $topic, PInt $rebase_radix,
PInt $rebase_max_denom, Cat.RoundMeth $rebase_round)>

This function results in the natural logarithm of its C<$topic> argument.
The 3 C<$rebase_\w+> parameters are as per C<log>.

=back

These functions convert between C<Rat> values and canonically formatted
representations of rationals as character strings.

=over

=item C<sys.Core.Rat.Rat_from_NEText of Rat (NEText $text, PInt2_36
$radix)>

This selector function results in the C<Rat> value that its C<$text>
argument maps to when the whole character string is evaluated as a
base-C<$radix> rational.  Extending the typical formats of [base-2, base-8,
base-10, base-16], this function supports base-2 through base-36; to get
the latter, the characters 0-9 and A-Z represent values in 0-35.  This
function will fail if C<$text> can't be mapped as specified.

=item C<sys.Core.Rat.NEText_from_Rat of NEText (Rat $rat, PInt2_36 $radix)>

This selector function results in the C<NEText> value where its C<$rat>
argument is formatted as a base-C<$radix> rational.

=back

These functions convert between C<Rat> values and equal or nearly equal
C<Int> values.

=over

=item C<sys.Core.Rat.Rat_from_Int of Rat (Int $int)>

This selector function results in the C<Rat> value that is conceptually
equal to its C<Int> argument.

=item C<sys.Core.Rat.round_half_up of Int (Rat $topic)>

This rounding function results in the integer that is nearest to its
argument, but that if the argument is exactly half-way between 2 integers,
it is rounded upwards.  This is the most commonly used method of rounding.

=item C<sys.Core.Rat.round_to_even of Int (Rat $topic)>

This rounding function results in the integer that is nearest to its
argument, but that if the argument is exactly half-way between 2 integers,
it is rounded to the one that is even.  Note that this operation is also
legitimately known as: I<unbiased rounding>, I<convergent rounding>,
I<statistician's rounding>, I<bankers' rounding>.

=item C<sys.Core.Rat.round_to_floor of Int (Rat $topic)>

This rounding function results in the integer that is either equal to its
argument or that is the nearest integer that is above the argument.

=item C<sys.Core.Rat.round_to_ceiling of Int (Rat $topic)>

This rounding function results in the integer that is either equal to its
argument or that is the nearest integer that is below the argument.

=item C<sys.Core.Rat.round_to_zero of Int (Rat $topic)>

This rounding function results in the integer that is either equal to its
argument or that is the nearest integer to the argument that is closer to
zero.  Note that this operation is also legitimately known as I<truncate>.

=back

These functions round and/or truncate rational values to make them easier
to deal with in various contexts.

=over

=item C<sys.Core.Rat.rebase of Rat (Rat $topic, PInt $radix, PInt
$max_denom, Cat.RoundMeth $round)>

This function results in the rational that is as close as possible to
C<$topic> but that its denominator is a positive power of C<$radix> and
said denominator is not larger than C<$max_denom>; if rounding is needed,
then C<$round> dictates the rounding method.

=back

=head2 Functions for sys.Core.Blob.Blob

These functions implement commonly used binary string operations.

=over

=item C<sys.Core.Blob.catenate of Blob (Seq{Blob} $topic)>

This function results in the catenation of the N element values of its
argument; it is a reduction operator that recursively takes each
consecutive pair of input values and catenates (which is associative) them
together until just one is left, which is the result.  If C<$topic> has
zero values, then C<catenate> results in the empty string value, which is
the identity value for catenate.

=item C<sys.Core.Blob.repeat of Blob (Blob $topic, UInt $count)>

This function results in the catenation of C<$count> instances of
C<$topic>.

=item C<sys.Core.Blob.length_in_bits of UInt (Blob $topic)>

This function results in the length of its argument in bits.

=item C<sys.Core.Blob.contains of Bool (Blob $look_in, Blob $look_for, Bool
$fixed_start, Bool $fixed_end)>

This function results in C<Bool:true> iff its C<$look_for> argument is a
substring of its C<$look_in> argument as per the optional C<$fixed_start>
and C<$fixed_end> constraints, and C<Bool:false> otherwise.  If
C<$fixed_start> or C<$fixed_end> are C<Bool:true>, then C<$look_for> must
occur right at the start or end, respectively, of C<$look_in> in order for
C<contains> to results in C<Bool:true>; if either flag is C<Bool:false>,
its additional constraint doesn't apply.

=item C<sys.Core.Blob.not of Blob (Blob $topic)>

This function results in the bitwise I<not> of its argument.

=item C<sys.Core.Blob.and of Blob (Set{Blob} $topic)>

This function is a reduction operator that recursively takes each pair of
its N input element values and does a bitwise I<and> (which is both
commutative and associative) on them until just one is left, which is the
function's result.  This function's argument values must all be of the same
length in bits, that length being part of the argument's declared type
(that is, C<Blob> subtype) definition, and that is also the length in bits
of the function's result.  If C<$topic> has zero values, then C<and> will
result in an appropriate-length string of identity/1 valued bits.

=item C<sys.Core.Blob.or of Blob (Set{Blob} $topic)>

This function is the same as C<sys.Core.Blob.and> but that it recursively
does a bitwise inclusive-or rather than a bitwise I<and>, and its identity
value is composed of zero valued bits.

=item C<sys.Core.Blob.xor of Blob (Bag{Blob} $topic)>

This function is the same as C<sys.Core.Blob.or> but that it recursively
does a bitwise exclusive-or rather than a bitwise inclusive-or.

=back

These functions convert between C<Blob> values and canonically formatted
representations of binary strings as character strings.

=over

=item C<sys.Core.Blob.Blob_from_Text of Blob (Text $text, PInt1_4 $size)>

This selector function results in the C<Blob> value that its C<$text>
argument maps to when each input character represents a sequence of 1-4
bits, the number of bits per character being determined by the C<$size>
argument; for example, if C<$size> is 1, then each input character is a
[0-1] and represents a bit; or, if C<$size> is 4, then each input character
is a [0-9A-F] and represents 4 bits.  This function will fail if C<$text>
can't be mapped as specified.

=item C<sys.Core.Blob.Text_from_Blob of Text (Blob $blob, PInt1_4 $size)>

This selector function results in the C<Text> value where its argument is
encoded using a character for each sequence of 1-4 bits, the number of bits
per character being determined by the C<$size> argument.  This function
will fail if C<$blob> doesn't have a length in bits which is a multiple of
C<$size>.

=back

=head2 Functions for sys.Core.Text.Text

These functions implement commonly used character string operations.

=over

=item C<sys.Core.Text.catenate of Text (Seq{Text} $topic)>

This function results in the catenation of the N element values of its
argument; it is a reduction operator that recursively takes each
consecutive pair of input values and catenates (which is associative) them
together until just one is left, which is the result.  If C<$topic> has
zero values, then C<catenate> results in the empty string value, which is
the identity value for catenate.

=item C<sys.Core.Text.repeat of Text (Text $topic, UInt $count)>

This function results in the catenation of C<$count> instances of
C<$topic>.

=item C<sys.Core.Text.length_in_nfd_graphs of UInt (Text $topic)>

This function results in the length of its argument in Unicode
Normalization Form D graphemes.

=item C<sys.Core.Text.length_in_nfc_graphs of UInt (Text $topic)>

This function results in the length of its argument in Unicode
Normalization Form C graphemes.

=item C<sys.Core.Text.length_in_nfd_codes of UInt (Text $topic)>

This function results in the length of its argument in Unicode
Normalization Form D code points.

=item C<sys.Core.Text.length_in_nfc_codes of UInt (Text $topic)>

This function results in the length of its argument in Unicode
Normalization Form C code points.

=item C<sys.Core.Text.contains of Bool (Text $look_in, Text $look_for, Bool
$fixed_start, Bool $fixed_end)>

This function results in C<Bool:true> iff its C<$look_for> argument is a
substring of its C<$look_in> argument as per the optional C<$fixed_start>
and C<$fixed_end> constraints, and C<Bool:false> otherwise.  If
C<$fixed_start> or C<$fixed_end> are C<Bool:true>, then C<$look_for> must
occur right at the start or end, respectively, of C<$look_in> in order for
C<contains> to result in C<Bool:true>; if either flag is C<Bool:false>, its
additional constraint doesn't apply.

=item C<sys.Core.Text.fold_case_to_upper (Text $topic)>

This function results in the transformation of its argument where any Latin
letters are folded to (capital) uppercase.

=item C<sys.Core.Text.fold_case_to_lower (Text $topic)>

This function results in the transformation of its argument where any Latin
letters are folded to (small) lowercase.

=item C<sys.Core.Text.trim_whitespace (Text $topic)>

This function results in the value of its argument but that any leading or
trailing whitespace characters are trimmed.

=back

=head1 SYSTEM-DEFINED CORE GENERIC NONSCALAR FUNCTIONS

These functions are applicable to mainly nonscalar types, but are generic
in that they typically work with any nonscalar types.

=head2 Functions for sys.Core.Tuple.Tuple Having Single Input Tuples

=over

=item C<sys.Core.Tuple.degree of UInt (Tuple $topic)>

This function results in the degree of its argument (that is, the count of
attributes it has).

=item C<sys.Core.Tuple.rename of Tuple (Tuple $topic, Cat.BiDiShortNameMap
$map)>

This function results in a C<Tuple> value that is the same as its C<$topic>
argument but that some of its attributes have different names.  Each tuple
of the argument C<$map> specifies how to rename one C<$topic> attribute,
with the C<key> and C<value> attributes of a C<$map> tuple representing the
old and new names of a C<$topic> attribute, respectively.  As a trivial
case, this function's result is C<$topic> if C<$map> has no tuples.  This
function supports renaming attributes to each others' names.  This function
will fail if C<$map> specifies any old names that C<$topic> doesn't have,
or any new names that are the same as C<$topic> attributes that aren't
being renamed.

=item C<sys.Core.Tuple.project of Tuple (Tuple $topic, Cat.SetOfShortName
$attrs)>

This function results in the projection of its C<$topic> argument that has
just the subset of attributes of C<$topic> which are named in its C<$attrs>
argument.  As a trivial case, this function's result is C<$topic> if
C<$attrs> lists all attributes of C<$topic>; or, it is the nullary tuple if
C<$attrs> is empty.  This function will fail if C<$attrs> specifies any
attribute names that C<$topic> doesn't have.

=item C<sys.Core.Tuple.remove of Tuple (Tuple $topic, Cat.SetOfShortName
$attrs)>

This function is the same as C<project> but that it results in the
complementary subset of attributes of C<$topic> when given the same
arguments.

=item C<sys.Core.Tuple.wrap of Tuple (Tuple $topic, Cat.SetOfShortName
$inner, Cat.ShortName $outer)>

This function results in a C<Tuple> value that is the same as its C<$topic>
argument but that some of its attributes have been wrapped up into a new
C<Tuple>-typed attribute, which exists in place of the original attributes.
The C<$inner> argument specifies which C<$topic> attributes are to be
removed and wrapped up, and the C<$outer> argument specifies the name of
their replacement attribute.  As a trivial case, if C<$inner> is empty,
then the result has all the same attributes as before plus a new nullary
tuple attribute; or, if C<$inner> lists all attributes of C<$topic>, then
the result has a single attribute whose value is the same as C<$topic>.
This function supports the new attribute having the same name as an old one
being wrapped into it.  This function will fail if C<$inner> specifies any
attribute names that C<$topic> doesn't have, or if C<$outer> is the same as
C<$topic> attributes that aren't being wrapped.

=item C<sys.Core.Tuple.unwrap of Tuple (Tuple $topic, Cat.ShortName
$outer)>

This function is the inverse of C<sys.Core.Tuple.wrap>, such that it will
unwrap a C<Tuple>-type attribute into its member attributes.  This function
will fail if C<$outer> specifies any attribute name that C<$topic> doesn't
have, or if an attribute of C<$topic{$outer}> is the same as a C<$topic>
attribute.

=back

=head2 Functions for sys.Core.Tuple.Tuple Having Multiple Input Tuples

=over

=item C<sys.Core.Tuple.product of Tuple (QuasiSet{Tuple} $topic)>

This function is similar to C<sys.Core.Relation.product> but that it works
with tuples rather than relations.  This function is mainly intended for
use in connecting tuples that have all disjoint headings, such as for
extending one tuple with additional attributes.

=back

=head2 Functions for sys.Core.Relation.Relation Having Single Input
Relations

=over

=item C<sys.Core.Relation.degree of UInt (Relation $topic)>

This function results in the degree of its argument (that is, the count of
attributes it has).

=item C<sys.Core.Relation.cardinality of UInt (Relation $topic)>

This function results in the cardinality of its argument (that is, the
count of tuples its body has).

=item C<sys.Core.Relation.is_empty of Bool (Relation $topic)>

This function results in C<Bool:true> iff its argument has zero tuples, and
C<Bool:false> otherwise.  Note that if you are using a C<Maybe> to
represent a sparse data item, analagously to a SQL nullable context, then
testing the C<Maybe> with C<is_empty> is analagous to testing a SQL
nullable with C<is null>.

=item C<sys.Core.Relation.is_not_empty of Bool (Relation $topic)>

This function is exactly the same as C<sys.Core.Relation.empty> except that
it results in the opposite boolean value when given the same argument.  And
following the analogy with C<is_empty>, C<is_not_empty> is analagous to
SQL's C<is not null>.

=item C<sys.Core.Relation.exists of Bool (Relation $r, Tuple $t)>

This function results in C<Bool:true> iff its C<$t> argument matches a
tuple of its C<$r> argument, and C<Bool:false> otherwise.  This function is
like C<sys.Core.Relation.contains> except that the tuple being looked for
doesn't have to be wrapped in a relation.  This function will fail if the 2
arguments don't have the same heading.

=item C<sys.Core.Relation.Tuple_from_Relation of Tuple (Relation $topic)>

This function results in the C<Tuple> that is the sole member tuple of its
argument.  This function will fail if its argument does not have exactly
one tuple.

=item C<sys.Core.Relation.Relation_from_Tuple of Relation (Tuple $topic)>

This function results in the C<Relation> value those body has just the one
C<Tuple> that is its argument.

=item C<sys.Core.Relation.insert of Relation (Relation $r, Tuple $t)>

This function results in a C<Relation> that is the relational union of
C<$r> and a relation whose sole tuple is C<$t>; that is, conceptually the
result is C<$t> inserted into C<$r>.  As a trivial case, if C<$t> already
exists in C<$r>, then the result is just C<$r>.

=item C<sys.Core.Relation.delete of Relation (Relation $r, Tuple $t)>

This function results in a C<Relation> that is the relational difference of
a relation whose sole tuple is C<$t> and C<$r>; that is, conceptually the
result is C<$t> deleted from C<$r>.  As a trivial case, if C<$t> already
doesn't exist in C<$r>, then the result is just C<$r>.

=item C<sys.Core.Relation.evacuate of Relation (Relation $topic)>

This function results in a C<Relation> that has the same heading as its
argument, but with an empty body.

=item C<sys.Core.Relation.not of Relation (Relation $topic)>

This function results in the relational I<not> of its argument.  The result
relation has the same heading as its argument, and its body contains all of
the tuples that are in the universal relation of the same heading (that is,
the relation having all the tuples that could ever exist in a relation with
that heading) and that are not in the argument; that is, the result is the
relational difference when the argument is subtracted from said universal
relation.  This function will fail if said universal relation is impossible
or impractically large to represent, such as when any attributes are of
infinite types.

=item C<sys.Core.Relation.rename of Relation (Relation $topic,
Cat.BiDiShortNameMap $map)>

This function is the same as C<sys.Core.Tuple.rename> but that it operates
on and results in a C<Relation> rather than a C<Tuple>.

=item C<sys.Core.Relation.project of Relation (Relation $topic,
Cat.SetOfShortName $attrs)>

This function is the same as C<sys.Core.Tuple.project> but that it operates
on and results in a C<Relation> rather than a C<Tuple>.  But note that the
result relation will have fewer tuples than C<$topic> if any C<$topic>
tuples were non-distinct for just the projected attributes.

=item C<sys.Core.Relation.remove of Relation (Relation $topic,
Cat.SetOfShortName $attrs)>

This function is the same as C<sys.Core.Tuple.remove> but that it operates
on and results in a C<Relation> rather than a C<Tuple>.

=item C<sys.Core.Relation.wrap of Relation (Relation $topic,
Cat.SetOfShortName $inner, Cat.ShortName $outer)>

This function is the same as C<sys.Core.Tuple.wrap> but that it operates on
and results in a C<Relation> rather than a C<Tuple>, where each of its
member tuples was transformed as per C<sys.Core.Tuple.wrap>.

=item C<sys.Core.Relation.unwrap of Relation (Relation $topic,
Cat.ShortName $outer)>

This function is the inverse of C<sys.Core.Relation.wrap> as
C<sys.Core.Tuple.unwrap> is to C<sys.Core.Tuple.wrap>.

=item C<sys.Core.Relation.group of Relation (Relation $topic,
Cat.SetOfShortName $inner, Cat.ShortName $outer)>

I<TODO.>

=item C<sys.Core.Relation.ungroup of Relation (Relation $topic,
Cat.ShortName $outer)>

I<TODO.>

=item C<sys.Core.Relation.tclose of Relation (Relation $topic)>

This function results in the transitive closure of its argument.  The
argument is a binary relation whose attributes are both of the same
declared type, and the result is a relation having the same heading and a
body which is a superset of the argument's tuples.  Assuming that the
argument represents all of the node pairs in a directed graph that have an
arc between them, and so each argument tuple represents an arc, C<tclose>
will determine all of the node pairs in that graph which have a path
between them (a recursive operation), so each tuple of the result
represents a path.  The result is a superset since all arcs are also
complete paths.  The C<tclose> function is intended to support recursive
queries, such as in connection with the "part explosion problem" (the
problem of finding all components, at all levels, of some specified part).

=item C<sys.Core.Relation.restrict of Relation (Relation $topic,
Cat.LongName $func, Tuple $assuming)>

This function results in the relational restriction of its C<$topic>
argument as determined by applying the C<Bool>-returning function named in
its C<$func> argument when the latter function is curried by its
C<$assuming> argument.  The result relation has the same heading as
C<$topic>, and its body contains the subset of C<$topic> tuples where, for
each tuple, the function named by C<$func> results in C<Bool:true> when
passed the tuple as its C<$topic> argument and C<$assuming> as its
C<$assuming> argument.  As a trivial case, if C<$func> is defined to
unconditionally result in C<Bool:true>, then this function results simply
in C<$topic>; or, for an unconditional C<Bool:false>, this function results
in the empty relation with the same heading.  Note that this operation is
also legitimately known as I<where>.  Note that
C<sys.Core.Relation.semijoin> is recommended for use instead of
C<sys.Core.Relation.restrict> to implement some common kinds of relational
restrictions (those composed simply of anded or ored tests for attribute
value equality), due to the former's greater simplicity.

=item C<sys.Core.Relation.extend of Relation (Relation $topic, Cat.LongName
$func, Tuple $assuming)>

This function results in a relation that is the same as its C<$topic>
argument, but that it has zero or more additional attributes, as determined
by applying the C<Tuple>-returning function named in its C<$func> argument
when the latter function is curried by its C<$assuming> argument.  The
result relation has a heading that is a superset of that of C<$topic>, and
its body contains the same number of tuples, with all attribute values of
C<$topic> retained, and possibly extra present, determined as follows; for
each C<$topic> tuple, the function named by C<$func> results in a second
tuple when passed the first tuple as its C<$topic> argument and
C<$assuming> as its C<$assuming> argument; the first and second tuples have
no attribute names in common, and the result tuple is derived by joining
the tuples together.

=item C<sys.Core.Relation.summarize>

I<TODO.>

=item C<sys.Core.Relation.substitute>

I<TODO.>

=back

=head2 Functions for sys.Core.Relation.Relation Having Multiple Input
Relations

=over

=item C<sys.Core.Relation.contains of Bool (Relation $look_in, Relation
$look_for)>

This function results in C<Bool:true> iff the set of tuples comprising
C<$look_for> is a subset of the set of tuples comprising C<$look_in>, and
C<Bool:false> otherwise.  This function will fail if the 2 arguments don't
have the same heading.

=item C<sys.Core.Relation.union of Relation (Set{Relation} $topic)>

This function results in the relational union/inclusive-or of the N element
values of its argument; it is a reduction operator that recursively takes
each pair of input values and relationally unions (which is both
commutative and associative) them together until just one is left, which is
the result.  The result relation has the same heading as all of its inputs,
and its body contains every tuple that is in any of the input relations.
If C<$topic> has zero values, then C<union> results in the empty relation
with the same heading, which is the per-distinct-heading identity value for
relational union.

=item C<sys.Core.Relation.exclusion of Relation (Bag{Relation} $topic)>

This function results in the relational exclusion/exclusive-or of the N
element values of its argument; it is a reduction operator that recursively
takes each pair of input values and relationally excludes (which is both
commutative and associative) them together until just one is left, which is
the result.  The result relation has the same heading as all of its inputs,
and its body contains every tuple that is in just an odd number of the
input relations.  If C<$topic> has zero values, then C<exclusion> results
in the empty relation with the same heading, which is the
per-distinct-heading identity value for relational exclusion.  Note that
this operation is also legitimately known as I<symmetric difference>, or
I<disjoint union>.

=item C<sys.Core.Relation.intersection of Relation (Set{Relation} $topic)>

This function results in the relational intersection/and of the N element
values of its argument; it is a reduction operator that recursively takes
each pair of input values and relationally intersects (which is both
commutative and associative) them together until just one is left, which is
the result.  The result relation has the same heading as all of its inputs,
and its body contains only the tuples that are in every one of the input
relations.  If C<$topic> has zero values, then C<intersection> results in
the universal relation with the same heading (that is, the relation having
all the tuples that could ever exist in a relation with that heading),
which is the per-distinct-heading identity value for relational
intersection.  Note that this I<intersection> operator is conceptually a
special case of C<join>, applicable when the headings of the inputs are the
same, and the other will produce the same result as this when given the
same inputs, but with the exception that I<intersection> has a different
identity value when given zero inputs.  This function will fail on a
C<$topic> of zero values if the result type's universal relation is
impossible or impractically large to represent, such as when any attributes
are of infinite types.

=item C<sys.Core.Relation.difference of Relation (Relation $source,
Relation $filter)>

This function results in the relational difference when its C<$filter>
argument is subtracted from its C<$source> argument.  The result relation
has the same heading as both of its arguments, and its body contains only
the tuples that are in C<$source> and are not in C<$filter>.  This function
will fail if its 2 arguments do not have the same heading.  Note that this
I<difference> operator is conceptually a special case of I<semidifference>,
applicable when the headings of the inputs are the same.

=item C<sys.Core.Relation.semidifference of Relation (Relation $source,
Relation $filter)>

This function is the same as C<semijoin> but that it results in the
complementary subset of tuples of C<$source> when given the same arguments.
Note that this operation is also legitimately known as I<antijoin>.

=item C<sys.Core.Relation.semijoin of Relation (Relation $source, Relation
$filter)>

This function results in the relational semijoin of its C<$source> and
C<$filter> arguments.  The result relation has the same heading as
C<$source>, and its body contains the subset of C<$source> tuples that
match those of C<$filter> as per C<join>.  Note that relational semijoin is
conceptually a short-hand for first doing an ordinary relational join
between its 2 arguments, and then performing a relational projection on all
of the attributes that just C<$source> has.  This function will fail any
time that C<join> would fail on the same 2 input relations.

=item C<sys.Core.Relation.join of Relation (QuasiSet{Relation} $topic)>

This function results in the relational join of the N element values of its
argument; it is a reduction operator that recursively takes each pair of
input values and relationally joins (which is both commutative and
associative) them together until just one is left, which is the result.
The result relation has a heading that is a union of all of the headings of
its inputs, and its body is the result of first pairwise-matching every
tuple of each input relation with every tuple of each other input relation,
then where each member of a tuple pair has attribute names in common,
eliminating pairs where the values of those attributes differ and unioning
the remaining said tuple pairs, then eliminating any result tuples that
duplicate others.  If C<$topic> has zero values, then C<join> results in
the nullary relation with one tuple, which is the identity value for
relational join.  As a trivial case, if any input relation has zero tuples,
then the function's result will too; or, if any input is the nullary
relation with one tuple, that input can be ignored (see identity value);
or, if any 2 inputs have no attribute names in common, then the join of
just those 2 is a cartesian product; or, if any 2 inputs have all attribute
names in common, then the join of just those 2 is an intersection; or, if
for 2 inputs, one's set of attribute names is a proper subset of another's,
then the join of just those to is a semijoin with the former filtering the
latter.  This function will fail if any input relations have attributes
with common names but different/incompatible declared types.  Note that
this operation is also legitimately known as I<natural inner join>.

=item C<sys.Core.Relation.product of Relation (QuasiSet{Relation} $topic)>

This function results in the relational cartesian/cross product of the N
element values of its argument; it is conceptually a special case of
C<join> where all input relations have mutually distinct attribute names;
unlike C<join>, C<product> will fail if any inputs have attribute names in
common.  Note that this operation is also legitimately known as
I<cartesian/cross join>.

=item C<sys.Core.Relation.compose of Relation (Relation $r1, Relation $r2)>

This function results in the relational composition of its 2 arguments.  It
is conceptually a short-hand for first doing an ordinary relational join
between its 2 arguments, and then performing a relational projection on all
of the attributes that only one of the arguments has; that is, the result
has all of and just the attributes that were not involved in matching the
tuples of the 2 arguments.  This function will fail any time that C<join>
would fail on the same 2 input relations.

=item C<sys.Core.Relation.quotient of Relation (Relation $dividend,
Relation $divisor)>

This function results in the quotient when its C<$dividend> argument is
divided by its C<$divisor> argument using relational division.  Speaking
informally, say the relations C<$dividend> and C<$divisor> are called C<A>
and C<B>, and their attribute sets are respectively named C<{X,Y}> and
C<{Y}>, then the result relation has a heading composed of attributes
C<{X}> (so the result and C<$divisor> headings are both complementary
subsets of the C<$dividend> heading); the result has all tuples C<{X}> such
that a tuple C<{X,Y}> appears in C<A> for all tuples C<{Y}> appearing in
C<B>; that is, C<A / B> is shorthand for C<A{X} - ((A{X} join B) - A){X}>.

=back

=head1 SYSTEM-DEFINED CORE GENERIC QUASI-NONSCALAR FUNCTIONS

I<This documentation is pending.>

=head1 SYSTEM-DEFINED CORE UPDATE OPERATORS

=head2 Generic Universal

These update operators are applicable to values of any data type at all.

=over

=item C<sys.Core.Universal.assign (UPD: Some.Universal $target ; RO:
Some.Universal $v)>

This update operator will update the variable supplied as its C<$target>
argument so that it holds the value supplied as its C<$v> argument.  This
update operator's arguments must be of compatible declared types; in this
case, C<$v> must be a subtype of C<$target>.

=back

=head2 Scalar

These update operators are applicable to just one or more specific
system-defined core scalar data type.

I<This documentation is pending.>

=head2 Nonscalar

These update operators are applicable to mainly nonscalar types, but are
generic in that they typically work with any nonscalar types.

=head2 Quasi-Nonscalar

I<This documentation is pending.>

=head1 SYSTEM-DEFINED CORE SYSTEM SERVICES

These system services are applicable to just one or more specific
system-defined core scalar data type.

I<This documentation is pending.>

=head1 SEE ALSO

Go to L<Language::MuldisD> for the majority of distribution-internal
references, and L<Language::MuldisD::SeeAlso> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<perl@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright  2002-2007, Darren Duncan.

See the LICENSE AND COPYRIGHT of L<Language::MuldisD> for details.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Language::MuldisD> apply to this file too.

=cut
