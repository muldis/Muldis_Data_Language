=pod

=encoding utf8

=head1 NAME

Language::MuldisD::Core -
Muldis D core data types and operators

=head1 VERSION

This document is Language::MuldisD::Core version 0.19.0.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Language::MuldisD>; you should read that root document
before you read this one, which provides subservient details.

=head1 DESCRIPTION

Muldis D has a mandatory core set of system-defined (eternally available)
entities, which is referred to as the I<Muldis D core> or the I<core>; they
are the minimal entities that all Muldis D implementations need to provide;
they are mutually self-describing and are used to bootstrap the language;
any entities outside the core, called I<Muldis D extensions>, are
non-mandatory and are defined in terms of the core or each other, but the
reverse isn't true.

This current C<Core> document features the boolean, integer, rational, bit
string, and character string types and operators, plus the tuple and
relation type constructors (and quasi- variants) and operators, plus the
type system minimal and maximal types, plus the special types used to
define the system catalog, and the polymorphic operators that all types, or
some types including core types, have defined over them.

Extensions are in these other documents:
L<Language::MuldisD::Ext::Temporal>, L<Language::MuldisD::Ext::Spatial>.

=head1 TYPE SUMMARY

Following are all the data types and data type factories described in this
document, arranged in a type graph according to their proper sub|supertype
relationships:

    sys.Core.Universal.Universal

        sys.Core.Universal.Empty

        sys.Core.Scalar.Scalar
            sys.Core.Ordered.Ordered

                # The following are all regular ordered scalar types.

                sys.Core.Bool.Bool
                sys.Core.Int.Int
                    sys.Core.Int.UInt
                        sys.Core.Int.PInt
                sys.Core.Rat.Rat
                    sys.Core.Rat.URat
                        sys.Core.Rat.PRat
                    sys.Core.Rat.BRat
                    sys.Core.Rat.DRat
                sys.Core.Blob.Blob
                    sys.Core.Blob.NEBlob
                sys.Core.Text.Text
                    sys.Core.Text.NEText

        # The following are mostly nonscalar type factories.

        sys.Core.Tuple.Tuple
            sys.Core.Tuple.D0
            sys.Core.Tuple.SetElem
            sys.Core.Tuple.SeqElem
            sys.Core.Tuple.BagElem
            sys.Core.Tuple.Database

        sys.Core.Relation.Relation
            sys.Core.Relation.D0
            sys.Core.Relation.Set
                sys.Core.Relation.Maybe
                    sys.Core.Relation.Nothing
                    sys.Core.Relation.Single
            sys.Core.Relation.Seq
            sys.Core.Relation.Bag

        # The following is filler, to group possible user-def types.

        sys.Core.QuasiScalar.QuasiScalar
            sys.Core.QuasiScalar.E_D

        # The following are mostly quasi-nonscalar type factories.

        sys.Core.QuasiTuple.QuasiTuple
            sys.Core.QuasiTuple.D0
            sys.Core.QuasiTuple.QuasiSetElem
            sys.Core.QuasiTuple.QuasiSeqElem
            sys.Core.QuasiTuple.QuasiBagElem

        sys.Core.QuasiRelation.QuasiRelation
            sys.Core.QuasiRelation.D0
            sys.Core.QuasiRelation.QuasiSet
                sys.Core.QuasiRelation.QuasiMaybe
                    sys.Core.QuasiRelation.QuasiNothing
                    sys.Core.QuasiRelation.QuasiSingle
            sys.Core.QuasiRelation.QuasiSeq
            sys.Core.QuasiRelation.QuasiBag

        # The following are all remnant types.

        sys.Core.Remnant.Remnant
            sys.Core.Remnant.ScaTupRel

Note that C<sys.Core.Universal.Empty> is a proper subtype of all of the
other types in this graph, but every other type has only one immediate
supertype shown, and hence the graph of them is a simple hierarchy.

These system-defined subtypes are specific to defining the system catalog,
more or less:

    sys.Core.Universal.Universal

        sys.Core.Universal.Empty

        sys.Core.Scalar.Scalar

            # The following is actually a union over many scalar types.

            sys.Core.Cat.ScalarLiteral

            sys.Core.Ordered.Ordered

                # The following are all regular ordered scalar types.

                sys.Core.Cat.Name
                sys.Core.Cat.NameChain
                sys.Core.Cat.FlattenedNameChain
                sys.Core.Cat.Comment

                sys.Core.Int.Int
                    sys.Core.Int.UInt
                        sys.Core.Int.PInt

                            # These are all finite integer types.

                            sys.Core.Cat.PInt1_4
                            sys.Core.Cat.PInt2_N
                                sys.Core.Cat.PInt2_36

            # The following are all regular non-ordered scalar types.

            sys.Core.Cat.E_RM
            sys.Core.Cat.E_TK
            sys.Core.Cat.E_TDM
            sys.Core.Cat.E_ENK
            sys.Core.Cat.E_PSAK

        sys.Core.Tuple.Tuple

            # The following are all regular tuple types.

            sys.Core.Cat.RatRoundRule
            sys.Core.Cat.Type
            sys.Core.Cat.ExprNode
            sys.Core.Cat.InnerFunc
            sys.Core.Cat.Func
            sys.Core.Cat.UpdStmt
            sys.Core.Cat.InnerUpdater
            sys.Core.Cat.Updater
            sys.Core.Cat.ProcStmtArg
            sys.Core.Cat.ProcStmt
            sys.Core.Cat.InnerProc
            sys.Core.Cat.Proc
            sys.Core.Cat.Exception

        sys.Core.Relation.Relation

            # The following are all regular relation types.

            sys.Core.Cat.NameTypeMap
            sys.Core.Cat.NameExprMap
            sys.Core.Cat.AttrRenameMap
            sys.Core.Cat.ExprSet
                sys.Core.Cat.ExprTree
            sys.Core.Cat.InnerFuncSet
                sys.Core.Cat.InnerFuncTree
            sys.Core.Cat.MultiUpdStmt
            sys.Core.Cat.InnerUpdaterSet
                sys.Core.Cat.InnerUpdaterTree
            sys.Core.Cat.ProcStmtArgSet
            sys.Core.Cat.InnerProcTree

            sys.Core.Relation.Set

                # The following are all regular set types.

                sys.Core.Cat.SetOfName
                sys.Core.Cat.SetOfSetOfName
                sys.Core.Cat.SetOfNameExprMap
                sys.Core.Cat.SetOfNameChain

            sys.Core.Relation.Seq

                # The following are all regular sequence types.

                sys.Core.Cat.NESeqOfName
                sys.Core.Cat.SeqOfProcStmt

These system-defined subtypes are used as the declared types of some
parameters of some system-defined N-ary routines, but they are not used in
defining the system catalog itself; it is not anticipated that they would
be used for user data:

    sys.Core.Universal.Universal

        sys.Core.Universal.Empty

        sys.Core.Relation.Relation
            sys.Core.Relation.Set

                # The following are all nonscalar type factories.

                sys.Core.QuasiCat.SetOfTuple
                sys.Core.QuasiCat.SetOfRelation
                    sys.Core.QuasiCat.SetOfBag

                sys.Core.Relation.Maybe

                    # The following are all nonscalar type factories.

                    sys.Core.QuasiCat.MaybeOfTuple

            sys.Core.Relation.Seq

                # The following are all nonscalar type factories.

                sys.Core.QuasiCat.SeqOfSeq

            sys.Core.Relation.Bag

                # The following are all nonscalar type factories.

                sys.Core.QuasiCat.BagOfTuple
                sys.Core.QuasiCat.BagOfRelation

        sys.Core.QuasiRelation.QuasiRelation
            sys.Core.QuasiRelation.QuasiSet

                # The following are all quasi-nonscalar type factories.

                sys.Core.QuasiCat.QuasiSetOfTuple
                sys.Core.QuasiCat.QuasiSetOfRelation

These system-defined subtypes have also been defined for convenience, as
they are anticipated to be frequently used; moreover, many system-defined
routines use them as parameter declared types:

    sys.Core.Universal.Universal

        sys.Core.Universal.Empty

        sys.Core.Relation.Relation
            sys.Core.Relation.Set

                # The following are all regular set types.

                sys.Core.Spec.SetOfScalar
                    sys.Core.Spec.SetOfOrdered
                        sys.Core.Spec.SetOfBool
                        sys.Core.Spec.SetOfInt
                            sys.Core.Spec.SetOfUInt
                        sys.Core.Spec.SetOfRat
                        sys.Core.Spec.SetOfBlob
                        sys.Core.Spec.SetOfText

                sys.Core.Relation.Maybe

                    # The following are all regular maybe types.

                    sys.Core.Spec.MaybeOfScalar
                        sys.Core.Spec.MaybeOfOrdered
                            sys.Core.Spec.MaybeOfBool
                            sys.Core.Spec.MaybeOfInt
                                sys.Core.Spec.MaybeOfUInt
                            sys.Core.Spec.MaybeOfRat
                            sys.Core.Spec.MaybeOfBlob
                            sys.Core.Spec.MaybeOfText

            sys.Core.Relation.Seq

                # The following are all regular sequence types.

                sys.Core.Spec.SeqOfScalar
                    sys.Core.Spec.SeqOfOrdered
                        sys.Core.Spec.SeqOfBool
                        sys.Core.Spec.SeqOfInt
                            sys.Core.Spec.SeqOfUInt
                        sys.Core.Spec.SeqOfRat
                        sys.Core.Spec.SeqOfBlob
                        sys.Core.Spec.SeqOfText

            sys.Core.Relation.Bag

                # The following are all regular bag types.

                sys.Core.Spec.BagOfScalar
                    sys.Core.Spec.BagOfOrdered
                        sys.Core.Spec.BagOfBool
                        sys.Core.Spec.BagOfInt
                            sys.Core.Spec.BagOfUInt
                        sys.Core.Spec.BagOfRat
                        sys.Core.Spec.BagOfBlob
                        sys.Core.Spec.BagOfText

=head1 SYSTEM-DEFINED CORE MAXIMAL AND MINIMAL DATA TYPES

These core data types are special and are the only Muldis D types that are
neither scalar nor nonscalar nor quasi-nonscalar types.  They are all
system-defined and it is impossible for users to define more types of this
nature.

=head2 sys.Core.Universal.Universal

The C<Universal> type is the maximal type of the entire Muldis D type
system, and contains every value that can possibly exist.  Every other type
is implicitly a proper subtype of C<Universal>, and C<Universal> is
implicitly a union type over all other types.  Its default value is
C<Bool:false>.  The cardinality of this type is infinity.

=head2 sys.Core.Universal.Empty

The C<Empty> type is the minimal type of the entire Muldis D type system,
and is the only type that contains exactly zero values.  Every other type
is implicitly a proper supertype of C<Empty> and C<Empty> is implicitly an
intersection type over all other types.  It has no default value.  The
cardinality of this type is zero.

=head1 SYSTEM-DEFINED CORE SCALAR DATA TYPES

These core scalar data types are the most fundamental Muldis D types.  Each
one has zero possreps, and hence has no named components that can be
referenced.  Plain Text Muldis D provides a specific syntax per type to
select a value of one of these types, which does not look like a routine
invocation, but rather like a scalar literal in a typical programming
language; details of that syntax are not given here, but in
L<Language::MuldisD::Dialect::PTMD_Tiny>.  Hosted Data Muldis D as hosted
in another language will essentially use literals of corresponding host
language types, whatever they use for eg booleans and integers and
character strings, but tagged with extra meta-data if the host language is
more weakly typed or lacks one-to-one type correspondence; see
L<Language::MuldisD::Dialect::HDMD_Perl_Tiny> for a Perl-based example.

=head2 sys.Core.Scalar.Scalar

The C<Scalar> type is the maximal type of all Muldis D scalar types, and
contains every scalar value that can possibly exist.  Every other scalar
type is implicitly a proper subtype of C<Scalar>, and C<Scalar> is
implicitly a union type over all other scalar types.  Its default value is
C<Bool:false>.  The cardinality of this type is infinity.

=head2 sys.Core.Ordered.Ordered

The C<Ordered> type is a proper subtype of C<Scalar> that is a proper
supertype of all scalar types that are considered ordered.  Any scalar
types which consider themselves ordered, which happens to include every
system-defined core scalar root type, will explicitly declare themselves as
subtypes of C<Ordered> in their type definitions; the definition of
C<Ordered> does not specify what other types it is a union over.  Its
default value is C<Bool:false>.  The cardinality of this type is infinity.

=head2 sys.Core.Bool.Bool

A C<Bool> is an enumeration consisting of the 2 values C<Bool:false> and
C<Bool:true>.  It represents a truth value, and is the result type of any
C<is_identical> or C<is_not_identical> routine; it is the only essential
scalar data type of a B<D> language.  Its default and minimum value is
C<Bool:false>; its maximum value is C<Bool:true>.  The cardinality of this
type is 2.

=head2 sys.Core.Int.Int

An C<Int> is a single exact integral number of any magnitude.  Its default
value is zero; its minimum and maximum values are conceptually infinities
and practically impossible.  The cardinality of this type is infinity; to
define a most-generalized finite C<Int> subtype, you must specify the 2
integer end-points of the inclusive range that all its values are in.

=head2 sys.Core.Int.UInt

A C<UInt> (unsigned / non-negative integer) is a proper subtype of C<Int>
where all member values are greater than or equal to zero.  Its minimum
value is zero.

=head2 sys.Core.Int.PInt

A C<PInt> (positive integer) is a proper subtype of C<UInt> where all
member values are greater than zero.  Its default and minimum value is 1.

=head2 sys.Core.Rat.Rat

A C<Rat> is a single exact rational number of any magnitude and precision.
It is conceptually a composite type with 2 main system-defined possreps,
called C<ratio> and C<float>, both of which are defined over several
C<Int>.

The C<ratio> possrep consists of 2 attributes: C<numerator> (an C<Int>),
C<denominator> (a C<PInt>); the conceptual value of a C<Rat> is the result
of rational-dividing its C<numerator> by its C<denominator>.  Because in
the general case there are an infinite set of [C<numerator>,C<denominator>]
integer pairs that denote the same rational value, the C<ratio> possrep
carries the normalization constraint that C<numerator> and C<denominator>
must be coprime, that is, they have no common integer factors other than 1.

The C<float> possrep consists of 3 attributes: C<mantissa> (an C<Int>),
C<radix> (a C<Cat.PInt2_N>), C<exponent> (an C<Int>); the conceptual value
of a C<Rat> is the result of multiplying its C<mantissa> by the result of
taking its C<radix> to the power of its C<exponent>.  The C<float> possrep
carries the normalization constraint that among all the
[C<mantissa>,C<radix>,C<exponent>] triples which would denote the same
rational value, the only allowed triple is the one having both the C<radix>
with the lowest value (that is closest to or equal to 2) and the
C<exponent> with the highest value (that is closest to positive infinity).
I<Note: this constraint could stand to be rephrased for simplification or
correction, eg if somehow the sets of candidate triples sharing the lowest
radix and sharing the highest exponent have an empty intersection.>

The default value of C<Rat> is zero; its minimum and maximum values are
conceptually infinities and practically impossible.  The cardinality of
this type is infinity; to define a most-generalized finite C<Rat> subtype,
you must specify the greatest magnitude value denominator, plus the the 2
integer end-points of the inclusive range of the value numerator; or
alternately you must specify the greatest magnitude value mantissa (the
I<maximum precision> of the number), and specify the greatest magnitude
value radix, plus the the 2 integer end-points of the inclusive range of
the value exponent (the I<maximum scale> of the number).  Common subtypes
specify that the normalized radixes of all their values are either 2 or 10;
types such as these will easily map exactly to common human or physical
numeric representations, so they tend to perform better.

=head2 sys.Core.Rat.URat

A C<URat> (unsigned / non-negative rational) is a proper subtype of C<Rat>
where all member values are greater than or equal to zero (that is, the
C<numerator>|C<mantissa> is greater than or equal to zero).  Its minimum
value is zero.

=head2 sys.Core.Rat.PRat

A C<PRat> (positive rational) is a proper subtype of C<URat> where all
member values are greater than zero (that is, the C<numerator>|C<mantissa>
is greater than zero).  Its default value is 1.

=head2 sys.Core.Rat.BRat

A C<BRat> (binary rational) is a proper subtype of C<Rat> where the
C<radix> is 2; it is the best option to exactly represent rational numbers
that are conceptually binary or octal or hexadecimal.

=head2 sys.Core.Rat.DRat

A C<DRat> (decimal rational) is a proper subtype of C<Rat> where the
C<radix> is 10 (or if it could be without the C<float> possrep
normalization constraint); it is the best option to exactly represent
rational numbers that are conceptually the decimal numbers that humans
typically work with.

=head2 sys.Core.Blob.Blob

A C<Blob> is an undifferentiated string of bits.  Its default and minimum
value is the empty string; its maximum value is an infinite-length string
and practically impossible.  The cardinality of this type is infinity; to
define a most-generalized finite C<Blob> subtype, you must specify a
maximum length in bits that the subtype's strings are.

=head2 sys.Core.Blob.NEBlob

A C<NEBlob> (non-empty blob) is a proper subtype of C<Blob> where its
length in bits must be at least 1; it can be any C<Blob> except for the
empty string.  Its default and minimum value is a single zero bit.

=head2 sys.Core.Text.Text

A C<Text> is a string of characters.  Its default and minimum value is the
empty string; its maximum value is an infinite-length string and
practically impossible.  Note that there is only one system-defined
character repertoire for C<Text> types, which is the newest Unicode
repertoire (5.0.0).  The cardinality of this type is infinity; to define a
most-generalized finite C<Text> subtype, you must specify a maximum length
in characters (that is, eg, in NFC graphemes) that the subtype's strings
are.

=head2 sys.Core.Text.NEText

A C<NEText> (non-empty text) is a proper subtype of C<Text> where its
length in characters must be more than zero; it can be any C<Text> except
for the empty string.  Its default value is a single "space" character; its
minimum value has one character, but which character that is depends on the
default or current collation.

=head1 SYSTEM-DEFINED CORE NONSCALAR PARAMETERIZED DATA TYPES

These are only called nonscalar data types in a loose sense, because by
themselves they are incomplete type definitions.  Actual nonscalar data
type definitions are derived from these by supplying the balance of the
type definitions, such as what their attributes are and/or what their
attribute types are.  Associated with these incomplete type definitions are
a set of system-defined routines that can be applied to values of any
actual nonscalar types derived from them; such are called I<generic
nonscalar operators>.  In the Muldis D type system, these incomplete
nonscalar types are defined as union types over all actual types derived
from them, and are proper supertypes of said.

Some actual nonscalar data types are system-defined, for use in defining
the Muldis D system catalog / meta-model (see further below in the current
document), and some others are system-defined for convenience since they
are the types of many core operators (see further below in the current
document), but all other actual nonscalar data types are user-defined.
Users can also define their own incomplete nonscalar data types that are
tuple or relation types.

As exceptions to the above 2 paragraphs, the C<Nothing> type and the 2
C<D0> types are actually complete types, despite being listed here.

=head2 sys.Core.Tuple.Tuple

The C<Tuple> type is the maximal type of all Muldis D tuple (nonscalar)
types, and contains every tuple value that could possibly exist.  A
C<Tuple> is an unordered heterogeneous collection of 0..N named attributes
(the count of attributes being its I<degree>), where all attribute names
are mutually distinct, and each attribute may be of distinct types; the
mapping of a tuple's attribute names and their declared data types is
called the tuple's I<heading>.  Its default value is the sole value of the
sole tuple data type that has zero attributes.  The cardinality of a
I<complete> C<Tuple> type (if it has no type constraints other than those
of its constituent attribute types) is equal to the product of the N-ary
multiplication where there is an input to that multiplication for each
attribute of the tuple and the value of the input is the cardinality of the
declared type of the attribute; for a C<Tuple> subtype to be finite, all of
its attribute types must be.

=head2 sys.Core.Tuple.D0

A C<Tuple.D0> is a proper subtype of C<Tuple> that has zero attributes; its
cardinality is 1, and its only value is also the default value of C<Tuple>.

=head2 sys.Core.Tuple.SetElem

A C<SetElem> is a C<Tuple> with the same heading as C<Set>.

=head2 sys.Core.Tuple.SeqElem

A C<SeqElem> is a C<Tuple> with the same heading as C<Seq>.

=head2 sys.Core.Tuple.BagElem

A C<BagElem> is a C<Tuple> with the same heading as C<Bag>.

=head2 sys.Core.Tuple.Database

A C<Database> is a proper subtype of C<Tuple> where all of its attributes
are each of relation types or of database types (the leaves of this
recursion are all relation types); it is otherwise the same.  It is also
trivially a proper supertype of C<Tuple.D0>.

=head2 sys.Core.Relation.Relation

The C<Relation> type is the maximal type of all Muldis D relation
(nonscalar) types, and contains every relation value that could possibly
exist.  A C<Relation> is analogous to a set of 0..N tuples where all tuples
have the same heading (the degrees match and all attribute names and
corresponding declared data types match), but that a C<Relation> data type
still has its own corresponding heading (attribute names and declared data
types) even when it consists of zero tuples.  Its default value is the
zero-tuple value of the sole relation data type that has zero attributes.
The cardinality of a I<complete> C<Relation> type (if it has no type
constraints other than those of its constituent attribute types) is equal
to 2 raised to the power of the cardinality of the I<complete> C<Tuple>
type with the same heading.  A relation data type can also have (unique)
keys each defined over a subset of its attributes, which constrain its set
of values relative to there being no explicit keys, but having the keys
won't turn an infinite relation type into a finite one.

=head2 sys.Core.Relation.D0

A C<Relation.D0> is a proper subtype of C<Relation> that has 0 attributes;
its cardinality is 2, and its default value is the same as that of
C<Relation>.

=head2 sys.Core.Relation.Set

A C<Set> is a proper subtype of C<Relation> that has 1 attribute, and its
name is C<value>; it can be of any declared type.  A C<Set> subtype is
normally used by any system-defined N-ary operators where the order of
their argument elements or result is not significant, and that duplicate
values are not significant.  Its default value has zero tuples.  Note that,
for any given I<complete> C<Set> subtype, C<Foo>, where its C<value>
attribute has a declared type of C<Bar>, the type C<Foo> can be considered
the I<power set> of the type C<Bar>.

=head2 sys.Core.Relation.Maybe

A C<Maybe> is a proper subtype of C<Set> that may have at most one element;
that is, it is a unary C<Relation> with a nullary key.  Operators that work
specifically with C<Maybe> subtypes can provide a syntactic shorthand for
working with sparse data; so Muldis D has something which is conceptually
close to SQL's nullable types without actually having 3-valued logic; it
would probably be convenient for code that round-trips SQL by way of Muldis
D to use the C<Maybe> type.  Its default value has zero tuples.

=head2 sys.Core.Relation.Nothing

A C<Nothing> is a proper subtype of C<Maybe> that has exactly zero
elements; its cardinality is 1 and its only value is its default.  The
single C<Nothing> value, which is a relation with zero tuples and a single
attribute named C<value>, is Muldis D's answer to the SQL NULL and is
intended to be used for the same purposes; that is, a special marker for
missing or inapplicable information, that does not typically equal any
normal/scalar value; however, in Muldis D, C<Nothing> I<is a value>, and it
I<is> equal to itself.

=head2 sys.Core.Relation.Single

A C<Single> is a proper subtype of C<Maybe> that has exactly 1 element.
Its default value's only tuple's only attribute has the value
C<Bool:false>.  The C<Single> type is complementary to the C<Nothing> type
under C<Maybe>; C<Nothing> consists of exactly 1 of C<Maybe>'s values, and
C<Single> consists of all of C<Maybe>'s other values.

=head2 sys.Core.Relation.Seq

A C<Seq> is a proper subtype of C<Relation> that has 2 attributes, and
their names are C<index> and C<value>, where C<index> is a unary key and
its declared type is a C<UInt> subtype (C<value> can be non-unique and of
any declared type).  A Seq is considered dense, and all C<index> values in
one are numbered consecutively from 0 to 1 less than the count of tuples,
like array indices in typical programming languages.  A C<Seq> subtype is
normally used by any system-defined N-ary operators where the order of
their argument elements or result is significant (and duplicate values are
significant); specifically, C<index> defines an explicit ordering for
C<value>.  Its default value has zero tuples.

=head2 sys.Core.Relation.Bag

A C<Bag> (or I<multiset>) is a proper subtype of C<Relation> that has 2
attributes, and their names are C<value> and C<count>, where C<value> is a
unary key (that can have any declared type) and C<count> is a C<PInt>
subtype.  A C<Bag> subtype is normally used by any system-defined N-ary
operators where the order of their argument elements or result is not
significant, but that duplicate values are significant; specifically,
C<count> defines an explicit count of occurrences for C<value>, also known
as that value's I<multiplicity>.  Its default value has zero tuples.

=head1 SYSTEM-DEFINED CORE QUASI-SCALAR DATA TYPES

There are no system-defined normal quasi-scalar types; the only reason the
following exist is to provide a maximal type of any user-defined ones that
may come to exist.

=over

=item C<sys.Core.QuasiScalar.QuasiScalar>

The C<QuasiScalar> type is the maximal type of all Muldis D quasi-scalar
types, and contains every quasi-scalar value that can possibly exist.  Its
default value is C<QuasiScalar.E_D:default>.  The cardinality of this type
is infinity.

=item C<sys.Core.QuasiScalar.E_D>

A C<QuasiScalar.E_D> is an enumeration consisting of the 1 value
C<QuasiScalar.E_D:default>, which is also its default value.  The only
reason it exists is to provide a default value for the QuasiScalar union
type.  The cardinality of this type is 1.

=back

=head1 SYSTEM-DEFINED CORE QUASI-NONSCALAR PARAMETERIZED DATA TYPES

These quasi-nonscalar incomplete data type definitions correspond to their
similarly-named (differing only by the C<Quasi>) nonscalar data types, and
their use is intended to be limited to the few situations where the
corresponding nonscalar data types can't be used.  It should be noted in
particular that there is no "QuasiDatabase" type, since all normal data or
catalog databases should be composed of normal relations only; but all of
the other nonscalar incomplete types have counterparts here.

=head2 sys.Core.QuasiTuple.QuasiTuple

A C<QuasiTuple> is like a C<Tuple> but that the declared types of its
attributes can be anything at all.  Its cardinality is infinite.

=head2 sys.Core.QuasiTuple.D0

A C<QuasiTuple.D0> is a proper subtype of C<QuasiTuple> in the
corresponding manner to C<Tuple.D0> being a proper subtype of C<Tuple>.
Its cardinality is 1.

=head2 sys.Core.QuasiTuple.QuasiSetElem

A C<QuasiSetElem> is a C<QuasiTuple> with the same heading as C<QuasiSet>.

=head2 sys.Core.QuasiTuple.QuasiSeqElem

A C<QuasiSeqElem> is a C<QuasiTuple> with the same heading as C<QuasiSeq>.

=head2 sys.Core.QuasiTuple.QuasiBagElem

A C<QuasiBagElem> is a C<QuasiTuple> with the same heading as C<QuasiBag>.

=head2 sys.Core.QuasiRelation.QuasiRelation

A C<QuasiRelation> is like a C<Relation> but that the declared types of its
attributes can be anything at all.  Its cardinality is infinite.

=head2 sys.Core.QuasiRelation.D0

A C<QuasiRelation.D0> is a proper subtype of C<QuasiRelation> in the
corresponding manner to C<Relation.D0> being a proper subtype of
C<Relation>.  Its cardinality is 2.

=head2 sys.Core.QuasiRelation.QuasiSet

A C<QuasiSet> is a proper subtype of C<QuasiRelation> in the corresponding
manner to C<Set> being a proper subtype of C<Relation>.  Its cardinality is
infinite.

=head2 sys.Core.QuasiRelation.QuasiMaybe

A C<QuasiMaybe> is a proper subtype of C<QuasiSet> in the corresponding
manner to C<Maybe> being a proper subtype of C<Set>. Its cardinality is
infinite.

=head2 sys.Core.QuasiRelation.QuasiNothing

A C<QuasiNothing> is a proper subtype of C<QuasiMaybe> in the corresponding
manner to C<Nothing> being a proper subtype of C<Maybe>.  Its cardinality
is 1.

=head2 sys.Core.QuasiRelation.QuasiSingle

A C<QuasiSingle> is a proper subtype of C<QuasiMaybe> in the corresponding
manner to C<Single> being a proper subtype of C<Maybe>.  Its cardinality is
infinite.

=head2 sys.Core.QuasiRelation.QuasiSeq

A C<QuasiSeq> is a proper subtype of C<QuasiRelation> in the corresponding
manner to C<Seq> being a proper subtype of C<Relation>.  Its cardinality is
infinite.

=head2 sys.Core.QuasiRelation.QuasiBag

A C<QuasiBag> is a proper subtype of C<QuasiRelation> in the corresponding
manner to C<Bag> being a proper subtype of C<Relation>.  Its cardinality is
infinite.

=head1 SYSTEM-DEFINED REMNANT TYPES

These core data types are mainly for use with the definitions of some
polymorphic operators whose range of possibly acceptable values may be
mutually incompatible, and they aren't appropriate to group into other type
categories or namespaces.

=head2 sys.Core.Remnant.Remnant

The C<Remnant> type is a partially redundant maximal type of all Muldis D
remnant types.  Its default value is C<Bool:false> by way of its
C<ScaTupRel> subtype.  The cardinality of this type is infinity.

=head2 sys.Core.Remnant.ScaTupRel

The C<ScaTupRel> type is a union type over C<Scalar>, C<Tuple> and
C<Relation>; it is mainly useful in describing the possible range of types
of attributes of scalar possreps or tuples or relations.  Its default value
is C<Bool:false>.

=head1 SYSTEM-DEFINED CORE CATALOG SCALAR DATA TYPES

These core scalar data types are more special-purpose in nature and are
intended for use in defining or working with the system catalog, which is
mainly composed of nonscalar types built using these.

=head2 sys.Core.Cat.ScalarLiteral

A C<Cat.ScalarLiteral> is a union type over all the system-defined scalar
types that are allowed to be used directly as hard-coded literal values in
Muldis D expressions; 'directly' meaning not by way of explicitly invoking
a selector function.  Generally speaking, this union type includes all of
the core scalar types that aren't themselves defined as union types.  The
full list that C<ScalarLiteral> unions is: C<Bool>, C<Int>, C<Rat>,
C<Blob>, C<Text>, C<Cat.Name>, C<Cat.NameChain>, C<Cat.Comment>,
C<Cat.E_RM>, C<Cat.E_TK>, C<Cat.E_TDM>, C<Cat.E_ENK>, C<Cat.E_PSAK>.  Its
default value is C<Bool:false>.

=head2 sys.Core.Cat.Name

A C<Cat.Name> is a canonical short name for any kind of DBMS entity (or
named component) when declaring it; this short name is sufficient to
identify the entity within its immediate namespace.  Similarly, a DBMS
entity can often be invoked or referred to using just its C<Cat.Name>,
depending on the context; other times, a C<Cat.NameChain> must be used
instead to also qualify the reference with a namespace.  C<Cat.Name> is the
same as C<Text> in all ways but that it is specifically intended for use in
naming DBMS entities rather than being normal data.

=head2 sys.Core.Cat.NameChain

A C<Cat.NameChain> is a canonical long name for invoking or referring to a
DBMS entity, when its name needs to be qualified with a namespace.  A
C<Cat.NameChain> has 2 possreps; one possrep is a sequence of 1..N
C<Cat.Name> (represented by a C<Cat.NESeqOfName>), the 1..N elements being
ordered from parent-most to child-most component name; the other possrep is
a character string (represented by a C<Cat.FlattenedNameChain>) like when
the elements of the first possrep are catenated (in order with the first
element at the start of the string), with a period (C<.>) between the
parts, and each part escaped such that backslashes, single-quotes, and
periods are escaped as C<\b>, C<\q> and C<\p> respectively.

=head2 sys.Core.Cat.FlattenedNameChain

The C<Cat.FlattenedNameChain> type is used as the definition of the
character string possrep of a C<Cat.NameChain> (see that type for details);
while being a character string like C<Cat.Name>, the two are disjoint.

=head2 sys.Core.Cat.Comment

A C<Cat.Comment> is the text of a Muldis D code comment, which programmers
can populate as an attribute of several catalog data types, such as whole
routines or statements or expression nodes.  C<Cat.Comment> is the same as
C<Text>, and C<Name>, in all ways but that it is specifically intended for
use in commenting Muldis D code rather than being normal data; they are
disjoint.  One main intended use of this type is to help preserve comments
in code translated to or from other languages; though only a subset of
those (FoxPro?) keep comments in the AST rather than discarding them.

=head2 sys.Core.Cat.PInt1_4

A C<Cat.PInt1_4> is a proper subtype of C<PInt> where all member values are
between 1 and 4.  Its maximum value is 4.  The cardinality of this type is
4.

=head2 sys.Core.Cat.PInt2_N

A C<Cat.PInt2_N> is a proper subtype of C<PInt> where all member values are
greater than 1.  Its default and minimum value is 2.

=head2 sys.Core.Cat.PInt2_36

A C<Cat.PInt2_36> is a proper subtype of C<Cat.PInt2_N> where all member
values are between 2 and 36.  (The significance of the number 36 is 10
digits plus 26 letters.)  Its maximum value is 36.  The cardinality of this
type is 35.

=head2 sys.Core.Cat.E_RM

A C<Cat.E_RM> (rounding method) is an enumeration consisting of the 7
values C<Cat.E_RM:half_down>, C<Cat.E_RM:half_up>, C<Cat.E_RM:half_even>,
C<Cat.E_RM:to_floor>, C<Cat.E_RM:to_ceiling>, C<Cat.E_RM:to_zero>,
C<Cat.E_RM:to_inf>.  When a value of some ordered type needs to be mapped
into a proper subtype that doesn't contain that value, such as when mapping
an arbitrary number to one with less precision, some rounding method is
applied to determine which value of the subtype is to be mapped to while
most accurately reflecting the original value.  The C<Cat.E_RM> type
enumerates the rounding methods that Muldis D operators can typically
apply.  With C<half_down>, C<half_up>, and C<half_even> (aka I<unbiased
rounding>, I<convergent rounding>, I<statistician's rounding>, or
I<bankers' rounding>), the original value will be mapped to the single
target value that it is closest to, if there is one; otherwise, if it is
exactly half-way between 2 adjacent target values, then C<half_down> will
round towards negative infinity, C<half_up> will round towards positive
infinity, and C<half_even> will round towards the nearest "even" target.
With C<to_floor>, C<to_ceiling>, C<to_zero> (aka I<truncate>), C<to_inf>,
the original value will always be mapped to the single adjacent value that
is lower than it, or higher than it, or towards "zero" from it, or towards
the nearer infinity from it, respectively.  The default value of
C<Cat.E_RM> is C<Cat.E_RM:half_up>, since that is the most commonly used
method of rounding.

=head2 sys.Core.Cat.E_TK

A C<Cat.E_TK> (type kind) is an enumeration consisting of the 8 values
C<Cat.E_TK:special> (mainly for system-defined implicit supertypes),
C<Cat.E_TK:scalar>, C<Cat.E_TK:tuple>, C<Cat.E_TK:relation>,
C<Cat.E_TK:quasi_scalar>, C<Cat.E_TK:quasi_tuple>,
C<Cat.E_TK:quasi_relation>, C<Cat.E_TK:remnant>.  Its default value is
C<Cat.E_TK:scalar>.

=head2 sys.Core.Cat.E_TDM

A C<Cat.E_TDM> (type definition method) is an enumeration consisting of the
9 values C<Cat.E_TDM:special> (for some system-defined types that don't
best fit in other categories, and all parameterized types; users can not
define the latter for now), C<Cat.E_TDM:root> (complete root type defined
in terms of explicit attribute collection; all are fully defined, not
parameterized), C<Cat.E_TDM:restriction> (defined as "explicit other-type
where condition"), C<Cat.E_TDM:alias> (so the same one type can have
multiple names), C<Cat.E_TDM:(union|intersection|exclusion)> (defined as
explicit union|intersection|exclusion of other types),
C<Cat.E_TDM:difference> (defined as explicit difference of 2 other types),
C<Cat.E_TDM:negation> (defined as explicit negation of another type).  Its
default value is C<Cat.E_TDM:alias>.

=head2 sys.Core.Cat.E_ENK

A C<Cat.E_ENK> (expression node kind) is an enumeration consisting of the
11 values C<Cat.E_ENK:default> (default value of expression's declared
type),
C<Cat.E_ENK:(scalar|tuple|relation|quasi_scalar|quasi_tuple|quasi_relation)
> (hard-coded literal
scalar|tuple|relation|quasi-scalar|quasi-tuple|quasi-relation value),
C<Cat.E_ENK:param> (value of expression-containing function parameter),
C<Cat.E_ENK:upd_param> (on-entry value of expression-containing update
operator subject-to-update parameter), C<Cat.E_ENK:ro_param> (value of
expression-containing update operator read-only parameter),
C<Cat.E_ENK:func> (result of function invocation, or inlining of function
body).  Note that only C<upd_param> and C<func> (over C<upd_param>) can be
used for a subject-to-update argument of an update operator, but all of
these can be used elsewhere.  Its default value is C<Cat.E_ENK:scalar>.

=head2 sys.Core.Cat.E_PSAK

A C<Cat.E_PSAK> (procedural statement argument kind) is an enumeration
consisting of the 5 values C<Cat.E_PSAK:default> (default value of
argument's declared type), C<Cat.E_PSAK:upd_param> (current value of
statement-containing procedure subject-to-update parameter),
C<Cat.E_PSAK:ro_param> (value of statement-containing procedure read-only
parameter), C<Cat.E_PSAK:inner_var> (current value of statement-containing
procedure lexical variable, not param), C<Cat.E_PSAK:outer_var> (current
value of a non-lexical variable).  Note that only C<upd_param> and
C<(inner|outer)_var> can be used for a subject-to-update argument, but all
of these can be used with a read-only argument.  Its default value is
C<Cat.E_PSAK:ro_param>.

=head1 SYSTEM-DEFINED CORE CATALOG TUPLE DATA TYPES

These tuple data types, essentially all of the system-defined tuple types
are special-purpose in nature and are intended for use in defining or
working with the system catalog.  They are all completely defined types.

Note that many of these types might conceptually have C<name> attributes,
but those would actually be provided by any larger types in which they are
embedded, rather than by these types themselves.

Note that whenever an attribute of one of these types isn't significant,
given the context (determined by other attributes of the same type), and
should be ignored, its value is the default for its type.

I<To keep things simpler for now, most constraint definitions for these
types are missing, or just defined informally.>

=head2 sys.Core.Cat.RatRoundRule

A C<Cat.RatRoundRule> is a C<Tuple>.  It specifies a controlled (and
typically degrading) coercion of a real number into a rational number
having a specific radix and precision.  It is mainly used to
deterministically massage an operation, whose conceptual result is
generally an irrational number, so that its actual result is a best
approximating rational number.  It is also used to define a generic
rounding operation on a rational number that derives a typically less
precise rational.  A C<Cat.RatRoundRule> has these 3 attributes: C<radix>
(a C<Cat.PInt2_N>), C<max_denom> (a C<PInt>), and C<round_meth> (a
C<Cat.E_RM>).  The rational resulting from the operation is as close as
possible to the conceptual result but that its denominator is a
non-negative power of C<radix> and said denominator is not larger than
C<max_denom>; if rounding is needed, then C<round> dictates the rounding
method.  The default value of C<Cat.RatRoundRule> specifies a coersion to a
whole number using the C<Cat.E_RM:half_up> rounding method (its radix is 2
and its max denom is 1).

=head2 sys.Core.Cat.Type

A C<Cat.Type> is a C<Tuple>.  It defines a data type, which can either be
(sometimes) invoked directly for values, or be invoked by or embedded into
other type definitions.  C<Cat.Type> is used in the catalogs for defining
both system and user types (just the interfaces in the former case).

I<TODO:  The catalog types for type definitions need an overhaul.>

A C<Cat.Type> has these 8 attributes:

=over

=item C<tk> - C<Cat.E_TK>

This broadly declares what kind of type this is (eg,
scalar|tuple|relation); it partially says how to interpret the rest of the
attributes and/or which of them have significant values.

=item C<tdm> - C<Cat.E_TDM>

This is the type definition method for the type; it partially says how to
interpret the rest of the attributes and/or which of them have significant
values.  If C<tk> is C<Cat.E_TK:special>, then C<tdm> must be
C<Cat.E_TDM:special>; C<tdm> can be special at other times too.

=item C<types> - C<Cat.SetOfNameChain>

For some values of C<tdm>, the data type is defined at least partially in
terms of other data types not by way of attribute definitions, and then
C<types> lists all/most of those types.  Iff C<tdm> is C<Cat.E_TDM:alias>,
then the data type is just a symbolic reference for some other data type
(as far as the type system is concerned, they are the same data type,
invokable by an extra name), and C<types> has one element that is the name
of that type.  Iff C<tdm> is C<Cat.E_TDM:restriction>, then the data type
is defined as an explicit subtype of another type by way of an explicit
further type constraint applied to it, and C<types> has one element that is
the name of that supertype.  Iff C<tdm> is
C<Cat.E_TDM:(union|intersection|exclusion)>, then the data type is defined
as an explicit union|intersection|exclusion of N other types, and C<types>
lists their names, one per element; 2+ elements is the norm; just 1 element
means that the data type is a simple alias for the named element; zero
elements means the data type is a simple alias for, respectively, the type
C<Empty>, C<Universal>, or C<Empty>.  Iff C<tdm> is
C<Cat.E_TDM.difference>, then the data type is defined as the difference of
2 other types, and C<types> has one element that is the name of the minuend
type.  Iff C<tdm> is C<Cat.E_TDM.negation>, then the data type is defined
as the negation of some other type, and C<types> has one element that is
the name of that type.

=item C<subtr_type> - C<Cat.NameChain>

Iff C<tdm> is C<Cat.E_TDM.difference>, then the data type is defined as the
difference of 2 other types, and C<subtr_type> is the name of the
subtrahend type.

=item C<attrs> - C<Cat.NameTypeMap>

Iff C<tdm> is C<Cat.E_TDM:root>, then the data type is defined
fundamentally in terms of an explicit attribute collection, and C<attrs>
defines the names and declared types of those attributes.  Iff additionally
C<tk> is C<Cat.E_TK:(scalar|quasi_scalar)>, then C<attrs> specifically
defines the attributes of just the core/initial/only possrep; otherwise,
C<attrs> defines the heading of the tuple or relation etc type.  It is
valid to have zero attributes; in this case, the type consists of exactly
one value.

=item C<keys> - C<Cat.SetOfSetOfName>

Iff C<tk> is C<Cat.E_TK:(relation|quasi_relation)> and C<tdm> is not
C<Cat.E_TDM:special>, then the data type is or resembles a relation type
and can have explicit keys (duality of unique key constraints and terser
unique identifiers for the q/relation's member q/tuples) defined over its
attributes, and C<keys> defines those keys in the canonical simplest form
(in contrast with using C<constraint> instead).  Each element of C<keys>
defines one key of the q/relation, and that element is a set of the
attribute names comprising that key.  For q/relation types, if no keys are
explicitly defined, then it implicitly has a single key comprising all of
its attributes.  If any explicit keys are defined, then every one must be
over a distinct proper subset of the type's attributes, and moreover no
key's attributes may be a proper subset of any other key's attributes; if 2
such candidates appear, just use the one that has the subset.  It is valid
for a key to consist of zero attributes; in this case, that key is the only
key of the q/relation type, and values of the type may each consist of no
more than one tuple.

=item C<constraint> - C<Cat.TypeConstraint> ... default one always res True

Iff C<tdm> is C<Cat.E_TDM:root>, then the data type is defined
fundamentally in terms of an explicit attribute collection, and
C<constraint> defines/names a generalized type constraint that validates
the collection as a whole.  Iff C<tdm> is C<Cat.E_TDM:restriction>, then
the data type is defined as an explicit subtype of another type by way of
an explicit further type constraint applied to it, and C<constraint>
defines/names that further constraint.

=item C<comment> - C<Cat.Comment>

This is an optional programmer comment about the data type.

=back

The default value of C<Cat.Type> is an alias of C<Empty>.

=head2 sys.Core.Cat.ExprNode

A C<Cat.ExprNode> is a C<Tuple>.  It specifies a named expression node,
which is the majority component of functional Muldis D code.  All
arbitrarily complex Muldis D expression trees, including relational
queries, are composed of just C<Cat.ExprNode>, either directly, or
indirectly by way of function invocations, as each function body is itself
composed entirely of a single expression tree (of at least 1 node).  Only
functions and update operators may contain C<Cat.ExprNode>, so for any
procedures that would conceptually include them, those portions of the
procedures need to be separated out and encapsulated by named functions or
inner-functions or update operators or inner-update-operators.  Note that,
while the general case has expression trees simply denoting a value, in
some cases they may instead define a pseudo-variable / virtual variable;
that only happens in update operators where the expression is used as an
argument for a subject-to-update parameter of an update operator call; in
that case the leaf nodes / only node of the expression must map to a
subject-to-update parameter of the containing update operator.

A C<Cat.ExprNode> has these 9 attributes:

=over

=item C<name> - C<Cat.Name>

This is the declared name of the expression node; other Muldis D code that
is composing this expression node into their own definitions would
reference it with this name.

=item C<type> - C<Cat.NameChain>

This is the declared result data type of the expression node.  If the
expression node represents a literal value, this is often necessary for
properly interpreting the details of that literal, particularly for
literals that are not scalar.  Otherwise, although the result type of an
expression can sometimes be inferred from context, such as from the result
type of a function it is an invocation of, this redundancy helps make
static analysis of Muldis D code easier, so it is easier to validate and
optimize in isolation from the other routines it interacts with.  Moreover,
this type declaration provides a terse way to use the C<treated> function
frequently in code, so that the programmer and compiler knows that some
generic routines are actually supposed to be resulting in a subtype of
their normal result types.

=item C<kind> - C<Cat.E_ENK>

This is the declared kind of expression that this node is; it says how to
interpret the rest of the attributes and/or which of them have significant
values.

=item C<scal_lit> - C<Cat.ScalarLiteral>

Iff C<kind> is C<Cat.E_ENK:scalar>, then the expression represents a
hard-coded scalar literal of one of a certain collection of system-defined
core scalar types (or subtype thereof), and this is that literal value.

=item C<coll_lit> - C<Cat.SetOfNameExprMap>

Iff C<kind> is C<Cat.E_ENK:(|quasi_)(tuple|relation)>, then the expression
represents a collection literal, and these are the values of its
components.  Each element defines one tuple, and each sub-element of that
element defines one attribute value for one tuple, with the sub-element
C<name> matching the attribute name, and the sub-element C<expr> naming
another local C<Cat.ExprNode> which defines the value.  The value of
C<coll_lit> defines exactly one tuple when C<kind> specifies a tuple or
quasi-tuple, and it defines 0..N tuples when C<kind> specifies a relation
or quasi-relation.

=item C<param> - C<Cat.Name>

Iff C<kind> is C<Cat.E_ENK:param>, then the expression represents the value
of the containing function's parameter which this names.  Or, if C<kind> is
C<Cat.E_ENK:upd_param> or C<Cat.E_ENK:ro_param>, then the expression
represents the on-entry value or value of the containing update operator's
subject-to-update or read-only parameter, respectively.

=item C<func> - C<Cat.NameChain>

Iff C<kind> is C<Cat.E_ENK:func>, then the expression represents the result
of invoking a named function with specific arguments, and this the name of
that function.

=item C<func_args> - C<Cat.NameExprMap>

Iff C<func> is used, then these are the arguments for the function
invocation.  Each element defines one argument value, with the element
C<name> matching the parameter name, and the element C<expr> naming another
local C<ExprNode> which defines the value.

=item C<comment> - C<Cat.Comment>

This is an optional programmer comment about either the expression node or
the expression node (sub-)tree it is the root of.

=back

The default value of C<Cat.ExprNode> has an empty name and represents the
literal scalar value C<Bool:false>.

=head2 sys.Core.Cat.InnerFunc

A C<Cat.InnerFunc> is a C<Tuple>.  It specifies a named C<inner_function>
routine, which is the main component type of a complete routine; a complete
function consists of at least one inner function, which is its main body,
plus more when it would conceptually be using anonymous inline function
definitions (to pass to function-valued function arguments), or when it
would conceptually have self-referencing/cyclic expressions.

A C<Cat.InnerFunc> has these 6 attributes:

=over

=item C<name> - C<Cat.Name>

This is the declared name of the inner function within its parent complete
function; other Muldis D code within said complete function would reference
it with this name.

=item C<result_type> - C<Cat.NameChain>

This is the declared result data type of the inner function as a whole.

=item C<is_recursive> - C<Bool>

This is C<Bool:true> if the inner function might possibly invoke itself,
either directly or indirectly; it is C<Bool:false> if it promises to never
be recursive.  Note that the C<is_recursive> attribute does not make any
claims regarding the actions of any anonymous functions that it is passed
as function-valued arguments, which may cause this inner function to be
involved in a recursion even if C<is_recursive> is C<Bool:false>.  I<Note
that this may be changed later, or the attribute simply be eliminated.>

=item C<params> - C<Cat.NameTypeMap>

This is the declared parameter list of the inner function, which has 0..N
named and typed parameters.

=item C<expr> - C<Cat.ExprTree>

This defines the entire body of the inner function, which is composed of a
single expression tree, whose root node's name is the empty string.  This
expression tree must reference all of the parameters that the inner
function has.

=item C<comment> - C<Cat.Comment>

This is an optional programmer comment about the inner function as a whole.

=back

The default value of C<Cat.InnerFunc> has an empty name and unconditionally
results in the literal scalar value C<Bool:false>.

=head2 sys.Core.Cat.Func

A C<Cat.Func> is a C<Tuple>.  It specifies a named C<function> routine,
which is conceptually a non-anonymous function that is generally invokable
by the public (unless its parent package says otherwise).

A C<Cat.Func> has these 3 attributes:

=over

=item C<name> - C<Cat.Name>

This is the declared name of the function; other Muldis D code would
reference it with this name.

=item C<inner_funcs> - C<Cat.InnerFuncTree>

This defines the entire body of the function (both its main body plus any
conceptually expression-inlined anonymous functions), which is composed of
one or more inner functions, plus its public interface / parameter list,
which is defined by one of those.  The inner function defining the outer
function's main body has the empty string as its name.

=item C<comment> - C<Cat.Comment>

This is an optional programmer comment about the function as a whole.

=back

The default value of C<Cat.Func> unconditionally results in the literal
scalar value C<Bool:false> as per the default of C<Cat.InnerFunc>.

=head2 sys.Core.Cat.UpdStmt

A C<Cat.UpdStmt> is a C<Tuple>.  It specifies a single update statement (of
1..N variables), which is the most fundamental component of procedural
Muldis D code, and is what the body of an update operator routine is
composed of.  The variables being updated are accessed via the host
routine's subject-to-update parameters.  All arbitrarily complex Muldis D
value assignments, including relational assignments, are composed of just
C<Cat.UpdStmt>, either directly, or indirectly by way of update operator
invocations, as each update operator body is itself composed entirely of 1
or more update statements (grouped as 1 multi-update).  Only update
operators may contain C<Cat.UpdStmt>, so for any procedures that would
conceptually include them, those portions of the procedures need to be
separated out and encapsulated by named update operators or
inner-update-operators.

A C<Cat.UpdStmt> has these 4 attributes:

=over

=item C<updater> - C<Cat.NameChain>

Every update statement is an invocation of some other update operator (or
inner-update-operator), either a user-defined or system-defined one (the
latter generally being the end of the call chain); this is the name of that
update operator.

=item C<upd_args> - C<Cat.NameExprMap>

These are the 1..N subject-to-update arguments to the update operator
invocation, as-per C<ro_args>.  But since each expression tree in
C<upd_args> is binding to a subject-to-update parameter, the expression
tree actually is defining a pseudo-variable / virtual-variable over 1..N
containing routine subject-to-update parameters; in the most trivial (and
common) case, such an expression tree is a single node that represents said
parameter without any indirection at all.

=item C<ro_args> - C<Cat.NameExprMap>

These are the 0..N read-only arguments to the update operator invocation.
Each element defines one argument value, with the element C<name> matching
the parameter name, and the element C<expr> naming a local C<ExprNode>
which defines the value.

=item C<comment> - C<Cat.Comment>

This is an optional programmer comment about the update statement as a
whole.

=back

The default value of C<Cat.UpdStmt> will unconditionally update 1
subject-to-update parameter of name C<topic> with the value C<Bool:false>.

=head2 sys.Core.Cat.InnerUpdater

A C<Cat.InnerUpdater> is a C<Tuple>.  It specifies a named C<updater>
routine, which is the main component type of a complete implicitly atomic
procedural routine; a complete update operator consists of at least one
inner update operator, which is its main body, likely plus more when it
would conceptually be code refactored.

A C<Cat.InnerUpdater> has these 7 attributes:

=over

=item C<name> - C<Cat.Name>

This is the declared name of the inner update operator within its parent
complete update operator; other Muldis D code within said complete update
operator would reference it with this name.

=item C<is_recursive> - C<Bool>

This is C<Bool:true> if the inner update operator might possibly invoke
itself, either directly or indirectly; it is C<Bool:false> if it promises
to never be recursive.  I<Note that this attribute may be eliminated.>

=item C<upd_params> - C<Cat.NameTypeMap>

This is the declared subject-to-update parameter list of the inner update
operator, which has 1..N named and typed such parameters.  It must have at
least 1 element.

=item C<ro_params> - C<Cat.NameTypeMap>

This is the declared read-only parameter list of the inner update operator,
which has 0..N named and typed such parameters.  There is a distributed
(unique) key over the C<name> attributes of C<upd_params> and C<ro_params>.

=item C<exprs> - C<Cat.ExprSet>

This defines the expression trees that are arguments to the update
operators that C<stmt> invokes.  These expression trees must reference all
of the parameters that the inner update operator has.

=item C<stmt> - C<Cat.MultiUpdStmt>

This defines the entire body of the inner update operator, which is
composed of a single multi-update statement.  This multi-update statement
must reference all of the parameters that the inner update operator has.

=item C<comment> - C<Cat.Comment>

This is an optional programmer comment about the inner updater as a whole.

=back

The default value of C<Cat.InnerUpdater> has an empty name and has 1
subject-to-update parameter named C<topic> and declared type C<Bool> and
will unconditionally update it to the value C<Bool:false>; it has zero
read-only parameters.

=head2 sys.Core.Cat.Updater

A C<Cat.Updater> is a C<Tuple>.  It specifies a named C<update operator>
routine, which is conceptually a non-anonymous update operator that is
generally invokable by the public (unless its parent package says
otherwise).

A C<Cat.Updater> has these 4 attributes:

=over

=item C<name> - C<Cat.Name>

This is the declared name of the update operator; other Muldis D code would
reference it with this name.

=item C<inner_updaters> - C<Cat.InnerUpdaterTree>

This (save for C<inner_funcs>) defines the entire body of the update
operator, which is composed of one or more inner update operators, plus its
public interface / parameter list, which is defined by one of those.  The
inner updater defining the outer updater's main body has the empty string
as its name.

=item C<inner_funcs> - C<Cat.InnerFuncSet>

This also contributes to the body of the update operator.

=item C<comment> - C<Cat.Comment>

This is an optional programmer comment about the updater as a whole.

=back

The default value of C<Cat.Updater> is as per the default of
C<Cat.InnerUpdater>.

=head2 sys.Core.Cat.ProcStmtArg

A C<Cat.ProcStmtArg> is a C<Tuple>.  It specifies a named argument for a
procedural routine invocation done as a procedure statement, and is
composed into the C<Cat.ProcStmt> definition of said statement.

A C<Cat.ProcStmtArg> has these 7 attributes:

=over

=item C<name> - C<Cat.Name>

This is the declared name of the invoked procedural routine's parameter
(either subject-to-update or read-only) that this argument is binding to.

=item C<type> - C<Cat.NameChain>

This is as per the C<type> attribute of a C<Cat.ExprNode>, but applying to
the declared data type of the argument.

=item C<kind> - C<Cat.E_PSAK>

This is the declared kind of value that this argument is; it says how to
interpret the rest of the attributes and/or which of them have significant
values.

=item C<param> - C<Cat.Name>

Iff C<kind> is C<Cat.E_PSAK:upd_param> or C<Cat.E_PSAK:ro_param>, then the
argument is the current value or value of the containing procedure's
subject-to-update or read-only parameter, respectively.

=item C<inner_var> - C<Cat.Name>

Iff C<kind> is C<Cat.E_PSAK:inner_var>, then the argument is the current
value of a lexical variable that isn't a parameter.

=item C<outer_var> - C<Cat.NameChain>

Iff C<kind> is C<Cat.E_PSAK:outer_var>, then the argument is the current
value of a non-lexical variable.

=item C<comment> - C<Cat.Comment>

This is an optional programmer comment about the statement argument.

=back

The default value of C<Cat.ProcStmtArg> will bind to a read-only parameter
of name C<topic> with a value of the containing procedure's read-only
parameter named C<topic>.

=head2 sys.Core.Cat.ProcStmt

A C<Cat.ProcStmt> is a C<Tuple>.  It specifies a generic statement from
which non-implicitly-atomic procedural Muldis D code is composed.  Only
procedures (or inner procedures) may contain C<Cat.ProcStmt>.

A C<Cat.ProcStmt> has these 4 attributes:

=over

=item C<proc> - C<Cat.NameChain>

Every procedure statement is an invocation of some other procedural routine
(eg, procedure, update operator, system service), either user-defined or
system-defined; this is the name of that routine.

=item C<upd_args> - C<Cat.ProcStmtArgSet>

These are the 0..N subject-to-update arguments to the routine invocation,
as-per C<ro_args>.

=item C<ro_args> - C<Cat.ProcStmtArgSet>

These are the 0..N read-only arguments to the routine invocation.  There is
a distributed (unique) key over the C<name> attributes of C<upd_params> and
C<ro_params>.

=item C<comment> - C<Cat.Comment>

This is an optional programmer comment about the statement as a whole.

=back

The default value of C<Cat.ProcStmt> will invoke
C<sys.Core.Universal.assign>, giving it arguments from same-named and typed
parameters.

=head2 sys.Core.Cat.InnerProc

A C<Cat.InnerProc> is a C<Tuple>.  It specifies a named C<procedure>
routine, which is the main component type of a complete procedure; a
complete procedure consists of at least one inner procedure, which is its
main body, likely plus more when it would conceptually be code refactored.

A C<Cat.InnerProc> has these 7 attributes:

=over

=item C<name> - C<Cat.Name>

This is the declared name of the inner procedure within its parent complete
procedure; other Muldis D code within said complete procedure would
reference it with this name.

=item C<is_recursive> - C<Bool>

This is C<Bool:true> if the inner procedure might possibly invoke
itself, either directly or indirectly; it is C<Bool:false> if it promises
to never be recursive.  I<Note that this attribute may be eliminated.>

=item C<upd_params> - C<Cat.NameTypeMap>

This is the declared subject-to-update parameter list of the inner
procedure, which has 0..N named and typed such parameters.

=item C<ro_params> - C<Cat.NameTypeMap>

This is the declared read-only parameter list of the inner procedure,
which has 0..N named and typed such parameters.  There is a distributed
(unique) key over the C<name> attributes of C<upd_params> and C<ro_params>.

=item C<vars> - C<Cat.NameTypeMap>

This defines the 0..N (non-parameter) lexical variables of the inner
procedure; they initialize to the default values of their declared types.

=item C<stmts> - C<Cat.SeqOfProcStmt>

This defines the entire main body of the inner procedure, which is composed
of 0..N procedure statements.  These statements must reference all of the
parameters and lexical variables that the inner procedure has.

=item C<comment> - C<Cat.Comment>

This is an optional programmer comment about the inner procedure as a
whole.

=back

The default value of C<Cat.InnerProc> has an empty name and is a no-op; its
C<name> has the default value of C<Cat.Name>, it has zero parameters, zero
variables, and zero statements.

=head2 sys.Core.Cat.Proc

A C<Cat.Proc> is a C<Tuple>.  It specifies a named C<procedure> routine,
which is conceptually a non-anonymous procedure that is generally invokable
by the public (unless its parent package says otherwise).

A C<Cat.Proc> has these 5 attributes:

=over

=item C<name> - C<Cat.Name>

This is the declared name of the procedure; other Muldis D code would
reference it with this name.

=item C<inner_procs> - C<Cat.InnerProcTree>

This (save for C<inner_updaters> and C<inner_funcs>) defines the entire
body of the procedure, which is composed of one or more inner procedures,
plus its public interface / parameter list, which is defined by one of
those.  The inner procedure defining the outer procedure's main body has
the empty string as its name.

=item C<inner_updaters> - C<Cat.InnerUpdaterSet>

This also contributes to the body of the procedure.

=item C<inner_funcs> - C<Cat.InnerFuncSet>

This also contributes to the body of the procedure.

=item C<comment> - C<Cat.Comment>

This is an optional programmer comment about the procedure as a whole.

=back

The default value of C<Cat.Proc> is as per the default of C<Cat.InnerProc>.

=head2 sys.Core.Cat.Exception

I<TODO.>

=head1 SYSTEM-DEFINED CORE CATALOG RELATION DATA TYPES

These relation data types, essentially all of the system-defined relation
types are special-purpose in nature and are intended for use in defining or
working with the system catalog.  They are all completely defined types.

I<To keep things simpler for now, most constraint definitions for these
types are missing, or just defined informally.>

=head2 sys.Core.Cat.NameTypeMap

A C<Cat.NameTypeMap> is a C<Relation>.  It defines a basic component list,
meaning a set of names, with a declared data type name for each.  It forms
the foundation for most componentized type definitions, including all tuple
and relation types (for which it is named I<heading>), and it is used also
for the components list of a scalar possrep.  It is also used to define
parameter lists for routines.  A C<Cat.NameTypeMap> has 2 attributes,
C<name> (a C<Cat.Name>) and C<type> (a C<Cat.NameChain>); the C<name> is
the declared name of the attribute or parameter, and comprises a unary key;
the C<type> is the declared data type of the attribute or parameter.  Its
default value has zero tuples.

=head2 sys.Core.Cat.NameExprMap

A C<Cat.NameExprMap> is a C<Relation>.  It defines a basic component-values
list, meaning a set of names, with a declared local expression node name
for each.  It is used to define collection literals; one C<Cat.NameExprMap>
defines a whole C<Tuple> value.  It is also used to define argument lists
for routine invocations.  A C<Cat.NameExprMap> has 2 attributes, C<name>
and C<expr>, each of those being a C<Cat.Name>; the C<name> is the name of
the tuple/etc attribute or routine argument, and comprises a unary key; the
C<expr> is the declared local name of the expression node which defines the
value for the attribute or argument.  Its default value has zero tuples.

=head2 sys.Core.Cat.AttrRenameMap

A C<Cat.AttrRenameMap> is a C<Relation>.  It is used as a specification for
how to rename attributes of some collection.  A C<Cat.AttrRenameMap> has 2
attributes, C<before> and C<after>, each of those being a C<Cat.Name>, and
each of those being a unary key.  Its default value has zero tuples.

=head2 sys.Core.Cat.ExprSet

A C<Cat.ExprSet> is the same as a C<Cat.ExprTree> except that it can
represent multiple trees rather than one, and there is no requirement for
any node to be named with the empty string; this is realized in that more
than one (rather than exactly one) member may have none of its peers as a
parent node.  It so happens then that C<Cat.ExprTree> is a proper subtype
of C<Cat.ExprSet>.

=head2 sys.Core.Cat.ExprTree

A C<Cat.ExprTree> is a C<Relation> with the same heading as
C<Cat.ExprNode>; it specifies a simple tree of named expression nodes,
which are its tuples.  It has a unary (unique) key on the C<name>
attribute, and it must have at least 1 member tuple.  All member tuples
must define a simple expression node tree, such that every member except
one (which is the root node) has one of its peers as a parent node, and no
direct cycles between members are permitted (only indirect cycles based on
function / inner-function invocations are allowed); the name of the root
node must be the empty string.  The default value of C<Cat.ExprTree> has
one tuple that is the default value of C<Cat.ExprNode>; the tree represents
the literal scalar value C<Bool:false>.

=head2 sys.Core.Cat.InnerFuncSet

A C<Cat.InnerFuncSet> is a C<Relation> with the same heading as
C<Cat.InnerFunc>; it specifies a set of inner functions (that comprise
parts of the same complete routine), which are its tuples.  It has a unary
(unique) key on the C<name> attribute.  Its default value is empty, which
may be applicable if the complete routine is not a function.

=head2 sys.Core.Cat.InnerFuncTree

A C<Cat.InnerFuncTree> is a proper subtype of C<Cat.InnerFuncSet> which is
likely to only be applicable if the complete routine is a function.  It
must have at least 1 member tuple.  All member tuples must define a single
invocation tree but that cycles are allowed, including any cycles that
invoke what is conceptually the tree root (main function if applicable);
the name of the root node must be the empty string.  The default value of
C<Cat.InnerFuncTree> has one tuple that is the default value of
C<Cat.InnerFunc>.

=head2 sys.Core.Cat.MultiUpdStmt

A C<Cat.MultiUpdStmt> is a C<Relation> with the same heading as
C<Cat.UpdStmt>; it is a multi-update statement, which is the narrowest
scope implicitly atomic component of procedural Muldis D code.  One value
of this type comprises the entire body of an update operator (or
inner-update-operator).  It must have at least 1 member tuple.  The default
value of C<Cat.MultiUpdStmt> has one tuple that is the default value of
C<Cat.UpdStmt>.

=head2 sys.Core.Cat.InnerUpdaterSet

A C<Cat.InnerUpdaterSet> is a C<Relation> with the same heading as
C<Cat.InnerUpdater>; it specifies a set of inner update operators (that
comprise parts of the same complete routine), which are its tuples.  It has
a unary (unique) key on the C<name> attribute.  Its default value is empty,
which may be applicable if the complete routine is not an update operator.

=head2 sys.Core.Cat.InnerUpdaterTree

A C<Cat.InnerUpdaterTree> is a proper subtype of C<Cat.InnerUpdaterSet>
which is likely to only be applicable if the complete routine is a update
operator.  It must have at least 1 member tuple.  All member tuples must
define a single invocation tree but that cycles are allowed, including any
cycles that invoke what is conceptually the tree root (main update operator
if applicable); the name of the root node must be the empty string.  The
default value of C<Cat.InnerUpdaterTree> has one tuple that is the default
value of C<Cat.InnerUpdater>.

=head2 sys.Core.Cat.ProcStmtArgSet

A C<Cat.ProcStmtArgSet> is a C<Relation> with the same heading as
C<Cat.ProcStmtArg>; it specifies a set of arguments to an invocation of a
procedural routine.  It has a unary (unique) key on the C<name> attribute.
Its default value is empty.

=head2 sys.Core.Cat.InnerProcTree

A C<Cat.InnerProcTree> is to C<Cat.InnerProc> what C<Cat.InnerUpdaterTree>
is to C<Cat.InnerUpdater>.

=head2 sys.Core.Cat.SetOfName

A C<Cat.SetOfName> is a C<Set> whose C<value> attribute has a declared type
of C<Cat.Name>.

=head2 sys.Core.Cat.SetOfSetOfName

A C<Cat.SetOfSetOfName> is a C<Set> whose C<value> attribute has a declared
type of C<Cat.SetOfName>.

=head2 sys.Core.Cat.SetOfNameExprMap

A C<Cat.SetOfNameExprMap> is a C<Set> whose C<value> attribute has a
declared type of C<Cat.NameExprMap>.

=head2 sys.Core.Cat.SetOfNameChain

A C<Cat.SetOfNameChain> is a C<Set> whose C<value> attribute has a declared
type of C<Cat.NameChain>.

=head2 sys.Core.Cat.NESeqOfName

A C<Cat.NESeqOfName> is a C<Seq> whose C<value> attribute has a declared
type of C<Cat.Name> and that must have at least 1 element; this type is
used as the definition of the sequence possrep of a C<Cat.NameChain> (see
that type for details).

=head2 sys.Core.Cat.SeqOfProcStmt

A C<Cat.SeqOfProcStmt> is a C<Seq> whose C<value> attribute has a declared
type of C<Cat.ProcStmt>.

=head1 SYSTEM-DEFINED CORE QUASI-CATALOG PARAMETERIZED TYPES

These types are incomplete proper subtypes of other core incomplete types,
and generally speaking their sole purpose is to be the declared data types
of several system-defined N-ary tuple|relation operator parameters which
are collections of generic nonscalar values.  They are called quasi-catalog
because they are not generally expected to be used for user data, but they
also are not used to compose the system catalog either.

=over

=item C<sys.Core.QuasiCat.(Set|Bag)Of(Tuple|Relation)>

A C<(Set|Bag)OfRelation> is an incompletely defined proper subtype of
C<Set|Bag> whose C<value> attribute has a declared type of a
C<Tuple|Relation> subtype; this is the parameter type of several N-ary
relational operators.

=item C<sys.Core.QuasiCat.SetOfBag>

A C<SetOfBag> is an incompletely defined proper subtype of C<Set> whose
C<value> attribute has a declared type of a C<Bag> subtype; this is the
parameter type of several N-ary relational operators that work with C<Bag>
values.

=item C<sys.Core.QuasiCat.MaybeOfTuple>

A C<MaybeOfTuple> is an incompletely defined proper subtype of C<Maybe>
whose C<value> attribute has a declared type of a C<Tuple> subtype; this is
the parameter type of the C<sys.Core.Relation.maybe_reduction> operator.

=item C<sys.Core.QuasiCat.SeqOfSeq>

A C<SeqOfSeq> is an incompletely defined proper subtype of C<Seq> whose
C<value> attribute has a declared type of a C<Seq> subtype; this is the
parameter type of the N-ary C<sys.Core.Seq.catenation> operator.

=item C<sys.Core.QuasiCat.QuasiSetOf(Tuple|Relation)>

A C<QuasiSetOfRelation> is an incompletely defined proper subtype of
C<QuasiSet> whose C<value> attribute has a declared type of
C<Tuple|Relation>; these are the parameter types of the N-ary
C<sys.Core.Tuple.product> and C<sys.Core.Relation.(join|product)>
operators.

=back

=head1 SYSTEM-DEFINED CORE SPECIALIZED SUBTYPES

These types are proper subtypes of other core types, and they are
system-defined for convenience, as they are anticipated to be frequently
used; in fact, most of them are used as the declared parameter types of
various core operators.

=over

=item C<sys.Core.Spec.(Set|Maybe|Seq|Bag)Of(Scalar|Ordered)>

A C<(Set|Maybe|Seq|Bag)Of(Scalar|Ordered)> is a completely defined proper
subtype of C<(Set|Maybe|Seq|Bag)> whose C<value> attribute has a declared
type of a C<(Scalar|Ordered)> subtype.

=item C<sys.Core.Spec.(Set|Maybe|Seq|Bag)Of(Bool|Int|UInt|Rat|Blob|Text)>

A C<(Set|Maybe|Seq|Bag)Of(Bool|Int|UInt|Rat|Blob|Text)> is a completely
defined proper subtype of C<(Set|Maybe|Seq|Bag)> whose C<value> attribute
has a declared type of a C<(Bool|Int|UInt|Rat|Blob|Text)> subtype.

=back

=head1 SEE ALSO

Go to L<Language::MuldisD> for the majority of distribution-internal
references, and L<Language::MuldisD::SeeAlso> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<perl@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright  2002-2008, Darren Duncan.

See the LICENSE AND COPYRIGHT of L<Language::MuldisD> for details.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Language::MuldisD> apply to this file too.

=cut
