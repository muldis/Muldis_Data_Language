=pod

=encoding utf8

=head1 NAME

Language::MuldisD::Grammar -
How to format Concrete Muldis D

=head1 VERSION

This document is Language::MuldisD::Grammar version 0.8.0.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Language::MuldisD>; you should read that root document
before you read this one, which provides subservient details.

=head1 DESCRIPTION

This document outlines the grammar of I<Concrete Muldis D>.  This grammar
is extremely simple such that any program or routine is simply a tuple
literal, which is composed of relation and tuple and scalar literals.
Whether or not these literals are valid is up to the I<Abstract Muldis D>
compiler, whose input is the AST resulting from parsing I<Concrete Muldis
D>.  This grammar primarily tests for well-formedness.

See also, for example, L<Language::MuldisD::PerlHosted> for a description
of the core Perl data structures that you would probably use instead of the
grammar below when using a Muldis D implementation in a Perl application;
moreover, that other document is necessary to understand the meaning of
some parts of this Grammar document.

I<This documentation is pending.>

=head1 GRAMMAR OF CONCRETE MULDIS D

This grammar is formatted as a Perl 6 grammar which could be used to parse
it.  That said, it is only meant to be illustrative, as only some Muldis D
implementations would actually be written in Perl 6 or understand Perl 6
grammars.  The following Perl 6 code does successfully compile using the
current Perl6::Pugs, though it has not yet been tested to execute
correctly.  Any remaining errors should be corrected as soon as possible.

    use v6-alpha;

    # grammar MuldisD:auth<cpan:DUNCAND>:ver<0.8.0>;
    grammar MuldisD-0.8.0-cpan:DUNCAND;

    token start {
        (MuldisD)
        <spec_sep>
        <authority>
        <spec_sep>
        <version>
        <spec_sep>
        <list_open>
            (<literal>)
        <list_close>
    }

    token authority { <quoted_text_str> }

    token version { <quoted_text_str> }

    token literal {
          <bool>
        | <int>
        | <rat>
        | <blob>
        | <text>
        | <tuple>
        | <relation>
        | <cat_name>
        | <cat_name_chain>
        | <cat_order>
        | <cat_e_rm>
        | <cat_e_tk>
        | <cat_e_tdm>
        | <cat_e_enk>
        | <cat_e_psak>
    }

    token bool { (Bool) <spec_sep> (false|true) }

    token int {
          <just_an_int>
        | <uint>
        | <pint>
    }

    token just_an_int {
        (Int)
        <spec_sep>
        (<[1-9A-Z]>)
        <spec_sep>
        (0|\-?<[1-9A-Z]><[0-9A-Z]>*)
    }

    token uint {
        (UInt)
        <spec_sep>
        (<[1-9A-Z]>)
        <spec_sep>
        (0|<[1-9A-Z]><[0-9A-Z]>*)
    }

    token pint {
        (PInt)
        <spec_sep>
        (<[1-9A-Z]>)
        <spec_sep>
        (<[1-9A-Z]><[0-9A-Z]>*)
    }

    token rat {
          rat_with_radix
        | rat_as_int_pair
    }

    token rat_with_radix {
        (Rat)
        <spec_sep>
        (radix)
        <spec_sep>
        (<[1-9A-Z]>)
        <spec_sep>
        (0|\-?<[1-9A-Z]><[0-9A-Z]>*\.?<[0-9A-Z]>*)
    }

    token rat_as_int_pair {
        (Rat)
        <spec_sep>
        (pair)
        <spec_sep>
        (<[1-9A-Z]>)
        <spec_sep>
        ((0|\-?<[1-9A-Z]><[0-9A-Z]>*)\/(<[1-9A-Z]><[0-9A-Z]>*))
    }

    token blob {
        (Blob)
        <spec_sep>
        (<[137F]>)
        <spec_sep>
        (<[0-9A-F]>*)
    }

    token text {
        (Text)
        <spec_sep>
        <quoted_text_str>
    }

    token tuple {
        (Tuple)
        <spec_sep>
        <type_name>
        <spec_sep>
        <tuple_body>
    }

    token relation {
          <just_a_relation>
        | <set>
        | <maybe>
        | <seq>
        | <bag>
    }

    token just_a_relation {
        (Relation)
        <spec_sep>
        <type_name>
        <spec_sep>
        <list_open>
            (((<tuple_body>) <list_sep>)*)
        <list_close>
    }

    token tuple_body {
        <list_open>
            (((<attr>) <list_sep>)*)
        <list_close>
    }

    token attr { <attr_name> <pair_sep> <literal> }

    token attr_name { <quoted_text_str> }

    token set {
        (Set)
        <spec_sep>
        <type_name>
        <spec_sep>
        <list_open>
            (((<literal>) <list_sep>)*)
        <list_close>
    }

    token maybe {
        (Maybe)
        <spec_sep>
        <type_name>
        <spec_sep>
        <list_open>
            (<literal>?)
        <list_close>
    }

    token seq {
          seq_indexed_values
        | seq_ordered_values
    }

    token seq_indexed_values {
        (Seq)
        <spec_sep>
        (index)
        <spec_sep>
        <type_name>
        <spec_sep>
        <list_open>
            (((<index>) <pair_sep> (<literal>) <list_sep>)*)
        <list_close>
    }

    token index { <uint> }

    token seq_ordered_values {
        (Seq)
        <spec_sep>
        (order)
        <spec_sep>
        <type_name>
        <spec_sep>
        <list_open>
            (((<literal>) <list_sep>)*)
        <list_close>
    }

    token bag {
          bag_counted_values
        | bag_repeated_values
    }

    token bag_counted_values {
        (Bag)
        <spec_sep>
        (count)
        <spec_sep>
        <type_name>
        <spec_sep>
        <list_open>
            (((<literal>) <pair_sep> (<count>) <list_sep>)*)
        <list_close>
    }

    token count { <pint> }

    token bag_repeated_values {
        (Bag)
        <spec_sep>
        (repeat)
        <spec_sep>
        <type_name>
        <spec_sep>
        <list_open>
            (((<literal>) <list_sep>)*)
        <list_close>
    }

    token list_open { '{' \s+ }

    token list_close { \s+ '}' }

    token list_sep { ',' \s+ }

    token pair_sep { \s+ '=>' \s+ }

    token type_name { <quoted_name_chain_str> }

    token spec_sep { ':' }

    token quoted_text_str {
        <text_delim>
            (<text_char>*)
        <text_delim>
    }

    token quoted_name_chain_str {
        <text_delim>
            ((<nc_elem_char>+) (<nc_elem_sep> (<nc_elem_char>+))*)
        <text_delim>
    }

    token text_delim { <[']> }

    token text_char { ['\b'|'\q'|<-[\\\']>] }

    token nc_elem_sep { '.' }

    token nc_elem_char { ['\b'|'\q'|'\p'|<-[\\\'\.]>] }

    token cat_name {
        (Cat.Name)
        <spec_sep>
        <quoted_text_str>
    }

    token cat_name_chain {
        (Cat.NameChain)
        <spec_sep>
        <quoted_name_chain_str>
    }

    token cat_order { (Cat.Order) <spec_sep> (increase|same|decrease) }

    token cat_e_rm {
        (Cat.E_RM)
        <spec_sep>
        (half_up|to_even|to_floor|to_ceiling|to_zero)
    }

    token cat_e_tk {
        (Cat.E_TK)
        <spec_sep>
        (special|scalar|tuple|relation|quasi_tuple|quasi_relation|remnant)
    }

    token cat_e_tdm {
        (Cat.E_TDM)
        <spec_sep>
        (special|root|restriction|alias
            |union|intersection|exclusion|difference|negation)
    }

    token cat_e_enk {
        (Cat.E_ENK)
        <spec_sep>
        (default|scalar|tuple|relation|quasi_tuple|quasi_relation
            |param|upd_param|ro_param|func)
    }

    token cat_e_psak {
        (Cat.E_PSAK)
        <spec_sep>
        (default|upd_param|ro_param|inner_var|outer_var)
    }

=head1 EXAMPLES

The following are fragments of actual Concrete Muldis D code.

    MuldisD:'cpan:DUNCAND':'1.2.3':{ Bool:false }

    Bool:true

    Int:1:11001001

    Int:7:0

    Int:7:644

    Int:9:-34

    Int:9:42

    Int:F:DEADBEEF

    Int:Z:-HELLOWORLD

    UInt:3:301

    PInt:B:A09B

    Rat:radix:1:-1.1

    Rat:radix:9:-1.5

    Rat:radix:9:3.14159

    Rat:radix:A:0.0

    Rat:radix:F:DEADBEEF.FACE

    Rat:radix:Z:0.000AZE

    Rat:pair:6:500001/1000

    Rat:pair:B:A09B/10

    Blob:1:00101110100010

    Blob:3:

    Blob:F:A705E

    Blob:7:523504376

    Text:'Ceres'

    Text:'サンプル'

    Text:''

    Text:'Perl'

    Tuple:'sys.Core.Tuple.D0':{}

    Tuple:'fed.the_db.account.user_t':{
        'login_name' => Text:'hartmark',
        'login_pass' => Text:'letmein',
        'is_special' => Bool:true,
    }

    Tuple:'fed.the_db.gene.person_t':{
        'name' => Text:'Michelle',
        'age'  => Int:9:17,
    }

    Tuple:'fed.the_db.account':{
        'user' => Relation:'fed.the_db.account.user_r':{ ... },
    }

    Tuple:'fed.the_db.gene':{
        'person' => Relation:'fed.the_db.gene.person_r':{ ... },
    }

    Relation:'sys.Core.Relation.D0':{}

    Relation:'sys.Core.Relation.D0':{ {}, }

    Relation:'fed.the_db.account.user_r':{
        {
            'login_name' => Text:'hartmark',
            'login_pass' => Text:'letmein',
            'is_special' => Bool:true,
        },
    }

    Relation:'fed.the_db.gene.person_r':{
        {
            'name' => Text:'Michelle',
            'age'  => Int:9:17,
        },
    }

    Set:'fed.the_db.account.country_name':{
        Text:'Canada',
        Text:'Spain',
        Text:'Jordan',
        Text:'Thailand',
    }

    Set:'fed.the_db.stats.some_ages':{
        Int:9:3,
        Int:9:16,
        Int:9:85,
    }

    Maybe:'fed.the_db.gene.person_death_date':{}

    Maybe:'fed.the_db.gene.person_death_date':{
        Text:'2003.07.24',
    }

    Seq:index:'fed.the_db.gene.sorted_person_name':{
        UInt:9:0 => Text:'Alphonse',
        UInt:9:1 => Text:'Edward',
        UInt:9:2 => Text:'Winry',
    }

    Seq:order:'fed.the_db.stats.samples_by_order':{
        Int:9:57,
        Int:9:45,
        Int:9:63,
        Int:9:61,
    }

    Bag:count:'fed.the_db.inventory.fruit':{
        Text:'Apple'  => PInt:9:500,
        Text:'Orange' => PInt:9:300,
        Text:'Banana' => PInt:9:400,
    }

    Bag:repeat:'fed.the_db.inventory.whatsits':{
        Text:'Foo',
        Text:'Quux',
        Text:'Foo',
        Text:'Bar',
        Text:'Baz',
        Text:'Baz',
    }

    Cat.Name:'login_pass'

    Cat.Name:'First Name'

    Cat.NameChain:'fed.the_db.gene.sorted_person_name'

    Cat.NameChain:'fed.the_db.stats.samples_by_order'

    Cat.Order:same

    Cat.E_RM:half_up

    Cat.E_TK:scalar

    Cat.E_TDM:alias

    Cat.E_ENK:default

    Cat.E_PSAK:ro_param

=head1 SEE ALSO

Go to L<Language::MuldisD> for the majority of distribution-internal
references, and L<Language::MuldisD::SeeAlso> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<perl@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2008, Darren Duncan.

See the LICENSE AND COPYRIGHT of L<Language::MuldisD> for details.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Language::MuldisD> apply to this file too.

=cut
