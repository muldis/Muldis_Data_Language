                                 Muldis::D
---------------------------------------------------------------------------

Following is a summary of things that still need doing.  It is specific to
the Muldis D specification distribution only, and doesn't talk about things
that would go in other distributions, including implementations.  (But,
look at lib/Muldis/D/SeeAlso.pod for a list of actual or possible
implementations.)

Alternately, this list deals with possible ideas to explore, which may or
may not be good ideas to pursue.

The following list is loosely ordered by priority, but list items may
actually be addressed in a different order.  There is no specific time
table for these items; they are simply to be done "as soon as possible".

* Generally speaking, make a new release to CPAN once every week, assuming
the progress is non-trivial, so there are regular public snapshots with
nicely rendered documentation.

* Consider changing the keywords in system-defined routine signatures,
specifically [result, params, update, read], to something better sounding.

* Expand the catalog types for defining nonscalar types so to add
short-hand syntax for foreign key constraints.

* Add catalog types that represent thrown exceptions.

* Add virtual relvars aka virtual dbvar attributes, that resemble a type
constraint or something, as per scalar possrep mapping functions.

* Add transition constraints.  The initial version would simply take a
'before' and an 'after' state argument.  But it may be good to provide an
alternative where arguments show the delta since often that is what
constraint writers want to know anyway.

* Add other kinds of triggered routines.

* Add some automatic code completion to the two Tiny dialects or as a
general function, mainly so that tuples comprising catalogs don't have to
be written out in full; attributes may be omitted by the coders but will be
automatically added with default attribute values at parsing time, when
converting Muldis D source from the Tiny dialect to the actual catalog.  As
far as the Muldis D catalog is concerned, the users had always written them
out in full.  Specific use case example is that programmers can omit
'comment' attributes, or empty sets of expression nodes that aren't used.

* Update Text.pod (or add other extensions) to add general search and
replace or transliteration or regular expression et al functionality,
besides the bare minimum SQL-LIKE-alike currently provided.

* Add functions for comparing or processing continuous ranges or intervals
as per is_inside_range ... the tests are for eg if 2 ranges do or don't
overlap, or whether an overlap is specifically between the start of one and
the end of another, or whether ranges simply touch, or whether a range is
entirely within another or not, etc ... some are analagous to set
operations, but not so much as they talk about continous intervals, or as
continuous such as the type in question supports ... useful particularly
for use with date data types.  as for supporting non-continuous ranges,
which are probably represented by sets of continuous ranges, that might be
simple enough to support here too ... or some range stuff might go off to
another extension perhaps or perhaps not.

* Consider adding catalog types, eg expression node kinds or statement
kinds, specific to certain control flow operators whose required semantics
don't fit into the general model.  For example, the 'if' expression
requires short-circuit evaluation to work properly while generally
everything else does not.  And maybe these additions will help things like
if-elseif-elseif-else-etc to be easier to express.  Or maybe not.  And once
starting down this road, where will it end?  Maybe such additions are
mainly more useful for the statement side of things.  Or control flow
expressions are still okay.  But keep in mind that users should be able to
define their own of whatever or something.  Yadda yadda.

* Define more flow control operators like IF/ELSE, GIVEN/WHEN, etc.  Both
functional and imperative versions.  Also add generic I/O routines.

* Define short-hand data definition procedures analagous to SQL's CREATE,
ALTER, DROP etc.  Note that these are not short-hand for inserting records
into catalogs, at least when the code doing either is an updater or
procedure.  Rather, these procedures are mainly for making bootloaders
work, since those can not directly invoke variables such as the catalogs in
order to insert into them.  Probably add new file Core/Routines_Catalog.pod
at the same time, to house them.  Also add sys.std.Core.Cat.Order_reverse
function in that new file; or that function best goes elsewhere?

* Add sequence generator updaters|procedures in Integer.pod.

* Consider adding random value generators for data types other than integer
and rational numerics, such as for character strings or binary strings.

* Consider rewriting the Temporal.pod again, as the current version still
appears to have some serious issues.  One problem is the combinatorial
explosion of types and routines, due to desire to have a wall between
different precisions.  Another problem concerns interaction of plain 'time'
types and time zones, such as what semantics their operators should have.

* Consider providing special literal syntax in the Tiny dialects for values
of temporal data types.  Or don't, since many users of temporal data types
would probably want to define them component-wise (using generic scalar
value selectors), or want to use a different terse format than any the Tiny
could pick.  It's better to leave special temporal value syntax to non-Tiny
dialects.  Also, it reduces bias away from third-party temporal extensions.

* Provide operators for the spatial data types, maybe overhaul the types.

* Update the system catalog to deal with database users and privileges etc.

* Whatever else needs doing, such as, fixing bugs.
